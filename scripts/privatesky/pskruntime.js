pskruntimeRequire=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"/opt/privatesky/builds/tmp/pskruntime.js":[function(require,module,exports){
require("../../modules/callflow/lib/overwriteRequire")

require("./pskruntime_intermediar");

require("callflow");

console.log("Loading runtime: callflow module ready");
},{"../../modules/callflow/lib/overwriteRequire":"/opt/privatesky/modules/callflow/lib/overwriteRequire.js","./pskruntime_intermediar":"/opt/privatesky/builds/tmp/pskruntime_intermediar.js","callflow":"callflow"}],"/opt/privatesky/builds/tmp/pskruntime_intermediar.js":[function(require,module,exports){
(function (global){
global.pskruntimeLoadModules = function(){ 
	$$.__runtimeModules["callflow"] = require("callflow");
	$$.__runtimeModules["launcher"] = require("launcher");
	$$.__runtimeModules["double-check"] = require("double-check");
	$$.__runtimeModules["pskcrypto"] = require("pskcrypto");
	$$.__runtimeModules["dicontainer"] = require("dicontainer");
	$$.__runtimeModules["swarmutils"] = require("swarmutils");
	$$.__runtimeModules["soundpubsub"] = require("soundpubsub");
	$$.__runtimeModules["pskbuffer"] = require("pskbuffer");
	$$.__runtimeModules["foldermq"] = require("foldermq");
	$$.__runtimeModules["domainBase"] = require("domainBase");
	$$.__runtimeModules["utils"] = require("utils");
	$$.__runtimeModules["@msgpack/msgpack"] = require("@msgpack/msgpack");
	$$.__runtimeModules["psklogger"] = require("psklogger");
}
if (false) {
	pskruntimeLoadModules();
}; 
global.pskruntimeRequire = require;
if (typeof $$ !== "undefined") {            
    $$.requireBundle("pskruntime");
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@msgpack/msgpack":"@msgpack/msgpack","callflow":"callflow","dicontainer":"dicontainer","domainBase":"domainBase","double-check":"double-check","foldermq":"foldermq","launcher":"launcher","pskbuffer":"pskbuffer","pskcrypto":"pskcrypto","psklogger":"psklogger","soundpubsub":"soundpubsub","swarmutils":"swarmutils","utils":"utils"}],"/opt/privatesky/libraries/domainBase/domainPubSub.js":[function(require,module,exports){
var pubSub = $$.require("soundpubsub").soundPubSub;
const path = require("path");
const fs = require("fs");

exports.create = function(folder, codeFolder ){

    $$.PSK_PubSub = pubSub;
    var sandBoxesRoot = path.join(folder, "sandboxes");

    try{
        fs.mkdirSync(sandBoxesRoot, {recursive: true});
    }catch(err){
        console.log("Failed to create sandboxes dir structure!", err);
        //TODO: maybe it is ok to call process.exit ???
    }

    $$.SandBoxManager = require("../../psknode/core/sandboxes/util/SandBoxManager").create(sandBoxesRoot, codeFolder, function(err, res){
        console.log($$.DI_components.sandBoxReady, err, res);
        $$.container.resolve($$.DI_components.sandBoxReady, true);
    });

    return pubSub;
};

},{"../../psknode/core/sandboxes/util/SandBoxManager":"/opt/privatesky/psknode/core/sandboxes/util/SandBoxManager.js","fs":false,"path":"path"}],"/opt/privatesky/libraries/launcher/components.js":[function(require,module,exports){
$$.DI_components = {
   swarmIsReady:"SwarmIsReady",
   configLoaded:"configLoaded",
   sandBoxReady:"SandBoxReady",
   localNodeAPIs:"localNodeAPIs"
}

},{}],"/opt/privatesky/libraries/utils/FSExtension.js":[function(require,module,exports){
(function (__dirname){
const fs = require("fs");
const path = require("path");
const os = require("os");
const child_process = require('child_process');
const crypto = require('crypto');

// if this is set to true, the logs will be available. Default (false)
const DEBUG =  process.env.DEPLOYER_DEBUG || false;

function FSExtention(){

    /**
     * Base path used to resolve all relative paths in the actions bellow.
     * Default is set to two levels up from the current directory. This can be changed using __setBasePath.
     * @type {*|string}
     */
    var basePath = path.join(__dirname, "../../");

    /**
     * Set the base path to a different absolute directory path.
     * @param wd {String} absolute directory path.
     * @private
     */
    var __setBasePath = function(wd) {
        basePath = path.resolve(wd);
    }

    /**
     * Resolve path into an absolute path. If filePath is relative, the path is resolved using the basePath as first argument.
     * @param filePath {String} relative or absolute file path.
     * @returns {String} absolute path
     * @private
     */
    var __resolvePath = function(filePath) {
        if(path.isAbsolute(filePath)) {
            return filePath;
        }

        return path.resolve(basePath, filePath);
    }

    /**
     * If the directory structure does not exist, it is created. Like mkdir -p
     * @param dir {String} dir path
     * @private
     */
    var __createDir = function(dir) {
        dir = __resolvePath(dir);
        if (fs.existsSync(dir)) {
            log(dir + " already exist! Continuing ...")
            return;
        }

        var isWin = (os.platform() === 'win32');
        var cmd = isWin ? "mkdir " : "mkdir -p ";

        child_process.execSync(cmd + "\""+dir+"\"", {stdio:[0,1,2]});
    }

    /**
     * Copy a file or directory. The directory can have recursive contents. Like copy -r.
     * NOTE: If src is a directory it will copy everything inside of the directory, not the entire directory itself.
     * NOTE: If src is a file, target cannot be a directory.
     * NOTE: If the destination path structure does not exists, it will be created.
     * @param src {String} Source file|directory path.
     * @param dest {String} Destination file|directory path.
     * @param options {Object} Optional parameters for copy action. Available options:
     *  - overwrite <Boolean>: overwrite existing file or directory, default is true.
     *  Note that the copy operation will silently fail if this is set to false and the destination exists.
     * @param callback {Function}
     * @private
     */
    var __copy = function (src, dest, options, callback) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        callback = callback || function(){};
        let rethrow = false;

        try{
            if (!fs.existsSync(src)) {
                rethrow = true;
                throw `Source directory or file "${src}" does not exists!`;
            }

            let srcStat = fs.lstatSync(src);
            if(srcStat.isDirectory()) {
                __copyDir(src, dest, options);
            } else if(srcStat.isFile()) {
                // destination must be a file too
                __copyFile(src, dest, options);
            }
        } catch (err) {
            if(rethrow){
                throw err;
            }
            log(err, true);
            callback(err);
            return;
        }

        callback();
    }

    /**
     * Copy a directory. The directory can have recursive contents. Like copy -r.
     * NOTE: Itt will copy everything inside of the directory, not the entire directory itself.
     * NOTE: If the destination path structure does not exists, it will be created.
     * @param src {String} Source directory path.
     * @param dest {String} Destination directory path.
     * @param options {Object} Optional parameters for copy action. Available options:
     *  - overwrite <Boolean>: overwrite existing directory, default is true.
     *  Note that the copy operation will silently fail if this is set to false and the destination exists.
     * @private
     */
    var __copyDir = function(src, dest, options) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        __createDir(dest);

        var files = fs.readdirSync(src);
        for(var i = 0; i < files.length; i++) {
            let current = fs.lstatSync(path.join(src, files[i]));
            let newSrc = path.join(src, files[i]);
            let newDest = path.join(dest, files[i]);

            if(current.isDirectory()) {
                __copyDir(newSrc, newDest, options);
            } else if(current.isSymbolicLink()) {
                var symlink = fs.readlinkSync(newSrc);
                fs.symlinkSync(symlink, newDest);
            } else {
                __copyFile(newSrc, newDest, options);
            }
        }
    };

    /**
     * Copy a file.
     * NOTE: If src is a file, target cannot be a directory.
     * NOTE: If the destination path structure does not exists, it will be created.
     * @param src {String} Source file path.
     * @param dest {String} Destination file path.
     * @param options {Object} Optional parameters for copy action. Available options:
     *  - overwrite <Boolean>: overwrite existing file or directory, default is true.
     *  Note that the copy operation will silently fail if this is set to false and the destination exists.
     * @param callback {Function}
     * @private
     */
    var __copyFile = function(src, dest, options) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        if(options && options.overwrite === false) {
            if (fs.existsSync(dest)) {
                // silently fail if overwrite is set to false and the destination exists.
                let error = `Silent fail - cannot copy. Destination file ${dest} already exists and overwrite option is set to false! Continuing...`;
                log(error, true);
                return;
            }
        }
        __createDir(path.dirname(dest));

        var content = fs.readFileSync(src, "utf8");
        fs.writeFileSync(dest, content);
    }

    /**
     * Removes a file or directory. The directory can have recursive contents. Like rm -rf
     * @param src {String} Path
     * @param callback {Function}
     * @private
     */
    var __remove = function(src, callback) {
        src = __resolvePath(src);

        callback = callback || function(){};

        log(`Removing ${src}`);

        try{
            let current = fs.lstatSync(src);
            if(current.isDirectory()) {
                __rmDir(src);
            } else if(current.isFile()) {
                __rmFile(src);
            }
        } catch (err) {
            if(err.code && err.code === "ENOENT"){
                //ignoring errors like "file/directory does not exist"
                err = null;
            }else{
                log(err, true);
            }
            callback(err);
            return;
        }

        callback();
    }

    /**
     * Removes a directory. The directory can have recursive contents. Like rm -rf
     * @param dir {String} Path
     * @private
     */
    var __rmDir = function (dir) {
        dir = __resolvePath(dir);

        if (!fs.existsSync(dir)) {
            log(`Directory ${dir} does not exist!`, true);
            return;
        }

        var list = fs.readdirSync(dir);
        for (var i = 0; i < list.length; i++) {
            var filename = path.join(dir, list[i]);
            var stat = fs.lstatSync(filename);

            if (stat.isDirectory()) {
                __rmDir(filename, null);
            } else {
                // rm filename
                fs.unlinkSync(filename);
            }
        }

        fs.rmdirSync(dir);
    }

    /**
     * Removes a file.
     * @param file {String} Path
     * @private
     */
    var __rmFile = function(file) {
        file = __resolvePath(file);
        if (!fs.existsSync(file)) {
            log(`File ${file} does not exist!`, true);
            return;
        }

        fs.unlinkSync(file);
    }

    /**
     * Writes data to a file, replacing the file if it already exists.
     * @param file {String} Path.
     * @param data {String}
     * @private
     */
    var __createFile = function(file, data, options) {
        file = __resolvePath(file)
        fs.writeFileSync(file, data, options);
    }

    /**
     * Moves a file or directory.
     * @param src {String} Source path.
     * @param dest {String} Destination path.
     * @param options {Object}. Optional parameters for copy action. Available options:
     *  - overwrite <boolean>: overwrite existing file or directory, default is false. Note that the move operation will silently fail if you set this to true and the destination exists.
     * @param callback {Function}
     * @private
     */
    var __move = function(src, dest, options, callback) {
        src = __resolvePath(src);
        dest = __resolvePath(dest);

        callback = callback || function(){};

        try {
            if(options && options.overwrite === false) {
                if (fs.existsSync(dest)) {
                    // silently fail if overwrite is set to false and the destination exists.
                    let error = `Silent fail - cannot move. Destination file ${dest} already exists and overwrite option is set to false! Continuing...`;
                    log(error, true);
                    callback();
                    return;
                }
            }

            __copy(src, dest, options);
            __remove(src);
        }catch(err) {
            callback(err);
            return;
        }
        callback();
    }

    /**
     * Computes checksum to a file or a directory based on their contents only.
     * If the source is directory, the checksum is a hash of all concatenated file hashes.
     * @param src {String} Path of a file or directory.
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Checksum of the file or directory.
     * @private
     */
    var __checksum = function(src, algorithm, encoding) {
        src = __resolvePath(src);

        if (!fs.existsSync(src)) {
            throw `Path ${src} does not exists!`;
        }

        var checksum = "";
        let current = fs.lstatSync(src);
        if(current.isDirectory()) {
            let hashDir = __hashDir(src, algorithm, encoding);
            checksum = hashDir["hash"];
        } else if(current.isFile()) {
            checksum = __hashFile(src, algorithm, encoding);
        }

        return checksum;
    }

    /**
     * Computes hash of a string.
     * @param str {String}
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Hash of the string.
     * @private
     */
    var __hash =  function(str, algorithm, encoding) {
        return crypto
            .createHash(algorithm || 'md5')
            .update(str, 'utf8')
            .digest(encoding || 'hex')
    }

    /**
     * Computes hash of a file based on its content only.
     * @param src {String} Path of a file.
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Hash of the file.
     * @private
     */
    var __hashFile = function(src, algorithm, encoding) {
        src = __resolvePath(src);
        if (!fs.existsSync(src)) {
            throw `${src} does not exist!`;
        }

        var content = fs.readFileSync(src, "utf8");
        return __hash(content, algorithm, encoding);
    }

    /**
     * Computes hash of a directory based on its content only.
     * If directory has multiple files, the result is a hash of all concatenated file hashes.
     * @param src {String} Path of a directory.
     * @param algorithm {String} Hashing algorithm(default: md5). The algorithm is dependent on the available algorithms
     * supported by the version of OpenSSL on the platform. E.g. 'md5', 'sha256', 'sha512'.
     * @param encoding {String} Hashing encoding (default: 'hex'). The encoding is dependent on the
     * available digest algorithms. E.g. 'hex', 'latin1' or 'base64'.
     * @returns {String} Hash of the directory.
     * @private
     */
    var __hashDir = function(dir, algorithm, encoding) {
        dir = __resolvePath(dir);
        if (!fs.existsSync(dir)) {
            throw `Directory ${dir} does not exist!`;
        }
        var hashes = {};
        var list = fs.readdirSync(dir);
        for (var i = 0; i < list.length; i++) {
            var filename = path.join(dir, list[i]);
            var stat = fs.lstatSync(filename);

            if (stat.isDirectory()) {
                let tempHashes = __hashDir(filename, algorithm, encoding);
                hashes = Object.assign(hashes, tempHashes["sub-hashes"]);
            } else {
                let tempHash = __hashFile(filename, algorithm, encoding);
                hashes[filename] = tempHash;
            }
        }

        // compute dir hash
        let dirContent = Object.keys(hashes).reduce(function (previous, key) {
            return previous += hashes[key];
        }, "");

        let dirHash = __hash(dirContent, algorithm, encoding);

        return {
            "hash": dirHash,
            "sub-hashes": hashes
        }
    }

    /**
     * Generates a guid (global unique identifier).
     * @returns {String} Guid in the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
     * @private
     */
    var __guid = function guid() {
        function _make_group(s) {
            var p = (Math.random().toString(16)+"000000000").substr(2,8);
            return s ? "-" + p.substr(0,4) + "-" + p.substr(4,4) : p ;
        }
        return _make_group() + _make_group(true) + _make_group(true) + _make_group();
    }

    /**
     * Logs wrapper.
     * @param message {String}
     * @param isError {Boolean}
     */
    function log(message, isError) {
        let logger = isError ? console.error : console.log;

        if(DEBUG) {
            logger(message);
        }
    }

    return {
        setBasePath: __setBasePath,
        resolvePath: __resolvePath,
        createDir: __createDir,
        copyDir: __copyDir,
        rmDir: __rmDir,
        rmFile: __rmFile,
        createFile: __createFile,
        copy: __copy,
        move: __move,
        remove: __remove,
        checksum: __checksum,
        guid: __guid
    }
}

module.exports.fsExt = new FSExtention();
}).call(this,"/libraries/utils")

},{"child_process":false,"crypto":"crypto","fs":false,"os":"os","path":"path"}],"/opt/privatesky/modules/callflow/constants.js":[function(require,module,exports){
$$.CONSTANTS = {
    SWARM_FOR_EXECUTION:"swarm_for_execution",
    INBOUND:"inbound",
    OUTBOUND:"outbound",
    PDS:"PrivateDataSystem",
    CRL:"CommunicationReplicationLayer",
    SWARM_RETURN: 'swarm_return',
    BEFORE_INTERCEPTOR: 'before',
    AFTER_INTERCEPTOR: 'after',
};


},{}],"/opt/privatesky/modules/callflow/lib/InterceptorRegistry.js":[function(require,module,exports){
// related to: SwarmSpace.SwarmDescription.createPhase()

function InterceptorRegistry() {
    const rules = new Map();

    // ??? $$.errorHandler Library ???
    const _CLASS_NAME = 'InterceptorRegistry';

    /************* PRIVATE METHODS *************/

    function _throwError(err, msg) {
        console.error(err.message, `${_CLASS_NAME} error message:`, msg);
        throw err;
    }

    function _warning(msg) {
        console.warn(`${_CLASS_NAME} warning message:`, msg);
    }

    const getWhenOptions = (function () {
        let WHEN_OPTIONS;
        return function () {
            if (WHEN_OPTIONS === undefined) {
                WHEN_OPTIONS = Object.freeze([
                    $$.CONSTANTS.BEFORE_INTERCEPTOR,
                    $$.CONSTANTS.AFTER_INTERCEPTOR
                ]);
            }
            return WHEN_OPTIONS;
        };
    })();

    function verifyWhenOption(when) {
        if (!getWhenOptions().includes(when)) {
            _throwError(new RangeError(`Option '${when}' is wrong!`),
                `it should be one of: ${getWhenOptions()}`);
        }
    }

    function verifyIsFunctionType(fn) {
        if (typeof fn !== 'function') {
            _throwError(new TypeError(`Parameter '${fn}' is wrong!`),
                `it should be a function, not ${typeof fn}!`);
        }
    }

    function resolveNamespaceResolution(swarmTypeName) {
        if (swarmTypeName === '*') {
            return swarmTypeName;
        }

        return (swarmTypeName.includes(".") ? swarmTypeName : ($$.libraryPrefix + "." + swarmTypeName));
    }

    /**
     * Transforms an array into a generator with the particularity that done is set to true on the last element,
     * not after it finished iterating, this is helpful in optimizing some other functions
     * It is useful if you want call a recursive function over the array elements but without popping the first
     * element of the Array or sending the index as an extra parameter
     * @param {Array<*>} arr
     * @return {IterableIterator<*>}
     */
    function* createArrayGenerator(arr) {
        const len = arr.length;

        for (let i = 0; i < len - 1; ++i) {
            yield arr[i];
        }

        return arr[len - 1];
    }

    /**
     * Builds a tree like structure over time (if called on the same root node) where internal nodes are instances of
     * Map containing the name of the children nodes (each child name is the result of calling next on `keysGenerator)
     * and a reference to them and on leafs it contains an instance of Set where it adds the function given as parameter
     * (ex: for a keyGenerator that returns in this order ("key1", "key2") the resulting structure will be:
     * {"key1": {"key1": Set([fn])}} - using JSON just for illustration purposes because it's easier to represent)
     * @param {Map} rulesMap
     * @param {IterableIterator} keysGenerator - it has the particularity that done is set on last element, not after it
     * @param {function} fn
     */
    function registerRecursiveRule(rulesMap, keysGenerator, fn) {
        const {value, done} = keysGenerator.next();

        if (!done) { // internal node
            const nextKey = rulesMap.get(value);

            if (typeof nextKey === 'undefined') { // if value not found in rulesMap
                rulesMap.set(value, new Map());
            }

            registerRecursiveRule(rulesMap.get(value), keysGenerator, fn);
        } else { // reached leaf node
            if (!rulesMap.has(value)) {

                rulesMap.set(value, new Set([fn]));
            } else {
                const set = rulesMap.get(value);

                if (set.has(fn)) {
                    _warning(`Duplicated interceptor for '${key}'`);
                }

                set.add(fn);
            }
        }
    }

    /**
     * Returns the corresponding set of functions for the given key if found
     * @param {string} key - formatted as a path without the first '/' (ex: swarmType/swarmPhase/before)
     * @return {Array<Set<function>>}
     */
    function getInterceptorsForKey(key) {
        if (key.startsWith('/')) {
            _warning(`Interceptor called on key ${key} starting with '/', automatically removing it`);
            key = key.substring(1);
        }

        const keyElements = key.split('/');
        const keysGenerator = createArrayGenerator(keyElements);

        return getValueRecursively([rules], keysGenerator);
    }

    /**
     * It works like a BFS search returning the leafs resulting from traversing the internal nodes with corresponding
     * names given for each level (depth) by `keysGenerator`
     * @param {Array<Map>} searchableNodes
     * @param {IterableIterator} keysGenerator - it has the particularity that done is set on last element, not after it
     * @return {Array<Set<function>>}
     */
    function getValueRecursively(searchableNodes, keysGenerator) {
        const {value: nodeName, done} = keysGenerator.next();

        const nextNodes = [];

        for (const nodeInRules of searchableNodes) {
            const nextNodeForAll = nodeInRules.get('*');
            const nextNode = nodeInRules.get(nodeName);

            if (typeof nextNode !== "undefined") {
                nextNodes.push(nextNode);
            }

            if (typeof nextNodeForAll !== "undefined") {
                nextNodes.push(nextNodeForAll);
            }

        }

        if (done) {
            return nextNodes;
        }

        return getValueRecursively(nextNodes, keysGenerator);
    }


    /************* PUBLIC METHODS *************/

    this.register = function (swarmTypeName, phaseName, when, fn) {
        verifyWhenOption(when);
        verifyIsFunctionType(fn);

        const resolvedSwarmTypeName = resolveNamespaceResolution(swarmTypeName);
        const keys = createArrayGenerator([resolvedSwarmTypeName, phaseName, when]);

        registerRecursiveRule(rules, keys, fn);
    };

    // this.unregister = function () { }

    this.callInterceptors = function (key, targetObject, args) {
        const interceptors = getInterceptorsForKey(key);

        if (interceptors) {
            for (const interceptorSet of interceptors) {
                for (const fn of interceptorSet) { // interceptors on key '*' are called before those specified by name
                    fn.apply(targetObject, args);
                }
            }
        }
    };
}


exports.createInterceptorRegistry = function () {
    return new InterceptorRegistry();
};

},{}],"/opt/privatesky/modules/callflow/lib/choreographies/SwarmDebug.js":[function(require,module,exports){
/*
 Initial License: (c) Axiologic Research & Alboaie Sînică.
 Contributors: Axiologic Research , PrivateSky project
 Code License: LGPL or MIT.
 */

var util = require("util");
var fs = require("fs");
cprint = console.log;
wprint = console.warn;
dprint = console.debug;
eprint = console.error;


/**
 * Shortcut to JSON.stringify
 * @param obj
 */
J = function (obj) {
    return JSON.stringify(obj);
}


/**
 * Print swarm contexts (Messages) and easier to read compared with J
 * @param obj
 * @return {string}
 */
exports.cleanDump = function (obj) {
    var o = obj.valueOf();
    var meta = {
        swarmTypeName:o.meta.swarmTypeName
    };
    return "\t swarmId: " + o.meta.swarmId + "{\n\t\tmeta: "    + J(meta) +
        "\n\t\tpublic: "        + J(o.publicVars) +
        "\n\t\tprotected: "     + J(o.protectedVars) +
        "\n\t\tprivate: "       + J(o.privateVars) + "\n\t}\n";
}

//M = exports.cleanDump;
/**
 * Experimental functions
 */


/*

 logger      = monitor.logger;
 assert      = monitor.assert;
 throwing    = monitor.exceptions;


 var temporaryLogBuffer = [];

 var currentSwarmComImpl = null;

 logger.record = function(record){
 if(currentSwarmComImpl===null){
 temporaryLogBuffer.push(record);
 } else {
 currentSwarmComImpl.recordLog(record);
 }
 }

 var container = require("dicontainer").container;

 container.service("swarmLoggingMonitor", ["swarmingIsWorking", "swarmComImpl"], function(outOfService,swarming, swarmComImpl){

 if(outOfService){
 if(!temporaryLogBuffer){
 temporaryLogBuffer = [];
 }
 } else {
 var tmp = temporaryLogBuffer;
 temporaryLogBuffer = [];
 currentSwarmComImpl = swarmComImpl;
 logger.record = function(record){
 currentSwarmComImpl.recordLog(record);
 }

 tmp.forEach(function(record){
 logger.record(record);
 });
 }
 })

 */
uncaughtExceptionString = "";
uncaughtExceptionExists = false;
if(typeof globalVerbosity == 'undefined'){
    globalVerbosity = false;
}

var DEBUG_START_TIME = new Date().getTime();

function getDebugDelta(){
    var currentTime = new Date().getTime();
    return currentTime - DEBUG_START_TIME;
}

/**
 * Debug functions, influenced by globalVerbosity global variable
 * @param txt
 */
dprint = function (txt) {
    if (globalVerbosity == true) {
        if (thisAdapter.initilised ) {
            console.log("DEBUG: [" + thisAdapter.nodeName + "](" + getDebugDelta()+ "):"+txt);
        }
        else {
            console.log("DEBUG: (" + getDebugDelta()+ "):"+txt);
            console.log("DEBUG: " + txt);
        }
    }
}

/**
 * obsolete!?
 * @param txt
 */
aprint = function (txt) {
    console.log("DEBUG: [" + thisAdapter.nodeName + "]: " + txt);
}



/**
 * Utility function usually used in tests, exit current process after a while
 * @param msg
 * @param timeout
 */
delayExit = function (msg, retCode,timeout) {
    if(retCode == undefined){
        retCode = ExitCodes.UnknownError;
    }

    if(timeout == undefined){
        timeout = 100;
    }

    if(msg == undefined){
        msg = "Delaying exit with "+ timeout + "ms";
    }

    console.log(msg);
    setTimeout(function () {
        process.exit(retCode);
    }, timeout);
}


function localLog (logType, message, err) {
    var time = new Date();
    var now = time.getDate() + "-" + (time.getMonth() + 1) + "," + time.getHours() + ":" + time.getMinutes();
    var msg;

    msg = '[' + now + '][' + thisAdapter.nodeName + '] ' + message;

    if (err != null && err != undefined) {
        msg += '\n     Err: ' + err.toString();
        if (err.stack && err.stack != undefined)
            msg += '\n     Stack: ' + err.stack + '\n';
    }

    cprint(msg);
    if(thisAdapter.initilised){
        try{
            fs.appendFileSync(getSwarmFilePath(thisAdapter.config.logsPath + "/" + logType), msg);
        } catch(err){
            console.log("Failing to write logs in ", thisAdapter.config.logsPath );
        }

    }
}


// printf = function (...params) {
//     var args = []; // empty array
//     // copy all other arguments we want to "pass through"
//     for (var i = 0; i < params.length; i++) {
//         args.push(params[i]);
//     }
//     var out = util.format.apply(this, args);
//     console.log(out);
// }
//
// sprintf = function (...params) {
//     var args = []; // empty array
//     for (var i = 0; i < params.length; i++) {
//         args.push(params[i]);
//     }
//     return util.format.apply(this, args);
// }


},{"fs":false,"util":"util"}],"/opt/privatesky/modules/callflow/lib/choreographies/swarm.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	return require("../utilityFunctions/base").createForObject(valueObject, thisObject, localId);
};
},{"../utilityFunctions/base":"/opt/privatesky/modules/callflow/lib/utilityFunctions/base.js"}],"/opt/privatesky/modules/callflow/lib/choreographies/swarmInstancesManager.js":[function(require,module,exports){


function SwarmsInstancesManager(){
    var swarmAliveInstances = {

    }

    this.waitForSwarm = function(callback, swarm, keepAliveCheck){

        function doLogic(){
            var swarmId = swarm.getInnerValue().meta.swarmId;
            var watcher = swarmAliveInstances[swarmId];
            if(!watcher){
                watcher = {
                    swarm:swarm,
                    callback:callback,
                    keepAliveCheck:keepAliveCheck
                }
                swarmAliveInstances[swarmId] = watcher;
            }
        }

        function filter(){
            return swarm.getInnerValue().meta.swarmId;
        }

        //$$.uidGenerator.wait_for_condition(condition,doLogic);
        swarm.observe(doLogic, null, filter);
    }

    function cleanSwarmWaiter(swarmSerialisation){ // TODO: add better mechanisms to prevent memory leaks
        var swarmId = swarmSerialisation.meta.swarmId;
        var watcher = swarmAliveInstances[swarmId];

        if(!watcher){
            $$.errorHandler.warning("Invalid swarm received: " + swarmId);
            return;
        }

        var args = swarmSerialisation.meta.args;
        args.push(swarmSerialisation);

        watcher.callback.apply(null, args);
        if(!watcher.keepAliveCheck()){
            delete swarmAliveInstances[swarmId];
        }
    }

    this.revive_swarm = function(swarmSerialisation){


        var swarmId     = swarmSerialisation.meta.swarmId;
        var swarmType   = swarmSerialisation.meta.swarmTypeName;
        var instance    = swarmAliveInstances[swarmId];

        var swarm;

        if(instance){
            swarm = instance.swarm;
            swarm.update(swarmSerialisation);

        } else {
            swarm = $$.swarm.start(swarmType);
            if(!swarm){
                throw new Error(`Unknown swarm type <${swarmType}>. Check if swarm type is present in domain constituion!`);
            }else{
                swarm.update(swarmSerialisation);
            }

            /*swarm = $$.swarm.start(swarmType, swarmSerialisation);*/
        }

        if (swarmSerialisation.meta.command == "asyncReturn") {
            var co = $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_RETURN, swarmSerialisation);
            console.log("Subscribers listening on", $$.CONSTANTS.SWARM_RETURN, co);
            // cleanSwarmWaiter(swarmSerialisation);
        } else if (swarmSerialisation.meta.command == "executeSwarmPhase") {
            swarm.runPhase(swarmSerialisation.meta.phaseName, swarmSerialisation.meta.args);
        } else {
            console.log("Unknown command", swarmSerialisation.meta.command, "in swarmSerialisation.meta.command");
        }

        return swarm;
    }
}


$$.swarmsInstancesManager = new SwarmsInstancesManager();



},{}],"/opt/privatesky/modules/callflow/lib/loadLibrary.js":[function(require,module,exports){
/*
Initial License: (c) Axiologic Research & Alboaie Sînică.
Contributors: Axiologic Research , PrivateSky project
Code License: LGPL or MIT.
*/

//var fs = require("fs");
//var path = require("path");


function SwarmLibrary(prefixName, folder){
    var self = this;
    function wrapCall(original, prefixName){
        return function(...args){
            //console.log("prefixName", prefixName)
            var previousPrefix = $$.libraryPrefix;
            var previousLibrary = $$.__global.currentLibrary;

            $$.libraryPrefix = prefixName;
            $$.__global.currentLibrary = self;
            try{
                var ret = original.apply(this, args);
                $$.libraryPrefix = previousPrefix ;
                $$.__global.currentLibrary = previousLibrary;
            }catch(err){
                $$.libraryPrefix = previousPrefix ;
                $$.__global.currentLibrary = previousLibrary;
                throw err;
            }
            return ret;
        }
    }

    $$.libraries[prefixName] = this;
    var prefixedRequire = wrapCall(function(path){
        return require(path);
    }, prefixName);

    function includeAllInRoot(folder) {
        if(typeof folder != "string"){
            //we assume that it is a library module properly required with require and containing $$.library
            for(var v in folder){
                $$.registerSwarmDescription(prefixName,v, prefixName + "." + v,  folder[v]);
            }

            var newNames = $$.__global.requireLibrariesNames[prefixName];
            for(var v in newNames){
                self[v] =  newNames[v];
            }
            return folder;
        }


        var res = prefixedRequire(folder); // a library is just a module
        if(typeof res.__autogenerated_privatesky_libraryName != "undefined"){
            var swarms = $$.__global.requireLibrariesNames[res.__autogenerated_privatesky_libraryName];
        } else {
            var swarms = $$.__global.requireLibrariesNames[folder];
        }
            var existingName;
            for(var v in swarms){
                existingName = swarms[v];
                self[v] = existingName;
                $$.registerSwarmDescription(prefixName,v, prefixName + "." + v,  existingName);
            }
        return res;
    }

    function wrapSwarmRelatedFunctions(space, prefixName){
        var ret = {};
        var names = ["create", "describe", "start", "restart"];
        for(var i = 0; i<names.length; i++ ){
            ret[names[i]] = wrapCall(space[names[i]], prefixName);
        }
        return ret;
    }

    this.callflows        = this.callflow   = wrapSwarmRelatedFunctions($$.callflows, prefixName);
    this.swarms           = this.swarm      = wrapSwarmRelatedFunctions($$.swarms, prefixName);
    this.contracts        = this.contract   = wrapSwarmRelatedFunctions($$.contracts, prefixName);
    includeAllInRoot(folder, prefixName);
}

exports.loadLibrary = function(prefixName, folder){
    var existing = $$.libraries[prefixName];
    if(existing ){
        if(!(existing instanceof SwarmLibrary)){
            var sL = new SwarmLibrary(prefixName, folder);
            for(var prop in existing){
                sL[prop] = existing[prop];
            }
            return sL;
        }
        if(folder) {
            $$.errorHandler.warning("Reusing already loaded library " + prefixName + "could be an error!");
        }
        return existing;
    }
    //var absolutePath = path.resolve(folder);
    return new SwarmLibrary(prefixName, folder);
}


},{}],"/opt/privatesky/modules/callflow/lib/overwriteRequire.js":[function(require,module,exports){
(function (global){
/*
 require and $$.require are overwriting the node.js defaults in loading modules for increasing security,speed and making it work to the privatesky runtime build with browserify.
 The privatesky code for domains should work in node and browsers.
 */


if (typeof(window) !== "undefined") {
    global = window;
}


if (typeof(global.$$) == "undefined") {
    global.$$ = {};
    $$.__global = {};
}

if (typeof($$.__global) == "undefined") {
    $$.__global = {};
}

if (typeof($$.__global.requireLibrariesNames) == "undefined") {
    $$.__global.currentLibraryName = null;
    $$.__global.requireLibrariesNames = {};
}


if (typeof($$.__runtimeModules) == "undefined") {
    $$.__runtimeModules = {};
}

require("./../standardGlobalSymbols");

if (typeof(global.functionUndefined) == "undefined") {
    global.functionUndefined = function () {
        console.log("Called of an undefined function!!!!");
        throw new Error("Called of an undefined function");
    };
    if (typeof(global.webshimsRequire) == "undefined") {
        global.webshimsRequire = global.functionUndefined;
    }

    if (typeof(global.domainRequire) == "undefined") {
        global.domainRequire = global.functionUndefined;
    }

    if (typeof(global.pskruntimeRequire) == "undefined") {
        global.pskruntimeRequire = global.functionUndefined;
    }
}

const weAreInbrowser = (typeof ($$.browserRuntime) != "undefined");
const weAreInSandbox = (typeof global.require !== 'undefined');


const pastRequests = {};

function preventRecursiveRequire(request) {
    if (pastRequests[request]) {
        const err = new Error("Preventing recursive require for " + request);
        err.type = "PSKIgnorableError";
        throw err;
    }

}

function disableRequire(request) {
    pastRequests[request] = true;
}

function enableRequire(request) {
    pastRequests[request] = false;
}


function requireFromCache(request) {
    const existingModule = $$.__runtimeModules[request];
    return existingModule;
}

function wrapStep(callbackName) {
    const callback = global[callbackName];

    if (callback === undefined) {
        return null;
    }

    if (callback === global.functionUndefined) {
        return null;
    }

    return function (request) {
        const result = callback(request);
        $$.__runtimeModules[request] = result;
        return result;
    }
}

function tryRequireSequence(originalRequire, request) {
    let arr;
    if (originalRequire) {
        arr = $$.__requireFunctionsChain.slice();
        arr.push(originalRequire);
    } else {
        arr = $$.__requireFunctionsChain;
    }

    preventRecursiveRequire(request);
    disableRequire(request);
    let result;
    const previousRequire = $$.__global.currentLibraryName;
    let previousRequireChanged = false;

    if (!previousRequire) {
        // console.log("Loading library for require", request);
        $$.__global.currentLibraryName = request;

        if (typeof $$.__global.requireLibrariesNames[request] == "undefined") {
            $$.__global.requireLibrariesNames[request] = {};
            //$$.__global.requireLibrariesDescriptions[request]   = {};
        }
        previousRequireChanged = true;
    }
    for (let i = 0; i < arr.length; i++) {
        const func = arr[i];
        try {

            if (func === global.functionUndefined) continue;
            result = func(request);

            if (result) {
                break;
            }

        } catch (err) {
            if (err.type !== "PSKIgnorableError") {
                $$.log("Require encountered an error while loading ", request, "\nCause:\n", err.stack);
            }
        }
    }

    if (!result) {
        $$.log("Failed to load module ", request, result);
    }

    enableRequire(request);
    if (previousRequireChanged) {
        //console.log("End loading library for require", request, $$.__global.requireLibrariesNames[request]);
        $$.__global.currentLibraryName = null;
    }
    return result;
}

if (typeof($$.require) == "undefined") {

    $$.__requireList = ["webshimsRequire", "pskruntimeRequire"];
    $$.__requireFunctionsChain = [];

    $$.requireBundle = function (name) {
        name += "Require";
        $$.__requireList.push(name);
        const arr = [requireFromCache];
        $$.__requireList.forEach(function (item) {
            const callback = wrapStep(item);
            if (callback) {
                arr.push(callback);
            }
        });

        $$.__requireFunctionsChain = arr;
    };

    $$.requireBundle("init");

    if (weAreInbrowser) {
        $$.log("Defining global require in browser");


        global.require = function (request) {

            ///*[requireFromCache, wrapStep(webshimsRequire), , wrapStep(pskruntimeRequire), wrapStep(domainRequire)*]
            return tryRequireSequence(null, request);
        }
    } else
        if (weAreInSandbox) {
        // require should be provided when code is loaded in browserify
        const bundleRequire = require;

        $$.requireBundle('sandboxBase');
        // this should be set up by sandbox prior to
        const sandboxRequire = global.require;
        global.crypto = require('crypto');

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            // console.log('trying to load ', request);

            function tryBundleRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = sandboxRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        const p = path.join(process.cwd(), request);
                        res = sandboxRequire.apply(self, [p]);
                        request = p;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            let res;


            res = tryRequireSequence(tryBundleRequire, request);


            return res;
        }

        global.require = newLoader;

    } else {  //we are in node
        const path = require("path");
        $$.__runtimeModules["crypto"] = require("crypto");
        $$.__runtimeModules["util"] = require("util");

        const Module = require('module');
        $$.__runtimeModules["module"] = Module;

        $$.log("Redefining require for node");

        $$.__originalRequire = Module._load;
        const moduleOriginalRequire = Module.prototype.require;

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            function originalRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = moduleOriginalRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        const p = path.join(process.cwd(), request);
                        res = moduleOriginalRequire.apply(self, [p]);
                        request = p;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            function currentFolderRequire(request) {
                return
            }

            //[requireFromCache, wrapStep(pskruntimeRequire), wrapStep(domainRequire), originalRequire]
            return tryRequireSequence(originalRequire, request);
        }

        Module.prototype.require = newLoader;
    }

    $$.require = require;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../standardGlobalSymbols":"/opt/privatesky/modules/callflow/standardGlobalSymbols.js","crypto":"crypto","module":false,"path":"path","util":"util"}],"/opt/privatesky/modules/callflow/lib/parallelJoinPoint.js":[function(require,module,exports){

var joinCounter = 0;

function ParallelJoinPoint(swarm, callback, args){
    joinCounter++;
    var channelId = "ParallelJoinPoint" + joinCounter;
    var self = this;
    var counter = 0;
    var stopOtherExecution     = false;

    function executionStep(stepFunc, localArgs, stop){

        this.doExecute = function(){
            if(stopOtherExecution){
                return false;
            }
            try{
                stepFunc.apply(swarm, localArgs);
                if(stop){
                    stopOtherExecution = true;
                    return false;
                }
                return true; //everyting is fine
            } catch(err){
                args.unshift(err);
                sendForSoundExecution(callback, args, true);
                return false; //stop it, do not call again anything
            }
        }
    }

    if(typeof callback !== "function"){
        $$.errorHandler.syntaxError("invalid join",swarm, "invalid function at join in swarm");
        return;
    }

    $$.PSK_PubSub.subscribe(channelId,function(forExecution){
        if(stopOtherExecution){
            return ;
        }

        try{
            if(forExecution.doExecute()){
                decCounter();
            } // had an error...
        } catch(err){
            //console.log(err);
            //$$.errorHandler.syntaxError("__internal__",swarm, "exception in the execution of the join function of a parallel task");
        }
    });

    function incCounter(){
        if(testIfUnderInspection()){
            //preventing inspector from increasing counter when reading the values for debug reason
            //console.log("preventing inspection");
            return;
        }
        counter++;
    }

    function testIfUnderInspection(){
        var res = false;
        var constArgv = process.execArgv.join();
        if(constArgv.indexOf("inspect")!==-1 || constArgv.indexOf("debug")!==-1){
            //only when running in debug
            var callstack = new Error().stack;
            if(callstack.indexOf("DebugCommandProcessor")!==-1){
                console.log("DebugCommandProcessor detected!");
                res = true;
            }
        }
        return res;
    }

    function sendForSoundExecution(funct, args, stop){
        var obj = new executionStep(funct, args, stop);
        $$.PSK_PubSub.publish(channelId, obj); // force execution to be "sound"
    }

    function decCounter(){
        counter--;
        if(counter == 0) {
            args.unshift(null);
            sendForSoundExecution(callback, args, false);
        }
    }

    var inner = swarm.getInnerValue();

    function defaultProgressReport(err, res){
        if(err) {
            throw err;
        }
        return {
            text:"Parallel execution progress event",
            swarm:swarm,
            args:args,
            currentResult:res
        };
    }

    function mkFunction(name){
        return function(...args){
            var f = defaultProgressReport;
            if(name != "progress"){
                f = inner.myFunctions[name];
            }
            var args = $$.__intern.mkArgs(args, 0);
            sendForSoundExecution(f, args, false);
            return __proxyObject;
        }
    }


    this.get = function(target, prop, receiver){
        if(inner.myFunctions.hasOwnProperty(prop) || prop == "progress"){
            incCounter();
            return mkFunction(prop);
        }
        return swarm[prop];
    };

    var __proxyObject;

    this.__setProxyObject = function(p){
        __proxyObject = p;
    }
}

exports.createJoinPoint = function(swarm, callback, args){
    var jp = new ParallelJoinPoint(swarm, callback, args);
    var inner = swarm.getInnerValue();
    var p = new Proxy(inner, jp);
    jp.__setProxyObject(p);
    return p;
};
},{}],"/opt/privatesky/modules/callflow/lib/serialJoinPoint.js":[function(require,module,exports){

var joinCounter = 0;

function SerialJoinPoint(swarm, callback, args){

    joinCounter++;

    var self = this;
    var channelId = "SerialJoinPoint" + joinCounter;

    if(typeof callback !== "function"){
        $$.errorHandler.syntaxError("unknown", swarm, "invalid function given to serial in swarm");
        return;
    }

    var inner = swarm.getInnerValue();


    function defaultProgressReport(err, res){
        if(err) {
            throw err;
        }
        return res;
    }


    var functionCounter     = 0;
    var executionCounter    = 0;

    var plannedExecutions   = [];
    var plannedArguments    = {};

    function mkFunction(name, pos){
        //console.log("Creating function ", name, pos);
        plannedArguments[pos] = undefined;

        function triggetNextStep(){
            if(plannedExecutions.length == executionCounter || plannedArguments[executionCounter] )  {
                $$.PSK_PubSub.publish(channelId, self);
            }
        }

        var f = function (...args){
            if(executionCounter != pos) {
                plannedArguments[pos] = args;
                //console.log("Delaying function:", executionCounter, pos, plannedArguments, arguments, functionCounter);
                return __proxy;
            } else{
                if(plannedArguments[pos]){
                    //console.log("Executing  function:", executionCounter, pos, plannedArguments, arguments, functionCounter);
					args = plannedArguments[pos];
                } else {
                    plannedArguments[pos] = args;
                    triggetNextStep();
                    return __proxy;
                }
            }

            var f = defaultProgressReport;
            if(name != "progress"){
                f = inner.myFunctions[name];
            }


            try{
                f.apply(self,args);
            } catch(err){
                    args.unshift(err);
                    callback.apply(swarm,args); //error
                    $$.PSK_PubSub.unsubscribe(channelId,runNextFunction);
                return; //terminate execution with an error...!
            }
            executionCounter++;

            triggetNextStep();

            return __proxy;
        };

        plannedExecutions.push(f);
        functionCounter++;
        return f;
    }

     var finished = false;

    function runNextFunction(){
        if(executionCounter == plannedExecutions.length ){
            if(!finished){
                args.unshift(null);
                callback.apply(swarm,args);
                finished = true;
                $$.PSK_PubSub.unsubscribe(channelId,runNextFunction);
            } else {
                console.log("serial construct is using functions that are called multiple times...");
            }
        } else {
            plannedExecutions[executionCounter]();
        }
    }

    $$.PSK_PubSub.subscribe(channelId,runNextFunction); // force it to be "sound"


    this.get = function(target, prop, receiver){
        if(prop == "progress" || inner.myFunctions.hasOwnProperty(prop)){
            return mkFunction(prop, functionCounter);
        }
        return swarm[prop];
    }

    var __proxy;
    this.setProxyObject = function(p){
        __proxy = p;
    }
}

exports.createSerialJoinPoint = function(swarm, callback, args){
    var jp = new SerialJoinPoint(swarm, callback, args);
    var inner = swarm.getInnerValue();
    var p = new Proxy(inner, jp);
    jp.setProxyObject(p);
    return p;
}
},{}],"/opt/privatesky/modules/callflow/lib/swarmDescription.js":[function(require,module,exports){
const OwM = require("swarmutils").OwM;

var swarmDescriptionsRegistry = {};


$$.registerSwarmDescription =  function(libraryName, shortName, swarmTypeName, description){
    if(!$$.libraries[libraryName]){
        $$.libraries[libraryName] = {};
    }

    if(!$$.__global.requireLibrariesNames[libraryName]){
        $$.__global.requireLibrariesNames[libraryName] = {};
    }

    $$.libraries[libraryName][shortName] = description;
    //console.log("Registering ", libraryName,shortName, $$.__global.currentLibraryName);
    if($$.__global.currentLibraryName){
        $$.__global.requireLibrariesNames[$$.__global.currentLibraryName][shortName] = libraryName + "." + shortName;
    }

    $$.__global.requireLibrariesNames[libraryName][shortName] = swarmTypeName;

    if(typeof description == "string"){
        description = swarmDescriptionsRegistry[description];
    }
    swarmDescriptionsRegistry[swarmTypeName] = description;
}


var currentLibraryCounter = 0;
$$.library = function(callback){
    currentLibraryCounter++;
    var previousCurrentLibrary = $$.__global.currentLibraryName;
    var libraryName = "___privatesky_library"+currentLibraryCounter;
    var ret = $$.__global.requireLibrariesNames[libraryName] = {};
    $$.__global.currentLibraryName = libraryName;
    callback();
    $$.__global.currentLibraryName = previousCurrentLibrary;
    ret.__autogenerated_privatesky_libraryName = libraryName;
    return ret;
}

function SwarmSpace(swarmType, utils) {

    var beesHealer = require("swarmutils").beesHealer;

    function getFullName(shortName){
        var fullName;
        if(shortName && shortName.includes(".")) {
            fullName = shortName;
        } else {
            fullName = $$.libraryPrefix + "." + shortName;
        }
        return fullName;
    }

    function VarDescription(desc){
        return {
            init:function(){
                return undefined;
            },
            restore:function(jsonString){
                return JSON.parse(jsonString);
            },
            toJsonString:function(x){
                return JSON.stringify();
            }
        };
    }

    function SwarmDescription(swarmTypeName, description){

        swarmTypeName = getFullName(swarmTypeName);

        var localId = 0;  // unique for each swarm

        function createVars(descr){
            var members = {};
            for(var v in descr){
                members[v] = new VarDescription(descr[v]);
            }
            return members;
        }

        function createMembers(descr){
            var members = {};
            for(var v in description){

                if(v != "public" && v != "private"){
                    members[v] = description[v];
                }
            }
            return members;
        }

        var publicVars = createVars(description.public);
        var privateVars = createVars(description.private);
        var myFunctions = createMembers(description);

        function createPhase(thisInstance, func, phaseName){
            var keyBefore = `${swarmTypeName}/${phaseName}/${$$.CONSTANTS.BEFORE_INTERCEPTOR}`;
            var keyAfter = `${swarmTypeName}/${phaseName}/${$$.CONSTANTS.AFTER_INTERCEPTOR}`;

            var phase = function(...args){
                var ret;
                try{
                    $$.PSK_PubSub.blockCallBacks();
                    thisInstance.setMetadata('phaseName', phaseName);
                    $$.interceptor.callInterceptors(keyBefore, thisInstance, args);
                    ret = func.apply(thisInstance, args);
                    $$.interceptor.callInterceptors(keyAfter, thisInstance, args);
                    $$.PSK_PubSub.releaseCallBacks();
                }catch(err){
                    $$.PSK_PubSub.releaseCallBacks();
                    throw err;
                }
                return ret;
            }
            //dynamic named func in order to improve callstack
            Object.defineProperty(phase, "name", {get: function(){return swarmTypeName+"."+func.name}});
            return phase;
        }

        this.initialise = function(serialisedValues){

            var result = new OwM({
                publicVars:{

                },
                privateVars:{

                },
                protectedVars:{

                },
                myFunctions:{

                },
                utilityFunctions:{

                },
                meta:{
                    swarmTypeName:swarmTypeName,
                    swarmDescription:description
                }
            });


            for(var v in publicVars){
                result.publicVars[v] = publicVars[v].init();
            };

            for(var v in privateVars){
                result.privateVars[v] = privateVars[v].init();
            };


            if(serialisedValues){
                beesHealer.jsonToNative(serialisedValues, result);
            }
            return result;
        };

        this.initialiseFunctions = function(valueObject, thisObject){

            for(var v in myFunctions){
                valueObject.myFunctions[v] = createPhase(thisObject, myFunctions[v], v);
            };

            localId++;
            valueObject.utilityFunctions = utils.createForObject(valueObject, thisObject, localId);

        }

        this.get = function(target, property, receiver){


            if(publicVars.hasOwnProperty(property))
            {
                return target.publicVars[property];
            }

            if(privateVars.hasOwnProperty(property))
            {
                return target.privateVars[property];
            }

            if(target.utilityFunctions.hasOwnProperty(property))
            {

                return target.utilityFunctions[property];
            }


            if(myFunctions.hasOwnProperty(property))
            {
                return target.myFunctions[property];
            }

            if(target.protectedVars.hasOwnProperty(property))
            {
                return target.protectedVars[property];
            }

            if(typeof property != "symbol") {
                $$.errorHandler.syntaxError(property, target);
            }
            return undefined;
        }

        this.set = function(target, property, value, receiver){

            if(target.utilityFunctions.hasOwnProperty(property) || target.myFunctions.hasOwnProperty(property)) {
                $$.errorHandler.syntaxError(property);
                throw new Error("Trying to overwrite immutable member" + property);
            }

            if(privateVars.hasOwnProperty(property))
            {
                target.privateVars[property] = value;
            } else
            if(publicVars.hasOwnProperty(property))
            {
                target.publicVars[property] = value;
            } else {
                target.protectedVars[property] = value;
            }
            return true;
        }

        this.apply = function(target, thisArg, argumentsList){
            console.log("Proxy apply");
            //var func = target[]
            //swarmGlobals.executionProvider.execute(null, thisArg, func, argumentsList)
        }

        var self = this;

        this.isExtensible = function(target) {
            return false;
        };

        this.has = function(target, prop) {
            if(target.publicVars[prop] || target.protectedVars[prop]) {
                return true;
            }
            return false;
        };

        this.ownKeys = function(target) {
            return Reflect.ownKeys(target.publicVars);
        };

        return function(serialisedValues){
            var valueObject = self.initialise(serialisedValues);
            var result = new Proxy(valueObject,self);
            self.initialiseFunctions(valueObject,result);
			if(!serialisedValues){
				if(!valueObject.getMeta("swarmId")){
					valueObject.setMeta("swarmId", $$.uidGenerator.safe_uuid());  //do not overwrite!!!
				}
				valueObject.utilityFunctions.notify();
			}

			if(result.autoInit){
                result.autoInit();
                $$.obsolete("fix the above comment")
                //result.autoInit = undefined;
            }
			return result;
        }
    }



    this.describe = function describeSwarm(swarmTypeName, description){
        swarmTypeName = getFullName(swarmTypeName);

        var pointPos = swarmTypeName.lastIndexOf('.');
        var shortName = swarmTypeName.substr( pointPos+ 1);
        var libraryName = swarmTypeName.substr(0, pointPos);
        if(!libraryName){
            libraryName = "global";
        }

        var description = new SwarmDescription(swarmTypeName, description);
        if(swarmDescriptionsRegistry[swarmTypeName] != undefined){
            $$.errorHandler.warning("Duplicate swarm description "+ swarmTypeName);
        }

        //swarmDescriptionsRegistry[swarmTypeName] = description;
		$$.registerSwarmDescription(libraryName, shortName, swarmTypeName, description);

        return description;
    }

    this.create = function(){
        $$.error("create function is obsolete. use describe!");
    }
    /* // confusing variant
    this.create = function createSwarm(swarmTypeName, description, initialValues){
        swarmTypeName = getFullName(swarmTypeName);
        try{
            if(undefined == description){
                return swarmDescriptionsRegistry[swarmTypeName](initialValues);
            } else {
                return this.describe(swarmTypeName, description)(initialValues);
            }
        } catch(err){
            console.log("CreateSwarm error", err);
            $$.errorHandler.error(err, arguments, "Wrong name or descriptions");
        }
    }*/

    this.continue = function(swarmTypeName, initialValues){
        swarmTypeName = getFullName(swarmTypeName);
        var desc = swarmDescriptionsRegistry[swarmTypeName];

        if(desc){
            return desc(initialValues);
        } else {
            $$.errorHandler.syntaxError(swarmTypeName,initialValues,
                "Failed to restart a swarm with type " + swarmTypeName + "\n Maybe different swarm space (used flow instead of swarm!?)");
        }
    }

    this.start = function(swarmTypeName, ctor, ...params){
        swarmTypeName = getFullName(swarmTypeName);
        var desc = swarmDescriptionsRegistry[swarmTypeName];
        if(!desc){
            $$.errorHandler.syntaxError(null, swarmTypeName);
            return null;
        }
        var res = desc();
        res.setMetadata("homeSecurityContext", $$.securityContext);

        if(ctor){
            res[ctor].apply(res, params);
        }

        return res;
    }
}

exports.createSwarmEngine = function(swarmType, utils){
    if(typeof utils == "undefined"){
        utils = require("./utilityFunctions/callflow");
    }
    return new SwarmSpace(swarmType, utils);
};

},{"./utilityFunctions/callflow":"/opt/privatesky/modules/callflow/lib/utilityFunctions/callflow.js","swarmutils":"swarmutils"}],"/opt/privatesky/modules/callflow/lib/utilityFunctions/asset.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var ret = require("./base").createForObject(valueObject, thisObject, localId);

	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.return          = null;
	ret.home            = null;
	ret.isPersisted  	= function () {
		return thisObject.getMetadata('persisted') === true;
	};

	return ret;
};
},{"./base":"/opt/privatesky/modules/callflow/lib/utilityFunctions/base.js"}],"/opt/privatesky/modules/callflow/lib/utilityFunctions/base.js":[function(require,module,exports){
var beesHealer = require("swarmutils").beesHealer;
var swarmDebug = require("../choreographies/SwarmDebug");

exports.createForObject = function(valueObject, thisObject, localId){
	var ret = {};

	function filterForSerialisable (valueObject){
		return valueObject.meta.swarmId;
	}

	var swarmFunction = function(context, phaseName){
		var args =[];
		for(var i = 2; i < arguments.length; i++){
			args.push(arguments[i]);
		}

		//make the execution at level 0  (after all pending events) and wait to have a swarmId
		ret.observe(function(){
			beesHealer.asJSON(valueObject, phaseName, args, function(err,jsMsg){
				jsMsg.meta.target = context;
				var subscribersCount = $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, jsMsg);
				if(!subscribersCount){
					console.log(`Nobody listening for <${$$.CONSTANTS.SWARM_FOR_EXECUTION}>!`);
				}
			});
		},null,filterForSerialisable);

		ret.notify();


		return thisObject;
	};

	var asyncReturn = function(err, result){
		var context = valueObject.protectedVars.context;

		if(!context && valueObject.meta.waitStack){
			context = valueObject.meta.waitStack.pop();
			valueObject.protectedVars.context = context;
		}

		beesHealer.asJSON(valueObject, "__return__", [err, result], function(err,jsMsg){
			jsMsg.meta.command = "asyncReturn";
			if(!context){
				context = valueObject.meta.homeSecurityContext;//TODO: CHECK THIS

			}
			jsMsg.meta.target = context;

			if(!context){
				$$.errorHandler.error(new Error("Asynchronous return inside of a swarm that does not wait for results"));
			} else {
				$$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, jsMsg);
			}
		});
	};

	function home(err, result){
		beesHealer.asJSON(valueObject, "home", [err, result], function(err,jsMsg){
			var context = valueObject.meta.homeContext;
			jsMsg.meta.target = context;
			$$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, jsMsg);
		});
	}



	function waitResults(callback, keepAliveCheck, swarm){
		if(!swarm){
			swarm = this;
		}
		if(!keepAliveCheck){
			keepAliveCheck = function(){
				return false;
			}
		}
		var inner = swarm.getInnerValue();
		if(!inner.meta.waitStack){
			inner.meta.waitStack = [];
			inner.meta.waitStack.push($$.securityContext)
		}
		$$.swarmsInstancesManager.waitForSwarm(callback, swarm, keepAliveCheck);
	}


	function getInnerValue(){
		return valueObject;
	}

	function runPhase(functName, args){
		var func = valueObject.myFunctions[functName];
		if(func){
			func.apply(thisObject, args);
		} else {
			$$.errorHandler.syntaxError(functName, valueObject, "Function " + functName + " does not exist!");
		}

	}

	function update(serialisation){
		beesHealer.jsonToNative(serialisation,valueObject);
	}


	function valueOf(){
		var ret = {};
		ret.meta                = valueObject.meta;
		ret.publicVars          = valueObject.publicVars;
		ret.privateVars         = valueObject.privateVars;
		ret.protectedVars       = valueObject.protectedVars;
		return ret;
	}

	function toString (){
		return swarmDebug.cleanDump(thisObject.valueOf());
	}


	function createParallel(callback){
		return require("../parallelJoinPoint").createJoinPoint(thisObject, callback, $$.__intern.mkArgs(arguments,1));
	}

	function createSerial(callback){
		return require("../serialJoinPoint").createSerialJoinPoint(thisObject, callback, $$.__intern.mkArgs(arguments,1));
	}

	function inspect(){
		return swarmDebug.cleanDump(thisObject.valueOf());
	}

	function constructor(){
		return SwarmDescription;
	}

	function ensureLocalId(){
		if(!valueObject.localId){
			valueObject.localId = valueObject.meta.swarmTypeName + "-" + localId;
			localId++;
		}
	}

	function observe(callback, waitForMore, filter){
		if(!waitForMore){
			waitForMore = function (){
				return false;
			}
		}

		ensureLocalId();

		$$.PSK_PubSub.subscribe(valueObject.localId, callback, waitForMore, filter);
	}

	function toJSON(prop){
		//preventing max call stack size exceeding on proxy auto referencing
		//replace {} as result of JSON(Proxy) with the string [Object protected object]
		return "[Object protected object]";
	}

	function getJSON(callback){
		return	beesHealer.asJSON(valueObject, null, null,callback);
	}

	function notify(event){
		if(!event){
			event = valueObject;
		}
		ensureLocalId();
		$$.PSK_PubSub.publish(valueObject.localId, event);
	}

	function getMeta(name){
		return valueObject.getMeta(name);
	}

	function setMeta(name, value){
		return valueObject.setMeta(name, value);
	}

	ret.setMeta			= setMeta;
	ret.getMeta			= getMeta;
	ret.swarm           = swarmFunction;
	ret.notify          = notify;
	ret.getJSON    	    = getJSON;
	ret.toJSON          = toJSON;
	ret.observe         = observe;
	ret.inspect         = inspect;
	ret.join            = createParallel;
	ret.parallel        = createParallel;
	ret.serial          = createSerial;
	ret.valueOf         = valueOf;
	ret.update          = update;
	ret.runPhase        = runPhase;
	ret.onReturn        = waitResults;
	ret.onResult        = waitResults;
	ret.asyncReturn     = asyncReturn;
	ret.return          = asyncReturn;
	ret.getInnerValue   = getInnerValue;
	ret.home            = home;
	ret.toString        = toString;
	ret.constructor     = constructor;
	ret.setMetadata		= valueObject.setMeta.bind(valueObject);
	ret.getMetadata		= valueObject.getMeta.bind(valueObject);

	ret.autoInit		= null;
	return ret;

};

},{"../choreographies/SwarmDebug":"/opt/privatesky/modules/callflow/lib/choreographies/SwarmDebug.js","../parallelJoinPoint":"/opt/privatesky/modules/callflow/lib/parallelJoinPoint.js","../serialJoinPoint":"/opt/privatesky/modules/callflow/lib/serialJoinPoint.js","swarmutils":"swarmutils"}],"/opt/privatesky/modules/callflow/lib/utilityFunctions/callflow.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var ret = require("./base").createForObject(valueObject, thisObject, localId);

	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.return          = null;
	ret.home            = null;

	return ret;
};
},{"./base":"/opt/privatesky/modules/callflow/lib/utilityFunctions/base.js"}],"/opt/privatesky/modules/callflow/lib/utilityFunctions/transaction.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var ret = require("./base").createForObject(valueObject, thisObject, localId);

	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.return          = null;
	ret.home            = null;
	ret.autoInit        = function(){
		thisObject.transaction = $$.blockchain.beginTransaction(thisObject);
	};
	ret.isPersisted  	= function () {
		return thisObject.getMetadata('persisted') === true;
	};

	return ret;
};
},{"./base":"/opt/privatesky/modules/callflow/lib/utilityFunctions/base.js"}],"/opt/privatesky/modules/callflow/standardGlobalSymbols.js":[function(require,module,exports){
let logger = console;

if (process.env.NO_LOGS !== 'true') {
    try {
        const PSKLoggerModule = require('psklogger');
        const PSKLogger = PSKLoggerModule.PSKLogger;
        
        logger = PSKLogger.getLogger();
        
        // TODO: remove this once $$ logger is used instead of console
        PSKLoggerModule.overwriteConsole();

        console.log('Logger init successful', process.pid);
    } catch (e) {
        console.warn('Logger not available, using console', e);
        logger = console;
    }
} else {
    console.log('Environment flag NO_LOGS is set, logging to console');
}

$$.registerGlobalSymbol = function (newSymbol, value) {
    if (typeof $$[newSymbol] == "undefined") {
        Object.defineProperty($$, newSymbol, {
            value: value,
            writable: false
        });
    } else {
        logger.error("Refusing to overwrite $$." + newSymbol);
    }
};

$$.registerGlobalSymbol("autoThrow", function (err) {
    if (!err) {
        throw err;
    }
});

$$.registerGlobalSymbol("ignoreError", function (err) {
    if (err) {
        $$.error(err);
    }
});

$$.registerGlobalSymbol("exception", function (message, type) {
    if (!err) {
        throw new Error(message);
    }
});

$$.registerGlobalSymbol("err", function (...args) {
    logger.error(...args);
});

$$.registerGlobalSymbol("warn", function (...args) {
    logger.warn(...args);
});

/* a feature is planned but not implemented (during development) but
also it could remain in production and should be flagged asap*/
$$.registerGlobalSymbol("incomplete", function (...args) {
    logger.warn(...args);
});

/* used during development and when trying to discover elusive errors*/
$$.registerGlobalSymbol("assert", function (value, explainWhy) {
    if (!value) {
        throw new Error("Assert false " + explainWhy);
    }
});

/* enable/disabale flags that control psk behaviour*/
$$.registerGlobalSymbol("flags", function (flagName, value) {
    $$.incomplete("flags handling not implemented");
});

$$.registerGlobalSymbol("obsolete", function (...args) {
    logger.log(...args);
});

$$.registerGlobalSymbol("log", function (...args) {
    logger.log(...args);
});

$$.registerGlobalSymbol("syntaxError", function (...args) {
    logger.log(...args);
});

/* log unknown exceptions*/
$$.registerGlobalSymbol("unknownException", function (...args) {
    logger.log(...args);
});

/* PrivateSky event, used by monitoring and statistics*/
$$.registerGlobalSymbol("event", function (event, ...args) {
    if (logger.hasOwnProperty('event')) {
        logger.event(event, ...args);
    } else {
        console.log(event, ...args);
    }
});

/* */
$$.registerGlobalSymbol("redirectLog", function(logType, logObject) {
    logger.redirect(logType, logObject);
});

/* log throttling event // it is just an event?*/
$$.registerGlobalSymbol("throttlingEvent", function (...args) {
    logger.log(...args);
});

},{"psklogger":"psklogger"}],"/opt/privatesky/modules/double-check/lib/standardAsserts.js":[function(require,module,exports){

module.exports.init = function(sf, logger){
    /**
     * Registering handler for failed asserts. The handler is doing logging and is throwing an error.
     * @param explanation {String} - failing reason message.
     */
    sf.exceptions.register('assertFail', function(explanation){
        const message = "Assert or invariant has failed " + (explanation ? explanation : "");
        const err = new Error(message);
        logger.recordAssert('[Fail] ' + message, err, true);
        throw err;
    });

    /**
     * Registering assert for equality. If check fails, the assertFail is invoked.
     * @param v1 {String|Number|Object} - first value
     * @param v1 {String|Number|Object} - second value
     * @param explanation {String} - failing reason message in case the assert fails.
     */
    sf.assert.addCheck('equal', function(v1 , v2, explanation){
        if(v1 !== v2){
            if(!explanation){
                explanation =  "Assertion failed: [" + v1 + " !== " + v2 + "]";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for inequality. If check fails, the assertFail is invoked.
     * @param v1 {String|Number|Object} - first value
     * @param v1 {String|Number|Object} - second value
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('notEqual', function(v1, v2, explanation){
        if(v1 === v2){
            if(!explanation){
                explanation =  " ["+ v1 + " == " + v2 + "]";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating an expression to true. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('true', function(b, explanation){
        if(!b){
            if(!explanation){
                explanation =  " expression is false but is expected to be true";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating an expression to false. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('false', function(b, explanation){
        if(b){
            if(!explanation){
                explanation =  " expression is true but is expected to be false";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating a value to null. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('isNull', function(v1, explanation){
        if(v1 !== null){
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating a value to be not null. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('notNull', function(v1 , explanation){
        if(v1 === null && typeof v1 === "object"){
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Checks if all properties of the second object are own properties of the first object.
     * @param firstObj {Object} - first object
     * @param secondObj{Object} - second object
     * @returns {boolean} - returns true, if the check has passed or false otherwise.
     */
    function objectHasFields(firstObj, secondObj){
        for(let field in secondObj) {
            if (firstObj.hasOwnProperty(field)) {
                if (firstObj[field] !== secondObj[field]) {
                    return false;
                }
            }
            else{
                return false;
            }
        }
        return true;
    }

    function objectsAreEqual(firstObj, secondObj) {
        let areEqual = true;
        if(firstObj !== secondObj) {
            if(typeof firstObj !== typeof secondObj) {
                areEqual = false;
            } else if (Array.isArray(firstObj) && Array.isArray(secondObj)) {
	            firstObj.sort();
	            secondObj.sort();
		        if (firstObj.length !== secondObj.length) {
			        areEqual = false;
		        } else {
			        for (let i = 0; i < firstObj.length; ++i) {
				        if (!objectsAreEqual(firstObj[i], secondObj[i])) {
					        areEqual = false;
					        break;
				        }
			        }
		        }
	        } else if((typeof firstObj === 'function' && typeof secondObj === 'function') ||
		        (firstObj instanceof Date && secondObj instanceof Date) ||
		        (firstObj instanceof RegExp && secondObj instanceof RegExp) ||
		        (firstObj instanceof String && secondObj instanceof String) ||
		        (firstObj instanceof Number && secondObj instanceof Number)) {
                    areEqual = firstObj.toString() === secondObj.toString();
            } else if(typeof firstObj === 'object' && typeof secondObj === 'object') {
                areEqual = objectHasFields(firstObj, secondObj);
            // isNaN(undefined) returns true
            } else if(isNaN(firstObj) && isNaN(secondObj) && typeof firstObj === 'number' && typeof secondObj === 'number') {
                areEqual = true;
            } else {
                areEqual = false;
            }
        }

        return areEqual;
    }

    /**
     * Registering assert for evaluating if all properties of the second object are own properties of the first object.
     * If check fails, the assertFail is invoked.
     * @param firstObj {Object} - first object
     * @param secondObj{Object} - second object
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck("objectHasFields", function(firstObj, secondObj, explanation){
        if(!objectHasFields(firstObj, secondObj)) {
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating if all element from the second array are present in the first array.
     * Deep comparison between the elements of the array is used.
     * If check fails, the assertFail is invoked.
     * @param firstArray {Array}- first array
     * @param secondArray {Array} - second array
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck("arraysMatch", function(firstArray, secondArray, explanation){
        if(firstArray.length !== secondArray.length){
            sf.exceptions.assertFail(explanation);
        }
        else {
            const result = objectsAreEqual(firstArray, secondArray);
            // const arraysDontMatch = secondArray.every(element => firstArray.indexOf(element) !== -1);
            // let arraysDontMatch = secondArray.some(function (expectedElement) {
            //     let found = firstArray.some(function(resultElement){
            //         return objectHasFields(resultElement,expectedElement);
            //     });
            //     return found === false;
            // });

            if(!result){
                sf.exceptions.assertFail(explanation);
            }
        }
    });

    // added mainly for test purposes, better test frameworks like mocha could be much better

    /**
     * Registering assert for checking if a function is failing.
     * If the function is throwing an exception, the test is passed or failed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('fail', function(testName, func){
        try{
            func();
            logger.recordAssert("[Fail] " + testName);
        } catch(err){
            logger.recordAssert("[Pass] " + testName);
        }
    });

    /**
     * Registering assert for checking if a function is executed with no exceptions.
     * If the function is not throwing any exception, the test is passed or failed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('pass', function(testName, func){
        try{
            func();
            logger.recordAssert("[Pass] " + testName);
        } catch(err){
            logger.recordAssert("[Fail] " + testName, err.stack);
        }
    });

    /**
     * Alias for the pass assert.
     */
    sf.assert.alias('test', 'pass');

    /**
     * Registering assert for checking if a callback function is executed before timeout is reached without any exceptions.
     * If the function is throwing any exception or the timeout is reached, the test is failed or passed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('callback', function(testName, func, timeout){

        if(!func || typeof func != "function"){
            throw new Error("Wrong usage of assert.callback!");
        }

        if(!timeout){
            timeout = 500;
        }

        var passed = false;
        function callback(){
            if(!passed){
                passed = true;
                logger.recordAssert("[Pass] " + testName);
                successTest();
            } else {
                logger.recordAssert("[Fail (multiple calls)] " + testName);
            }
        }
        
        try{
            func(callback);
        } catch(err){
            logger.recordAssert("[Fail] " + testName,  err, true);
        }

        function successTest(force){
            if(!passed){
                logger.recordAssert("[Fail Timeout] " + testName );
            }
        }

        setTimeout(successTest, timeout);
    });

    /**
     * Registering assert for checking if an array of callback functions are executed in a waterfall manner,
     * before timeout is reached without any exceptions.
     * If any of the functions is throwing any exception or the timeout is reached, the test is failed or passed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('steps', function(testName, arr, timeout){
        if(!timeout){
            timeout = 500;
        }

        var currentStep = 0;
        var passed = false;

        function next(){
            if(currentStep === arr.length){
                passed = true;
                logger.recordAssert("[Pass] " + testName );
                return;
            }

            var func = arr[currentStep];
            currentStep++;
            try{
                func(next);
            } catch(err){
                logger.recordAssert("[Fail] " + testName  + " [at step " + currentStep + "]", err);
            }
        }

        function successTest(force){
            if(!passed){
                logger.recordAssert("[Fail Timeout] " + testName  + " [at step " + currentStep + "]");
            }
        }

        setTimeout(successTest, timeout);
        next();
    });

    /**
     * Alias for the steps assert.
     */
    sf.assert.alias('waterfall', 'steps');

    /**
     * Registering assert for asynchronously printing all execution summary from logger.dumpWhys.
     * @param message {String} - message to be recorded
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('end', function(timeout, silence){
        if(!timeout){
            timeout = 1000;
        }

        function handler() {
            if(logger.dumpWhys){
                logger.dumpWhys().forEach(function(c){
                    const executionSummary = c.getExecutionSummary();
                    console.log(JSON.stringify(executionSummary, null, 4));
                });
            }

            if(!silence){
                console.log("Forcing exit after", timeout, "ms");
            }
            process.exit(0);
        }

        setTimeout(handler, timeout);
    });

    /**
     * Registering assert for printing a message and asynchronously printing all logs from logger.dumpWhys.
     * @param message {String} - message to be recorded
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('begin', function(message, timeout){
        logger.recordAssert(message);
        sf.assert.end(timeout, true);
    });
};
},{}],"/opt/privatesky/modules/double-check/lib/standardChecks.js":[function(require,module,exports){
/*
    checks are like asserts but are intended to be used in production code to help debugging and signaling wrong behaviours

 */

exports.init = function(sf){
    sf.exceptions.register('checkFail', function(explanation, err){
        var stack;
        if(err){
            stack = err.stack;
        }
        console.log("Check failed ", explanation, stack);
    });

    sf.check.addCheck('equal', function(v1 , v2, explanation){

        if(v1 !== v2){
            if(!explanation){
                explanation =  " ["+ v1 + " != " + v2 + "]";
            }

            sf.exceptions.checkFail(explanation);
        }
    });


    sf.check.addCheck('true', function(b, explanation){
        if(!b){
            if(!explanation){
                explanation =  " expression is false but is expected to be true";
            }

            sf.exceptions.checkFail(explanation);
        }
    });


    sf.check.addCheck('false', function(b, explanation){
        if(b){
            if(!explanation){
                explanation =  " expression is true but is expected to be false";
            }

            sf.exceptions.checkFail(explanation);
        }
    });

    sf.check.addCheck('notequal', function(v1 , v2, explanation){
        if(v1 == v2){
            if(!explanation){
                explanation =  " ["+ v1 + " == " + v2 + "]";
            }
            sf.exceptions.checkFail(explanation);
        }
    });


    /*
        added mainly for test purposes, better test frameworks like mocha could be much better :)
    */
    sf.check.addCheck('fail', function(testName ,func){
        try{
            func();
            console.log("[Fail] " + testName );
        } catch(err){
            console.log("[Pass] " + testName );
        }
    });


    sf.check.addCheck('pass', function(testName ,func){
        try{
            func();
            console.log("[Pass] " + testName );
        } catch(err){
            console.log("[Fail] " + testName  ,  err.stack);
        }
    });


    sf.check.alias('test','pass');


    sf.check.addCheck('callback', function(testName ,func, timeout){
        if(!timeout){
            timeout = 500;
        }
        var passed = false;
        function callback(){
            if(!passed){
                passed = true;
                console.log("[Pass] " + testName );
                SuccessTest();
            } else {
                console.log("[Fail (multiple calls)] " + testName );
            }
        }
        try{
            func(callback);
        } catch(err){
            console.log("[Fail] " + testName  ,  err.stack);
        }

        function SuccessTest(force){
            if(!passed){
                console.log("[Fail Timeout] " + testName );
            }
        }

        setTimeout(SuccessTest, timeout);
    });


    sf.check.addCheck('steps', function(testName , arr, timeout){
        var  currentStep = 0;
        var passed = false;
        if(!timeout){
            timeout = 500;
        }

        function next(){
            if(currentStep === arr.length){
                passed = true;
                console.log("[Pass] " + testName );
                return ;
            }
            var func = arr[currentStep];
            currentStep++;
            try{
                func(next);
            } catch(err){
                console.log("[Fail] " + testName  ,"\n\t" , err.stack + "\n\t" , " [at step ", currentStep + "]");
            }
        }

        function SuccessTest(force){
            if(!passed){
                console.log("[Fail Timeout] " + testName + "\n\t" , " [at step ", currentStep+ "]");
            }
        }

        setTimeout(SuccessTest, timeout);
        next();
    });

    sf.check.alias('waterfall','steps');
    sf.check.alias('notEqual','notequal');

    sf.check.addCheck('end', function(timeOut, silence){
        if(!timeOut){
            timeOut = 1000;
        }

        setTimeout(function(){
            if(!silence){
                console.log("Forcing exit after", timeOut, "ms");
            }
            process.exit(0);
        }, timeOut);
    });


    sf.check.addCheck('begin', function(message, timeOut){
        console.log(message);
        sf.check.end(timeOut, true);
    });


};
},{}],"/opt/privatesky/modules/double-check/lib/standardExceptions.js":[function(require,module,exports){
exports.init = function(sf){
    /**
     * Registering unknown exception handler.
     */
    sf.exceptions.register('unknown', function(explanation){
        explanation = explanation || "";
        const message = "Unknown exception" + explanation;
        throw(message);
    });

    /**
     * Registering resend exception handler.
     */
    sf.exceptions.register('resend', function(exceptions){
        throw(exceptions);
    });

    /**
     * Registering notImplemented exception handler.
     */
    sf.exceptions.register('notImplemented', function(explanation){
        explanation = explanation || "";
        const message = "notImplemented exception" + explanation;
        throw(message);
    });

    /**
     * Registering security exception handler.
     */
    sf.exceptions.register('security', function(explanation){
        explanation = explanation || "";
        const message = "security exception" + explanation;
        throw(message);
    });

    /**
     * Registering duplicateDependency exception handler.
     */
    sf.exceptions.register('duplicateDependency', function(variable){
        variable = variable || "";
        const message = "duplicateDependency exception" + variable;
        throw(message);
    });
};
},{}],"/opt/privatesky/modules/double-check/lib/standardLogs.js":[function(require,module,exports){
const LOG_LEVELS = {
    HARD_ERROR:     0,  // system level critical error: hardError
    ERROR:          1,  // potentially causing user's data loosing error: error
    LOG_ERROR:      2,  // minor annoyance, recoverable error:   logError
    UX_ERROR:       3,  // user experience causing issues error:  uxError
    WARN:           4,  // warning,possible isues but somehow unclear behaviour: warn
    INFO:           5,  // store general info about the system working: info
    DEBUG:          6,  // system level debug: debug
    LOCAL_DEBUG:    7,  // local node/service debug: ldebug
    USER_DEBUG:     8,  // user level debug; udebug
    DEV_DEBUG:      9,  // development time debug: ddebug
    WHYS:            10, // whyLog for code reasoning
    TEST_RESULT:    11, // testResult to log running tests
};

exports.init = function(sf){

    /**
     * Records log messages from various use cases.
     * @param record {String} - log message.
     */
    sf.logger.record = function(record){
        var displayOnConsole = true;
        if(process.send) {
            process.send(record);
            displayOnConsole = false;
        }

        if(displayOnConsole) {
            const prettyLog = JSON.stringify(record, null, 2);
            console.log(prettyLog);
        }
    };

    /**
     * Adding case for logging system level critical errors.
     */
    sf.logger.addCase('hardError', function(message, exception, args, pos, data){
        sf.logger.record(createDebugRecord(LOG_LEVELS.HARD_ERROR, 'systemError', message, exception, true, args, pos, data));
    }, [
        {
            'message':'explanation'
        }
    ]);

    /**
     * Adding case for logging potentially causing user's data loosing errors.
     */
    sf.logger.addCase('error', function(message, exception, args, pos, data){
        sf.logger.record(createDebugRecord(LOG_LEVELS.ERROR, 'error', message, exception, true, args, pos, data));
    }, [
        {
            'message':'explanation'
        },
        {
            'exception':'exception'
        }
    ]);

    /**
     * Adding case for logging minor annoyance, recoverable errors.
     */
    sf.logger.addCase('logError', function(message, exception, args, pos, data){
        sf.logger.record(createDebugRecord(LOG_LEVELS.LOG_ERROR, 'logError', message, exception, true, args, pos, data));
    }, [
        {
            'message':'explanation'
        },
        {
            'exception':'exception'
        }
    ]);

    /**
     * Adding case for logging user experience causing issues errors.
     */
    sf.logger.addCase('uxError', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.UX_ERROR, 'uxError', message, null, false));
    }, [
        {
            'message':'explanation'
        }
    ]);

    /**
     * Adding case for logging throttling messages.
     */
    sf.logger.addCase('throttling', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.WARN, 'throttling', message, null, false));
    }, [
        {
            'message':'explanation'
        }
    ]);

    /**
     * Adding case for logging warning, possible issues, but somehow unclear behaviours.
     */
    sf.logger.addCase('warning', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.WARN, 'warning', message,null, false, arguments, 0));
    }, [
        {
            'message':'explanation'
        }
    ]);
    
    sf.logger.alias('warn', 'warning');

    /**
     * Adding case for logging general info about the system working.
     */
    sf.logger.addCase('info', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.INFO, 'info', message,null, false, arguments, 0));
    }, [
        {
            'message':'explanation'
        }
    ]);

    /**
     * Adding case for logging system level debug messages.
     */
    sf.logger.addCase('debug', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.DEBUG, 'debug', message,null, false, arguments, 0));
    }, [
        {
            'message':'explanation'
        }
    ]);


    /**
     * Adding case for logging local node/service debug messages.
     */
    sf.logger.addCase('ldebug', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.LOCAL_DEBUG, 'ldebug', message, null, false, arguments, 0));
    }, [
        {
            'message':'explanation'
        }
    ]);

    /**
     * Adding case for logging user level debug messages.
     */
    sf.logger.addCase('udebug', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.USER_DEBUG, 'udebug', message ,null, false, arguments, 0));
    }, [
        {
            'message':'explanation'
        }
    ]);

    /**
     * Adding case for logging development debug messages.
     */
    sf.logger.addCase('devel', function(message){
        sf.logger.record(createDebugRecord(LOG_LEVELS.DEV_DEBUG, 'devel', message, null, false, arguments, 0));
    }, [
        {
            'message':'explanation'
        }
    ]);

    /**
     * Adding case for logging "whys" reasoning messages.
     */
    sf.logger.addCase("logWhy", function(logOnlyCurrentWhyContext){
        sf.logger.record(createDebugRecord(LOG_LEVELS.WHYS, 'logwhy', undefined, undefined, undefined, undefined, undefined, undefined, logOnlyCurrentWhyContext));
    });

    /**
     * Adding case for logging asserts messages to running tests.
     */
    sf.logger.addCase("recordAssert", function (message, error,showStack){
        sf.logger.record(createDebugRecord(LOG_LEVELS.TEST_RESULT, 'assert', message, error, showStack));
    });

    /**
     * Generic method to create structured debug records based on the log level.
     * @param level {Number} - number from 1-11, used to identify the level of attention that a log entry should get from operations point of view
     * @param type {String} - identifier name for log type
     * @param message {String} - description of the debug record
     * @param exception {String} - exception details if any
     * @param saveStack {Boolean} - if set to true, the exception call stack will be added to the debug record
     * @param args {Array} - arguments of the caller function
     * @param pos {Number} - position
     * @param data {String|Number|Array|Object} - payload information
     * @param logOnlyCurrentWhyContext - if whys is enabled, only the current context will be logged
     * @returns Debug record model {Object} with the following fields:
     * [required]: level: *, type: *, timestamp: number, message: *, data: * and
     * [optional]: stack: *, exception: *, args: *, whyLog: *
     */
    function createDebugRecord(level, type, message, exception, saveStack, args, pos, data, logOnlyCurrentWhyContext){

        var ret = {
            level: level,
            type: type,
            timestamp: (new Date()).getTime(),
            message: message,
            data: data
        };

        if(saveStack){
            var stack = '';
            if(exception){
                stack = exception.stack;
            } else {
                stack  = (new Error()).stack;
            }
            ret.stack = stack;
        }

        if(exception){
            ret.exception = exception.message;
        }

        if(args){
            ret.args = JSON.parse(JSON.stringify(args));
        }

        if(process.env.RUN_WITH_WHYS){
            var why = require('whys');
            if(logOnlyCurrentWhyContext) {
                ret['whyLog'] = why.getGlobalCurrentContext().getExecutionSummary();
            }else{
                ret['whyLog'] = why.getAllContexts().map(function (context) {
                    return context.getExecutionSummary();
                });
            }
        }

        if(!process.env.DISABLE_STACKPRINT){
            if(stack){
                console.log(stack);
            }
        }
        return ret;
    }

};


},{"whys":false}],"/opt/privatesky/modules/double-check/lib/testRunner.js":[function(require,module,exports){
(function (Buffer,__dirname){
const fs = require("fs");
const path = require("path");
const forker = require('child_process');

const DEFAULT_TIMEOUT = 2000;

var globToRegExp =  require("./utils/glob-to-regexp");

var defaultConfig = {
    confFileName: "double-check.json",      // name of the conf file
    fileExt: ".js",                         // test file supported by extension
    matchDirs: [ 'test', 'tests' ],           // dirs names for tests - case insensitive (used in discovery process)
    testsDir: process.cwd(),                // path to the root tests location
    reports: {
        basePath: process.cwd(),            // path where the reports will be saved
        prefix: "Report-",                  // prefix for report files, filename pattern: [prefix]-{timestamp}{ext}
        ext: ".txt"                         // report file extension
    }
};

const TAG = "[TEST_RUNNER]";
const MAX_WORKERS = process.env['DOUBLE_CHECK_POOL_SIZE'] || 10;
const DEBUG = typeof v8debug === 'object';

const TEST_STATES = {
    READY: 'ready',
    RUNNING: 'running',
    FINISHED: 'finished',
    TIMEOUT: 'timeout'
};

// Session object
var defaultSession = {
    testCount: 0,
    currentTestIndex: 0,
    debugPort: process.debugPort,   // current process debug port. The child process will be increased from this port
    workers: {
        running: 0,
        terminated: 0
    }
};

// Template structure for test reports.
var reportFileStructure = {
    count: 0,
    suites: {
        count: 0,
        items: []
    },
    passed: {
        count: 0,
        items: []
    },
    failed: {
        count: 0,
        items: []
    },
};

exports.init = function(sf){
    sf.testRunner = {
        /**
         * Initialization of the test runner.
         * @param config {Object} - settings object that will be merged with the default one
         * @private
         */
        __init: function(config) {
            this.config = this.__extend(defaultConfig, config);
            this.testTree = {};
            this.testList = [];

            this.session = defaultSession;

            // create reports directory if not exist
            if (!fs.existsSync(this.config.reports.basePath)){
                fs.mkdirSync(this.config.reports.basePath);
            }
        },
        /**
         * Main entry point. It will start the flow runner flow.
         * @param config {Object} - object containing settings such as conf file name, test dir.
         * @param callback {Function} - handler(error, result) invoked when an error occurred or the runner has completed all jobs.
         */
        start: function(config, callback) {

            // wrapper for provided callback, if any
            this.callback = function(err, result) {
                if(err) {
                    this.__debugInfo(err.message || err);
                }

                if(callback) {
                    return callback(err, result);
                }
            };

            this.__init(config);

            this.__consoleLog("Discovering tests ...");
            this.testTree = this.__discoverTestFiles(this.config.testsDir, config);
            this.testList = this.__toTestTreeToList(this.testTree);
            this.__launchTests();
        },
        /**
         * Reads configuration settings from a json file.
         * @param confPath {String} - absolute path to the configuration file.
         * @returns {Object} - configuration object {{}}
         * @private
         */
        __readConf: function(confPath) {
            var config = {};
            try{
                config = require(confPath);
            } catch(error) {
                console.error(error);
            }

            return config;
        },
        /**
         * Discovers test files recursively starting from a path. The dir is the root of the test files. It can contains
         * test files and test sub directories. It will create a tree structure with the test files discovered.
         * Notes: Only the config.matchDirs will be taken into consideration. Also, based on the conf (double-check.json)
         * it will include the test files or not.
         * @param dir {String} - path where the discovery process starts
         * @param parentConf {String} - configuration object (double-check.json) from the parent directory
         * @returns The root node object of the file structure tree. E.g. {*|{__meta, data, result, items}}
         * @private
         */
        __discoverTestFiles: function(dir, parentConf) {
            const stat = fs.statSync(dir);
            if(!stat.isDirectory()){
                throw new Error(dir + " is not a directory!");
            }

            let currentConf = parentConf;

            let currentNode = this.__getDefaultNodeStructure();
            currentNode.__meta.parent = path.dirname(dir);
            currentNode.__meta.isDirectory = true;

            let files = fs.readdirSync(dir);
            // first look for conf file
            if(files.indexOf(this.config.confFileName) !== -1) {
                let fd = path.join(dir, this.config.confFileName);
                let conf = this.__readConf(fd);
                if(conf) {
                    currentNode.__meta.conf = conf;
                    currentConf = conf;
                }
            }

            currentNode.data.name = path.basename(dir);
            currentNode.data.path = dir;
            currentNode.items = [];

            for(let i = 0, len = files.length; i < len; i++) {
                let item = files[i];

                let fd = path.join(dir, item);
                let stat = fs.statSync(fd);
                let isDir = stat.isDirectory();
                let isTestDir = this.__isTestDir(fd);

                if(isDir && !isTestDir) {
                    continue; // ignore dirs that does not follow the naming rule for test dirs
                }

                if(!isDir && item.match(this.config.confFileName)){
                    continue; // already processed
                }

                // exclude files based on glob patterns
                if(currentConf) {
                    // currentConf['ignore'] - array of regExp
                    if(currentConf['ignore']) {
                        const isMatch = this.__isAnyMatch(currentConf['ignore'], item);
                        if(isMatch) {continue;}
                    }
                }

                let childNode = this.__getDefaultNodeStructure();
                childNode.__meta.conf = {};
                childNode.__meta.isDirectory = isDir;
                childNode.__meta.parent = path.dirname(fd);

                if (isDir) {
                    let tempChildNode = this.__discoverTestFiles(fd, currentConf);
                    childNode = Object.assign(childNode, tempChildNode);
                    currentNode.items.push(childNode);
                }
                else if(path.extname(fd) ===  this.config.fileExt){
                    childNode.__meta.conf.runs = currentConf['runs'] || 1;
                    childNode.__meta.conf.silent = currentConf['silent'];
                    childNode.__meta.conf.timeout = currentConf['timeout'] || DEFAULT_TIMEOUT;

                    childNode.data.name = item;
                    childNode.data.path = fd;

                    currentNode.items.push(childNode);
                }
            }

            return currentNode;
        },
        /**
         * Launch collected tests. Initialises session variables, that are specific for the current launch.
         * @private
         */
        __launchTests: function() {
            this.__consoleLog("Launching tests ...");
            this.session.testCount = this.testList.length;
            this.session.processedTestCount = 0;
            this.session.workers.running = 0;
            this.session.workers.terminated = 0;

            if(this.session.testCount > 0) {
                this.__scheduleWork();
            } else {
                this.__doTestReports();
            }
        },
        /**
         * Schedules work based on the MAX available workers, and based on the number of runs of a test.
         * If a test has multiple runs as a option, it will be started in multiple workers. Once all runs are completed,
         * the test is considered as processed.
         * @private
         */
        __scheduleWork: function() {
            while(this.session.workers.running < MAX_WORKERS && this.session.currentTestIndex < this.session.testCount){
                let test = this.testList[this.session.currentTestIndex];
                if(test.result.runs < test.__meta.conf.runs) {
                    test.result.runs++;
                    this.__launchTest(test);
                } else {
                    this.session.currentTestIndex++;
                }
            }
        },
        /**
         * Launch a test into a separate worker (child process).
         * Each worker has handlers for message, exit and error events. Once the exit or error event is invoked,
         * new work is scheduled and session object is updated.
         * Notes: On debug mode, the workers will receive a debug port, that is increased incrementally.
         * @param test {Object} - test object
         * @private
         */
        __launchTest: function(test) {
            this.session.workers.running++;

            test.result.state = TEST_STATES.RUNNING;
            test.result.pass = true;
            test.result.asserts[test.result.runs] = [];
            test.result.messages[test.result.runs] = [];

            let env = process.env;

            let execArgv = [];
            if(DEBUG) {
                const debugPort = ++defaultSession.debugPort;
                const debugFlag = '--debug=' + debugPort;
                execArgv.push(debugFlag);
            }

            const cwd = test.__meta.parent;

            let worker = forker.fork(test.data.path, [], {'cwd': cwd, 'env': env, 'execArgv': execArgv, stdio: [ 'inherit', "pipe", 'inherit', 'ipc' ], silent:false });

            this.__debugInfo(`Launching test ${test.data.name}, run[${test.result.runs}], on worker pid[${worker.pid}] `+new Date().getTime());

            worker.on("message", onMessageEventHandlerWrapper(test));
            worker.on("exit", onExitEventHandlerWrapper(test));
            worker.on("error", onErrorEventHandlerWrapper(test));

            worker.terminated = false;

            worker.stdout.on('data', function (chunk) {
                let content = new Buffer(chunk).toString('utf8'); //TODO: replace with PSKBUFFER
                if(test.__meta.conf.silent) {
                    this.__consoleLog(content);
                }
            }.bind(this));

            var self = this;
            function onMessageEventHandlerWrapper(test) {
                const currentRun = test.result.runs;
                return function(log) {
                    if(log.type === 'assert'){
                        if(log.message.includes("[Fail")) {
                            test.result.pass = false;
                        }
                        test.result.asserts[currentRun].push(log);
                    } else {
                        test.result.messages[currentRun].push(log);
                    }
                };
            }

            function onExitEventHandlerWrapper(test) {
                return function(code, signal) {
                    clearTimeout(worker.timerVar);
                    self.__debugInfo(`Worker ${worker.pid} - exit event. Code ${code}, signal ${signal} `+new Date().getTime());

                    worker.terminated = true;

                    test.result.state = TEST_STATES.FINISHED;
                    if(code !== null && code!==0 /*&& typeof test.result.pass === 'undefined'*/){
                        test.result.pass = false;
                        test.result.messages[test.result.runs].push( {message: "Process finished with errors!", "Exit code":code, "Signal":signal});
                    }

                    self.session.workers.running--;
                    self.session.workers.terminated++;

                    self.__scheduleWork();
                    self.__checkWorkersStatus();
                };
            }

            // this handler can be triggered when:
            // 1. The process could not be spawned, or
            // 2. The process could not be killed, or
            // 3. Sending a message to the child process failed.
            // IMPORTANT: The 'exit' event may or may not fire after an error has occurred!
            function onErrorEventHandlerWrapper(test) {
                return function(error) {
                    self.__debugInfo(`Worker ${worker.pid} - error event.`, test);
                    self.__debugError(error);

                    self.session.workers.running--;
                    self.session.workers.terminated++;
                };
            }

            // Note: on debug, the timeout is reached before exit event is called
            // when kill is called, the exit event is raised
            worker.timerVar = setTimeout(()=>{
                if(!worker.terminated){
                    this.__consoleLog(`worker pid [${worker.pid}] - timeout event`,new Date().getTime(),  test);

                    if(test.result.state !== TEST_STATES.FINISHED){
                        test.result.pass = false;
                    }
                    worker.kill();
                    test.result.state = TEST_STATES.TIMEOUT;
                }else{
                    console.log("Got something, but don't know what...", test);
                }
            }, test.__meta.conf.timeout);

                self.__debugInfo(`Worker ${worker.pid} - set timeout event at `+new Date().getTime() + " for "+test.__meta.conf.timeout);

        },
        /**
         * Checks if all workers completed their job (finished or have been terminated).
         * If true, then the reporting steps can be started.
         * @private
         */
        __checkWorkersStatus: function() {
            if(this.session.workers.running === 0) {
                this.__doTestReports();
            }
        },
        /**
         * Creates test reports object (JSON) that will be saved in the test report.
         * Filename of the report is using the following pattern: {prefix}-{timestamp}{ext}
         * The file will be saved in config.reports.basePath.
         * @private
         */
        __doTestReports: function() {
            this.__consoleLog("Doing reports ...");
            reportFileStructure.count = this.testList.length;

            // pass/failed tests
            for(let i = 0, len = this.testList.length; i < len; i++) {
                let test = this.testList[i];

                let testPath = this.__toRelativePath(test.data.path);
                let item = {path: testPath};
                if(test.result.pass) {
                    item.reason = this.__getFirstFailReasonPerRun(test);
                    reportFileStructure.passed.items.push(item);
                } else {
                    item.reason = this.__getFirstFailReasonPerRun(test);
                    reportFileStructure.failed.items.push(item);
                }
            }
            reportFileStructure.passed.count = reportFileStructure.passed.items.length;
            reportFileStructure.failed.count = reportFileStructure.failed.items.length;

            // suites (first level of directories)
            for(let i = 0, len = this.testTree.items.length; i < len; i++) {
                let item = this.testTree.items[i];
                if(item.__meta.isDirectory) {
                    let suitePath = this.__toRelativePath(item.data.path);
                    reportFileStructure.suites.items.push(suitePath);
                }
            }
            reportFileStructure.suites.count = reportFileStructure.suites.items.length;

            let numberOfReports = 2;

            let finishReports = (err, res) => {
                if(numberOfReports > 1){
                    numberOfReports -= 1;
                    return;
                }
                if(reportFileStructure.failed.count === 0){
                    this.__consoleLog("\nEverything went well! No failed tests.\n\n");
                }else{
                    this.__consoleLog("\nSome tests failed. Check report files!\n\n");
                }

                this.callback(err, "Done");
            };


            this.__consoleLog(this.config.reports.prefix);
            const fileName = `${this.config.reports.prefix}latest${this.config.reports.ext}`;
            const filePath = path.join(this.config.reports.basePath, fileName);
            this.__saveReportToFile(reportFileStructure, filePath, finishReports);

            const timestamp = new Date().getTime().toString();
            const htmlFileName = `${this.config.reports.prefix}latest.html`;
            const htmlFilePath = path.join(this.config.reports.basePath, htmlFileName);
            this.__saveHtmlReportToFile(reportFileStructure, htmlFilePath, timestamp, finishReports);
        },
        /**
         * Saves test reports object (JSON) in the specified path.
         * @param reportFileStructure {Object} - test reports object (JSON)
         * @param destination {String} - path of the file report (the base path MUST exist)
         * @private
         */
        __saveReportToFile: function(reportFileStructure, destination, callback) {

            var content = JSON.stringify(reportFileStructure, null, 4);
            fs.writeFile(destination, content, 'utf8', function (err) {
                if (err) {
                    const message = "An error occurred while writing the report file, with the following error: " + JSON.stringify(err);
                    this.__debugInfo(message);
                    throw err;
                } else{
                    const message = `Finished writing report to ${destination}`;
                    this.__consoleLog(message);
                }
                callback();
            }.bind(this));
        },
        /**
         * Saves test reports as HTML in the specified path.
         * @param reportFileStructure {Object} - test reports object (JSON)
         * @param destination {String} - path of the file report (the base path MUST exist)
         * @param timestamp {String} - timestamp to be injected in html template
         * @private
         */
        __saveHtmlReportToFile: function (reportFileStructure, destination, timestamp, callback) {
            var folderName = path.resolve(__dirname);
            fs.readFile(path.join(folderName,'/utils/reportTemplate.html'), 'utf8', (err, res) => {
                if (err) {
                    const message = 'An error occurred while reading the html report template file, with the following error: ' + JSON.stringify(err);
                    this.__debugInfo(message);
                    throw err;
                }

                fs.writeFile(destination, res + `<script>init(${JSON.stringify(reportFileStructure)}, ${timestamp});</script>`, 'utf8', (err) => {
                    if (err) {
                        const message = 'An error occurred while writing the html report file, with the following error: ' + JSON.stringify(err);
                        this.__debugInfo(message);
                        throw err;
                    }

                    const message = `Finished writing report to ${destination}`;
                    this.__consoleLog(message);

                    callback();
                });
            });
        },
        /**
         * Converts absolute file path to relative path.
         * @param absolutePath {String} - absolute path
         * @returns {string | void | *} - relative path
         * @private
         */
        __toRelativePath: function(absolutePath) {
            const basePath = path.join(this.config.testsDir, "/");
            const relativePath = absolutePath.replace(basePath, "");
            return relativePath;
        },
        /**
         * Checks if a directory is a test dir, by matching its name against config.matchDirs array.
         * @param dir {String} - directory name
         * @returns {boolean} - returns true if there is a match and false otherwise.
         * @private
         */
        __isTestDir: function(dir) {
            if(!this.config || !this.config.matchDirs ) {
                throw `matchDirs is not defined on config ${JSON.stringify(this.config)} does not exist!`;
            }

            var isTestDir = this.config.matchDirs.some(function(item) {
                return dir.toLowerCase().includes(item.toLowerCase());
            });

            return isTestDir;
        },
        /**
         * For a failed test, it returns only the first fail reason per each run.
         * @param test {Object} - test object
         * @returns {Array} - an array of reasons per each test run.
         * @private
         */
        __getFirstFailReasonPerRun: function(test) {
            const reason = [];
            for(let i = 1; i <= test.result.runs; i++) {
                if(test.result.asserts[i] && test.result.asserts[i].length > 0) {
                    addReason(i, test.result.asserts[i][0]);
                }

                if(test.result.messages[i] && test.result.messages[i].length > 0) {
                    addReason(i, test.result.messages[i][0]);
                }

                function addReason(run, log) {
                    const message = {
                        run: run,
                        log: log
                    };

                    reason.push(message);
                }
            }

            return reason;
        },
        /**
         * Described default tree node structure.
         * @returns {{__meta: {conf: null, parent: null, isDirectory: boolean}, data: {name: null, path: null}, result: {state: string, pass: null, executionTime: number, runs: number, asserts: {}, messages: {}}, items: null}}
         * @private
         */
        __getDefaultNodeStructure: function() {
            return  {
                __meta: {
                    conf: null,
                    parent: null,
                    isDirectory: false
                },
                data: {
                    name: null,
                    path: null,
                },
                result: {
                    state: TEST_STATES.READY, // ready | running | terminated | timeout
                    pass: null,
                    executionTime: 0,
                    runs: 0,
                    asserts: {},
                    messages: {}
                },
                items: null
            };
        },
        /**
         * Match a test file path to a UNIX glob expression array. If its any match returns true, otherwise returns false.
         * @param globExpArray {Array} - an array with glob expression (UNIX style)
         * @param str {String} - the string to be matched
         * @returns {boolean} - returns true if there is any match and false otherwise.
         * @private
         */
        __isAnyMatch: function(globExpArray, str) {
            const hasMatch = function(globExp) {
                const regex = globToRegExp(globExp);
                return regex.test(str);
            };

            return globExpArray.some(hasMatch);
        },
        /**
         * Converts a tree structure into an array list of test nodes. The tree traversal is DFS (Deep-First-Search).
         * @param rootNode {Object} - root node of the test tree.
         * @returns {Array} - List of test nodes.
         * @private
         */
        __toTestTreeToList: function(rootNode) {
            var testList = [];

            traverse(rootNode);

            function traverse(node) {
                if(!node.__meta.isDirectory || !node.items) {
                    return;
                }

                for(let i = 0, len = node.items.length; i < len; i++) {
                    const item = node.items[i];
                    if(item.__meta.isDirectory) {
                        traverse(item);
                    } else {
                        testList.push(item);
                    }
                }
            }

            return testList;
        },
        /**
         * Logging to console wrapper.
         * @param log {String|Object|Number} - log message
         * @private
         */
        __consoleLog: function(log) {
            console.log(TAG, log);
        },
        /**
         * Logging debugging info messages wrapper.
         * Logger: console.info
         * @param log {String|Object|Number} - log message
         * @private
         */
        __debugInfo: function(log) {
            this.__debug(console.info, log);
        },
        /**
         * Logging debugging error messages wrapper.
         * Logger: console.error
         * @param log {String|Object|Number} - log message
         * @private
         */
        __debugError: function(log) {
            this.__debug(console.error, log);
        },
        /**
         *  Logging debugging messages wrapper. One debug mode, the logging is silent.
         * @param logger {Function} - handler for logging
         * @param log {String|Object|Number} - log message
         * @private
         */
        __debug: function(logger, log) {
            if(!DEBUG) {return;}

            // let prettyLog = JSON.stringify(log, null, 2);
            logger("DEBUG", log);
        },
        /**
         * Deep extend one object with properties of another object.
         * If the property exists in both objects the property from the first object is overridden.
         * @param first {Object} - the first object
         * @param second {Object} - the second object
         * @returns {Object} - an object with both properties from the first and second object.
         * @private
         */
        __extend: function (first, second) {
            for (const key in second) {
                if (!first.hasOwnProperty(key)) {
                    first[key] = second[key];
                } else {
                    let val = second[key];
                    if(typeof first[key] === 'object') {
                        val = this.__extend(first[key], second[key]);
                    }

                    first[key] = val;
                }
            }

            return first;
        }
    };
};

}).call(this,require("buffer").Buffer,"/modules/double-check/lib")

},{"./utils/glob-to-regexp":"/opt/privatesky/modules/double-check/lib/utils/glob-to-regexp.js","buffer":"buffer","child_process":false,"fs":false,"path":"path"}],"/opt/privatesky/modules/double-check/lib/utils/glob-to-regexp.js":[function(require,module,exports){

// globToRegExp turns a UNIX glob expression into a RegEx expression.
//  Supports all simple glob patterns. Examples: *.ext, /foo/*, ../../path, ^foo.*
// - single character matching, matching ranges of characters etc. group matching are no supported
// - flags are not supported
var globToRegExp = function (globExp) {
    if (typeof globExp !== 'string') {
        throw new TypeError('Glob Expression must be a string!');
    }

    var regExp = "";

    for (let i = 0, len = globExp.length; i < len; i++) {
        let c = globExp[i];

        switch (c) {
            case "/":
            case "$":
            case "^":
            case "+":
            case ".":
            case "(":
            case ")":
            case "=":
            case "!":
            case "|":
                regExp += "\\" + c;
                break;

            case "*":
                // treat any number of "*" as one
                while(globExp[i + 1] === "*") {
                    i++;
                }
                regExp += ".*";
                break;

            default:
                regExp += c;
        }
    }

    // set the regular expression with ^ & $
    regExp = "^" + regExp + "$";

    return new RegExp(regExp);
};

module.exports = globToRegExp;
},{}],"/opt/privatesky/modules/foldermq/lib/folderMQ.js":[function(require,module,exports){
const utils = require("swarmutils");
const OwM = utils.OwM;
var beesHealer = utils.beesHealer;
var fs = require("fs");
var path = require("path");


//TODO: prevent a class of race condition type of errors by signaling with files metadata to the watcher when it is safe to consume

function FolderMQ(folder, callback = () => {}){

	if(typeof callback !== "function"){
		throw new Error("Second parameter should be a callback function");
	}

	folder = path.normalize(folder);

	fs.mkdir(folder, {recursive: true}, function(err, res){
		fs.exists(folder, function(exists) {
			if (exists) {
				return callback(null, folder);
			} else {
				return callback(err);
			}
		});
	});

	function mkFileName(swarmRaw){
		let meta = OwM.prototype.getMetaFrom(swarmRaw);
		let name = `${folder}${path.sep}${meta.swarmId}.${meta.swarmTypeName}`;
		const unique = meta.phaseId || $$.uidGenerator.safe_uuid();

		name = name+`.${unique}`;
		return path.normalize(name);
	}

	this.getHandler = function(){
		if(producer){
			throw new Error("Only one consumer is allowed!");
		}
		producer = true;
		return {
			sendSwarmSerialization: function(serialization, callback){
				if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}
				writeFile(mkFileName(JSON.parse(serialization)), serialization, callback);
			},
			addStream : function(stream, callback){
				if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}

				if(!stream || !stream.pipe || typeof stream.pipe !== "function"){
					return callback(new Error("Something wrong happened"));
				}

				let swarm = "";
				stream.on('data', (chunk) =>{
					swarm += chunk;
				});

				stream.on("end", () => {
					writeFile(mkFileName(JSON.parse(swarm)), swarm, callback);
				});

				stream.on("error", (err) =>{
					callback(err);
				});
			},
			addSwarm : function(swarm, callback){
				if(!callback){
					callback = $$.defaultErrorHandlingImplementation;
				}else if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}

				beesHealer.asJSON(swarm,null, null, function(err, res){
					if (err) {
						console.log(err);
					}
					writeFile(mkFileName(res), J(res), callback);
				});
			},
			sendSwarmForExecution: function(swarm, callback){
				if(!callback){
					callback = $$.defaultErrorHandlingImplementation;
				}else if(typeof callback !== "function"){
					throw new Error("Second parameter should be a callback function");
				}

				beesHealer.asJSON(swarm, OwM.prototype.getMetaFrom(swarm, "phaseName"), OwM.prototype.getMetaFrom(swarm, "args"), function(err, res){
					if (err) {
						console.log(err);
					}
					var file = mkFileName(res);
					var content = JSON.stringify(res);

					//if there are no more FD's for files to be written we retry.
					function wrapper(error, result){
						if(error){
							console.log(`Caught an write error. Retry to write file [${file}]`);
							setTimeout(()=>{
								writeFile(file, content, wrapper);
							}, 10);
						}else{
							return callback(error, result);
						}
					}

					writeFile(file, content, wrapper);
				});
			}
		};
	};

	var recipient;
	this.setIPCChannel = function(processChannel){
		if(processChannel && !processChannel.send || (typeof processChannel.send) != "function"){
			throw new Error("Recipient is not instance of process/child_process or it was not spawned with IPC channel!");
		}
		recipient = processChannel;
		if(consumer){
			console.log(`Channel updated`);
			(recipient || process).on("message", receiveEnvelope);
		}
	};


	var consumedMessages = {};

	function checkIfConsummed(name, message){
		const shortName = path.basename(name);
		const previousSaved = consumedMessages[shortName];
		let result = false;
		if(previousSaved && !previousSaved.localeCompare(message)){
			result = true;
		}
		return result;
	}

	function save2History(envelope){
		consumedMessages[path.basename(envelope.name)] = envelope.message;
	}

	function buildEnvelopeConfirmation(envelope, saveHistory){
		if(saveHistory){
			save2History(envelope);
		}
		return `Confirm envelope ${envelope.timestamp} sent to ${envelope.dest}`;
	}

	function buildEnvelope(name, message){
		return {
			dest: folder,
			src: process.pid,
			timestamp: new Date().getTime(),
			message: message,
			name: name
		};
	}

	function receiveEnvelope(envelope){
		if(!envelope || typeof envelope !== "object"){
			return;
		}
		//console.log("received envelope", envelope, folder);

		if(envelope.dest !== folder && folder.indexOf(envelope.dest)!== -1 && folder.length === envelope.dest+1){
			console.log("This envelope is not for me!");
			return;
		}

		let message = envelope.message;

		if(callback){
			//console.log("Sending confirmation", process.pid);
			recipient.send(buildEnvelopeConfirmation(envelope, true));
			consumer(null, JSON.parse(message));
		}
	}

	this.registerAsIPCConsumer = function(callback){
		if(typeof callback !== "function"){
			throw new Error("The argument should be a callback function");
		}
		registeredAsIPCConsumer = true;
		//will register as normal consumer in order to consume all existing messages but without setting the watcher
		this.registerConsumer(callback, true, (watcher) => !watcher);

		//console.log("Registered as IPC Consummer", );
		(recipient || process).on("message", receiveEnvelope);
	};

	this.registerConsumer = function (callback, shouldDeleteAfterRead = true, shouldWaitForMore = (watcher) => true) {
		if(typeof callback !== "function"){
			throw new Error("First parameter should be a callback function");
		}
		if (consumer) {
			throw new Error("Only one consumer is allowed! " + folder);
		}

		consumer = callback;

		fs.mkdir(folder, {recursive: true}, function (err, res) {
			if (err && (err.code !== 'EEXIST')) {
				console.log(err);
			}
			consumeAllExisting(shouldDeleteAfterRead, shouldWaitForMore);
		});
	};

	this.writeMessage = writeFile;

	this.unlinkContent = function (messageId, callback) {
		const messagePath = path.join(folder, messageId);

		fs.unlink(messagePath, (err) => {
			callback(err);
		});
	};

	this.dispose = function(force){
		if(typeof folder != "undefined"){
			var files;
			try{
				files = fs.readdirSync(folder);
			}catch(error){
				//..
			}

			if(files && files.length > 0 && !force){
				console.log("Disposing a channel that still has messages! Dir will not be removed!");
				return false;
			}else{
				try{
					fs.rmdirSync(folder);
				}catch(err){
					//..
				}
			}

			folder = null;
		}

		if(producer){
			//no need to do anything else
		}

		if(typeof consumer != "undefined"){
			consumer = () => {};
		}

		if(watcher){
			watcher.close();
			watcher = null;
		}

		return true;
	};


	/* ---------------- protected  functions */
	var consumer = null;
	var registeredAsIPCConsumer = false;
	var producer = null;

	function buildPathForFile(filename){
		return path.normalize(path.join(folder, filename));
	}

	function consumeMessage(filename, shouldDeleteAfterRead, callback) {
		var fullPath = buildPathForFile(filename);

		fs.readFile(fullPath, "utf8", function (err, data) {
			if (!err) {
				if (data !== "") {
					try {
						var message = JSON.parse(data);
					} catch (error) {
						console.log("Parsing error", error);
						err = error;
					}

					if(checkIfConsummed(fullPath, data)){
						//console.log(`message already consumed [${filename}]`);
						return ;
					}

					if (shouldDeleteAfterRead) {

						fs.unlink(fullPath, function (err, res) {
							if (err) {throw err;};
						});

					}
					return callback(err, message);
				}
			} else {
				console.log("Consume error", err);
				return callback(err);
			}
		});
	}

	function consumeAllExisting(shouldDeleteAfterRead, shouldWaitForMore) {

		let currentFiles = [];

		fs.readdir(folder, 'utf8', function (err, files) {
			if (err) {
				$$.errorHandler.error(err);
				return;
			}
			currentFiles = files;
			iterateAndConsume(files);

		});

		function startWatching(){
			if (shouldWaitForMore(true)) {
				watchFolder(shouldDeleteAfterRead, shouldWaitForMore);
			}
		}

		function iterateAndConsume(files, currentIndex = 0) {
			if (currentIndex === files.length) {
				//console.log("start watching", new Date().getTime());
				startWatching();
				return;
			}

			if (path.extname(files[currentIndex]) !== in_progress) {
				consumeMessage(files[currentIndex], shouldDeleteAfterRead, (err, data) => {
					if (err) {
						iterateAndConsume(files, ++currentIndex);
						return;
					}
					consumer(null, data, path.basename(files[currentIndex]));
					if (shouldWaitForMore()) {
						iterateAndConsume(files, ++currentIndex);
					}
				});
			} else {
				iterateAndConsume(files, ++currentIndex);
			}
		}
	}

	function writeFile(filename, content, callback){
		if(recipient){
			var envelope = buildEnvelope(filename, content);
			//console.log("Sending to", recipient.pid, recipient.ppid, "envelope", envelope);
			recipient.send(envelope);
			var confirmationReceived = false;

			function receiveConfirmation(message){
				if(message === buildEnvelopeConfirmation(envelope)){
					//console.log("Received confirmation", recipient.pid);
					confirmationReceived = true;
					try{
						recipient.off("message", receiveConfirmation);
					}catch(err){
						//...
					}

				}
			}

			recipient.on("message", receiveConfirmation);

			setTimeout(()=>{
				if(!confirmationReceived){
					//console.log("No confirmation...", process.pid);
					hidden_writeFile(filename, content, callback);
				}else{
					if(callback){
						return callback(null, content);
					}
				}
			}, 200);
		}else{
			hidden_writeFile(filename, content, callback);
		}
	}

	const in_progress = ".in_progress";
	function hidden_writeFile(filename, content, callback){
		var tmpFilename = filename+in_progress;
		try{
			if(fs.existsSync(tmpFilename) || fs.existsSync(filename)){
				console.log(new Error(`Overwriting file ${filename}`));
			}
			fs.writeFileSync(tmpFilename, content);
			fs.renameSync(tmpFilename, filename);
		}catch(err){
			return callback(err);
		}
		callback(null, content);
	}

	var alreadyKnownChanges = {};

	function alreadyFiredChanges(filename, change){
		var res = false;
		if(alreadyKnownChanges[filename]){
			res = true;
		}else{
			alreadyKnownChanges[filename] = change;
		}

		return res;
	}

	function watchFolder(shouldDeleteAfterRead, shouldWaitForMore){

		setTimeout(function(){
			fs.readdir(folder, 'utf8', function (err, files) {
				if (err) {
					$$.errorHandler.error(err);
					return;
				}

				for(var i=0; i<files.length; i++){
					watchFilesHandler("change", files[i]);
				}
			});
		}, 1000);

		function watchFilesHandler(eventType, filename){
			//console.log(`Got ${eventType} on ${filename}`);

			if(!filename || path.extname(filename) === in_progress){
				//caught a delete event of a file
				//or
				//file not ready to be consumed (in progress)
				return;
			}

			var f = buildPathForFile(filename);
			if(!fs.existsSync(f)){
				//console.log("File not found", f);
				return;
			}

			//console.log(`Preparing to consume ${filename}`);
			if(!alreadyFiredChanges(filename, eventType)){
				consumeMessage(filename, shouldDeleteAfterRead, (err, data) => {
					//allow a read a the file
					alreadyKnownChanges[filename] = undefined;

					if (err) {
						// ??
						console.log("\nCaught an error", err);
						return;
					}

					consumer(null, data, filename);


					if (!shouldWaitForMore()) {
						watcher.close();
					}
				});
			}else{
				console.log("Something happens...", filename);
			}
		}


		const watcher = fs.watch(folder, watchFilesHandler);

		const intervalTimer = setInterval(()=>{
			fs.readdir(folder, 'utf8', function (err, files) {
				if (err) {
					$$.errorHandler.error(err);
					return;
				}

				if(files.length > 0){
					console.log(`\n\nFound ${files.length} files not consumed yet in ${folder}`, new Date().getTime(),"\n\n");
					//faking a rename event trigger
					watchFilesHandler("rename", files[0]);
				}
			});
		}, 5000);
	}
}

exports.getFolderQueue = function(folder, callback){
	return new FolderMQ(folder, callback);
};

},{"fs":false,"path":"path","swarmutils":"swarmutils"}],"/opt/privatesky/modules/pskbuffer/lib/PSKBuffer.js":[function(require,module,exports){
function PSKBuffer() {}

function getArrayBufferInterface () {
    if(typeof SharedArrayBuffer === 'undefined') {
        return ArrayBuffer;
    } else {
        return SharedArrayBuffer;
    }
}

PSKBuffer.from = function (source) {
    const ArrayBufferInterface = getArrayBufferInterface();

    const buffer = new Uint8Array(new ArrayBufferInterface(source.length));
    buffer.set(source, 0);

    return buffer;
};

PSKBuffer.concat = function ([ ...params ], totalLength) {
    const ArrayBufferInterface = getArrayBufferInterface();

    if (!totalLength && totalLength !== 0) {
        totalLength = 0;
        for (const buffer of params) {
            totalLength += buffer.length;
        }
    }

    const buffer = new Uint8Array(new ArrayBufferInterface(totalLength));
    let offset = 0;

    for (const buf of params) {
        const len = buf.length;

        const nextOffset = offset + len;
        if (nextOffset > totalLength) {
            const remainingSpace = totalLength - offset;
            for (let i = 0; i < remainingSpace; ++i) {
                buffer[offset + i] = buf[i];
            }
        } else {
            buffer.set(buf, offset);
        }

        offset = nextOffset;
    }

    return buffer;
};

PSKBuffer.isBuffer = function (pskBuffer) {
    return !!ArrayBuffer.isView(pskBuffer);
};

PSKBuffer.alloc = function(size) {
    const ArrayBufferInterface = getArrayBufferInterface();

    return new Uint8Array(new ArrayBufferInterface(size));
};

module.exports = PSKBuffer;
},{}],"/opt/privatesky/modules/pskcrypto/lib/ECDSA.js":[function(require,module,exports){
const crypto = require('crypto');
const KeyEncoder = require('./keyEncoder');

function ECDSA(curveName){
    this.curve = curveName || 'secp256k1';
    const self = this;

    this.generateKeyPair = function() {
        const result     = {};
        const ec         = crypto.createECDH(self.curve);
        result.public  = ec.generateKeys('hex');
        result.private = ec.getPrivateKey('hex');
        return keysToPEM(result);
    };

    function keysToPEM(keys){
        const result                  = {};
        const ECPrivateKeyASN         = KeyEncoder.ECPrivateKeyASN;
        const SubjectPublicKeyInfoASN = KeyEncoder.SubjectPublicKeyInfoASN;
        const keyEncoder              = new KeyEncoder(self.curve);

        const privateKeyObject        = keyEncoder.privateKeyObject(keys.private,keys.public);
        const publicKeyObject         = keyEncoder.publicKeyObject(keys.public);

        result.private              = ECPrivateKeyASN.encode(privateKeyObject, 'pem', privateKeyObject.pemOptions);
        result.public               = SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', publicKeyObject.pemOptions);

        return result;

    }

    this.sign = function (privateKey,digest) {
        const sign = crypto.createSign("sha256");
        sign.update(digest);

        return sign.sign(privateKey,'hex');
    };

    this.verify = function (publicKey,signature,digest) {
        const verify = crypto.createVerify('sha256');
        verify.update(digest);

        return verify.verify(publicKey,signature,'hex');
    }
}

exports.createECDSA = function (curve){
    return new ECDSA(curve);
};
},{"./keyEncoder":"/opt/privatesky/modules/pskcrypto/lib/keyEncoder.js","crypto":"crypto"}],"/opt/privatesky/modules/pskcrypto/lib/PskCrypto.js":[function(require,module,exports){
(function (Buffer){
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const os = require('os');

const utils = require("./utils/cryptoUtils");

const PassThroughStream = require('./utils/PassThroughStream');

const EventEmitter = require('events');
const tempFolder = os.tmpdir();

function PskCrypto() {

    const self = this;

    const event = new EventEmitter();

    this.on = event.on;
    this.off = event.removeListener;
    this.removeAllListeners = event.removeAllListeners;
    this.emit = event.emit;

    /*--------------------------------------------- ECDSA functions ------------------------------------------*/
    const ecdsa = require("./ECDSA").createECDSA();
    this.generateECDSAKeyPair = function () {
        return ecdsa.generateKeyPair();
    };

    this.sign = function (privateKey, digest) {
        return ecdsa.sign(privateKey, digest);
    };

    this.verify = function (publicKey, signature, digest) {
        return ecdsa.verify(publicKey, signature, digest);
    };

    /*---------------------------------------------Encryption functions -------------------------------------*/

    this.encryptStream = function (inputPath, destinationPath, password, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        archiver.on('progress', (progress) => {
            self.emit('progress', progress);
        });

        fs.open(destinationPath, "wx", function (err, fd) {
            if (err) {
                callback(err);
                return;
            }

            fs.close(fd, function (err) {
                if (err) {
                    return callback(err);
                }

                const ws = fs.createWriteStream(destinationPath, {autoClose: false});
                const keySalt = crypto.randomBytes(32);
                const key = crypto.pbkdf2Sync(password, keySalt, utils.iterations_number, 32, 'sha512');

                const aadSalt = crypto.randomBytes(32);
                const aad = crypto.pbkdf2Sync(password, aadSalt, utils.iterations_number, 32, 'sha512');

                const salt = Buffer.concat([keySalt, aadSalt]);
                const iv = crypto.pbkdf2Sync(password, salt, utils.iterations_number, 12, 'sha512');

                const cipher = crypto.createCipheriv(utils.algorithm, key, iv);
                cipher.setAAD(aad);
                archiver.zipStream(inputPath, cipher, function (err, cipherStream) {

                    if (err) {
                        return callback(err);
                    }

                    cipherStream.on("data", function (chunk) {
                        ws.write(chunk);
                    });
                    cipherStream.on('end', function () {
                        const tag = cipher.getAuthTag();
                        const dataToAppend = Buffer.concat([salt, tag]);
                        ws.end(dataToAppend, function (err) {
                            if (err) {
                                return callback(err);
                            }

                            callback();
                        })
                    });
                });
            });
        });
    };

    this.decryptStream = function (encryptedInputPath, outputFolder, password, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        decryptFile(encryptedInputPath, tempFolder, password, function (err, tempArchivePath) {
            if (err) {
                return callback(err);
            }

            archiver.on('progress', (progress) => {
                self.emit('progress', 10 + 0.9 * progress);
            });


            archiver.unzipStream(tempArchivePath, outputFolder, function (err, unzippedFileNames) {
                if (err) {
                    return callback(err);
                }

                utils.deleteRecursively(tempArchivePath, function (err) {
                    if (err) {
                        return callback(err);
                    }

                    callback(undefined, unzippedFileNames);
                });

            });
        })
    };

    this.encryptObject = function (inputObj, dseed, depth, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        archiver.zipInMemory(inputObj, depth, function (err, zippedObj) {
            if (err) {
                return callback(err);
            }
            const cipherText = utils.encrypt(zippedObj, dseed);
            callback(null, cipherText);
        })
    };

    this.decryptObject = function (encryptedData, dseed, callback) {
        const PskArchiver = require("./psk-archiver");
        const archiver = new PskArchiver();

        const zippedObject = utils.decrypt(encryptedData, dseed);
        archiver.unzipInMemory(zippedObject, function (err, obj) {
            if (err) {
                return callback(err);
            }
            callback(null, obj);
        })
    };

    this.pskHash = function (data) {
        if (Buffer.isBuffer(data)) {
            return utils.createPskHash(data);
        }
        if (data instanceof Object) {
            return utils.createPskHash(JSON.stringify(data));
        }
        return utils.createPskHash(data);
    };

    this.pskHashStream = function (readStream, callback) {
        const pskHash = new utils.PskHash();

        readStream.on('data', (chunk) => {
            pskHash.update(chunk);
        });


        readStream.on('end', () => {
            callback(null, pskHash.digest());
        })
    };


    this.saveData = function (data, password, path, callback) {
        const encryptionKey = this.deriveKey(password, null, null);
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv('aes-256-cfb', encryptionKey, iv);
        let encryptedDSeed = cipher.update(data, 'binary');
        const final = Buffer.from(cipher.final('binary'), 'binary');
        encryptedDSeed = Buffer.concat([iv, encryptedDSeed, final]);
        fs.writeFile(path, encryptedDSeed, function (err) {
            callback(err);
        });
    };


    this.loadData = function (password, path, callback) {

        fs.readFile(path, null, (err, encryptedData) => {
            if (err) {
                callback(err);
            } else {
                const iv = encryptedData.slice(0, 16);
                const encryptedDseed = encryptedData.slice(16);
                const encryptionKey = this.deriveKey(password, null, null);
                const decipher = crypto.createDecipheriv('aes-256-cfb', encryptionKey, iv);
                let dseed = Buffer.from(decipher.update(encryptedDseed, 'binary'), 'binary');
                const final = Buffer.from(decipher.final('binary'), 'binary');
                dseed = Buffer.concat([dseed, final]);
                callback(null, dseed);
            }
        });
    };


    this.generateSafeUid = function (password, additionalData) {
        password = password || Buffer.alloc(0);
        if (!additionalData) {
            additionalData = Buffer.alloc(0);
        }

        if (!Buffer.isBuffer(additionalData)) {
            additionalData = Buffer.from(additionalData);
        }

        return utils.encode(this.pskHash(Buffer.concat([password, additionalData])));
    };

    this.deriveKey = function deriveKey(password, iterations, dkLen) {
        iterations = iterations || 1000;
        dkLen = dkLen || 32;
        const salt = utils.generateSalt(password, 32);
        const dk = crypto.pbkdf2Sync(password, salt, iterations, dkLen, 'sha512');
        return Buffer.from(dk);
    };

    this.randomBytes = crypto.randomBytes;
    this.PskHash = utils.PskHash;

    //-------------------------- Internal functions -----------------------------------
    function decryptFile(encryptedInputPath, tempFolder, password, callback) {
        fs.stat(encryptedInputPath, function (err, stats) {
            if (err) {
                return callback(err, null);
            }

            const fileSizeInBytes = stats.size;

            fs.open(encryptedInputPath, "r", function (err, fd) {
                if (err) {
                    callback(err, null);
                } else {
                    const encryptedAuthData = Buffer.alloc(80);

                    fs.read(fd, encryptedAuthData, 0, 80, fileSizeInBytes - 80, function (err, bytesRead) {
                        const salt = encryptedAuthData.slice(0, 64);
                        const keySalt = salt.slice(0, 32);
                        const aadSalt = salt.slice(-32);

                        const iv = crypto.pbkdf2Sync(password, salt, utils.iterations_number, 12, 'sha512');
                        const key = crypto.pbkdf2Sync(password, keySalt, utils.iterations_number, 32, 'sha512');
                        const aad = crypto.pbkdf2Sync(password, aadSalt, utils.iterations_number, 32, 'sha512');
                        const tag = encryptedAuthData.slice(-16);

                        const decipher = crypto.createDecipheriv(utils.algorithm, key, iv);

                        decipher.setAAD(aad);
                        decipher.setAuthTag(tag);
                        const rs = fs.createReadStream(encryptedInputPath, {start: 0, end: fileSizeInBytes - 81});
                        fs.mkdir(tempFolder, {recursive: true}, function (err) {

                            if (err) {
                                return callback(err);
                            }
                            const tempArchivePath = path.join(tempFolder, path.basename(encryptedInputPath) + ".zip");

                            fs.open(tempArchivePath, "w", function (err, fd) {
                                if (err) {
                                    callback(err);
                                    return;
                                }

                                fs.close(fd, function (err) {

                                    if (err) {
                                        return callback(err);
                                    }

                                    const ptStream = new PassThroughStream();

                                    const ws = fs.createWriteStream(tempArchivePath, {autoClose: false});
                                    ws.on("finish", function () {
                                        callback(null, tempArchivePath);
                                    });


                                    let progressLength = 0;
                                    let totalLength = 0;

                                    /**
                                     * TODO review this
                                     * In browser, piping will block the event loop and the stack queue is not called.
                                     */
                                    rs.on("data", (chunk) => {
                                        progressLength += chunk.length;
                                        totalLength += chunk.length;

                                        if (progressLength > 300000) {
                                            progressLength = 0;
                                            emitProgress(fileSizeInBytes, totalLength)
                                        }
                                    });

                                    rs.pipe(decipher).pipe(ptStream).pipe(ws);

                                });
                            });
                        });

                    });

                }
            });
        });
    }

    function emitProgress(total, processed) {


        if (processed > total) {
            processed = total;
        }

        const progress = (100 * processed) / total;
        self.emit('progress', parseInt(progress));
    }

}

module.exports = new PskCrypto();

}).call(this,require("buffer").Buffer)

},{"./ECDSA":"/opt/privatesky/modules/pskcrypto/lib/ECDSA.js","./psk-archiver":"/opt/privatesky/modules/pskcrypto/lib/psk-archiver.js","./utils/PassThroughStream":"/opt/privatesky/modules/pskcrypto/lib/utils/PassThroughStream.js","./utils/cryptoUtils":"/opt/privatesky/modules/pskcrypto/lib/utils/cryptoUtils.js","buffer":"buffer","crypto":"crypto","events":"events","fs":false,"os":"os","path":"path"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/api.js":[function(require,module,exports){
var asn1 = require('./asn1');
var inherits = require('util').inherits;

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"./asn1":"/opt/privatesky/modules/pskcrypto/lib/asn1/asn1.js","util":"util","vm":false}],"/opt/privatesky/modules/pskcrypto/lib/asn1/asn1.js":[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('./bignum/bn');

asn1.define = require('./api').define;
asn1.base = require('./base/index');
asn1.constants = require('./constants/index');
asn1.decoders = require('./decoders/index');
asn1.encoders = require('./encoders/index');

},{"./api":"/opt/privatesky/modules/pskcrypto/lib/asn1/api.js","./base/index":"/opt/privatesky/modules/pskcrypto/lib/asn1/base/index.js","./bignum/bn":"/opt/privatesky/modules/pskcrypto/lib/asn1/bignum/bn.js","./constants/index":"/opt/privatesky/modules/pskcrypto/lib/asn1/constants/index.js","./decoders/index":"/opt/privatesky/modules/pskcrypto/lib/asn1/decoders/index.js","./encoders/index":"/opt/privatesky/modules/pskcrypto/lib/asn1/encoders/index.js"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/base/buffer.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":"/opt/privatesky/modules/pskcrypto/lib/asn1/base/index.js","buffer":"buffer","util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/base/index.js":[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":"/opt/privatesky/modules/pskcrypto/lib/asn1/base/buffer.js","./node":"/opt/privatesky/modules/pskcrypto/lib/asn1/base/node.js","./reporter":"/opt/privatesky/modules/pskcrypto/lib/asn1/base/reporter.js"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/base/node.js":[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
//var assert = require('double-check').assert;

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  //assert.equal(state.parent,null,'state.parent should be null');
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  // assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    // assert.equal(state.children, null, 'state.children should be null');
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    // assert.equal(state.args, null, 'state.args should be null');
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    // assert.equal(state.tag, null, 'state.tag should be null');
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  // assert.equal(state.use, null, 'state.use should be null');
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  // assert.equal(state['default'], null, "state['default'] should be null");
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  // assert.equal(state.explicit,null, 'state.explicit should be null');
  // assert.equal(state.implicit,null, 'state.implicit should be null');

  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

    // assert.equal(state.explicit,null, 'state.explicit should be null');
    // assert.equal(state.implicit,null, 'state.implicit should be null');

    state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  // assert.equal(state.key, null, 'state.key should be null');
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  // assert.equal(state.choice, null,'state.choice should be null');
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input);
        else
          this._decodeChoice(input);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return err;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr')
    return this._decodeStr(input, tag);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);

  return null;
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  // assert.equal(state.useDecoder._baseState.parent, null, 'state.useDecoder._baseState.parent should be null');
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;
  var present = true;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // For error reporting
  var prevKey;

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  // if (!node) {
  //   assert(
  //       false,
  //       data.type + ' not found in ' +
  //           JSON.stringify(Object.keys(state.choice)));
  // }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'utf8str')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

},{"../base":"/opt/privatesky/modules/pskcrypto/lib/asn1/base/index.js"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/base/reporter.js":[function(require,module,exports){
var inherits = require('util').inherits;

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/bignum/bn.js":[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.sign = false;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (base === 'le' || base === 'be') {
    endian = base;
    base = 10;
  }

  if (number !== null)
    this._init(number || 0, base || 10, endian || 'be');
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.sign = true;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.sign = true;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.sign = this.sign;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.sign = false;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var padding = padding | 0 || 1;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.sign = false;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian) {
  this.strip();
  var res = new Array(this.byteLength());
  res[0] = 0;

  var q = this.clone();
  if (endian !== 'le') {
    // Assume big-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[res.length - i - 1] = b;
    }
  } else {
    // Assume little-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[i] = b;
    }
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.sign = !this.sign;
  return r;
};


// Or `num` with `this` in-place
BN.prototype.ior = function ior(num) {
  this.sign = this.sign || num.sign;

  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};


// And `num` with `this` in-place
BN.prototype.iand = function iand(num) {
  this.sign = this.sign && num.sign;

  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};


// Xor `num` with `this` in-place
BN.prototype.ixor = function ixor(num) {
  this.sign = this.sign || num.sign;

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.sign && !num.sign) {
    this.sign = false;
    var r = this.isub(num);
    this.sign = !this.sign;
    return this._normSign();

  // positive + negative
  } else if (!this.sign && num.sign) {
    num.sign = false;
    var r = this.isub(num);
    num.sign = true;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] + b.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.sign && !this.sign) {
    num.sign = false;
    var res = this.sub(num);
    num.sign = true;
    return res;
  } else if (!num.sign && this.sign) {
    this.sign = false;
    var res = num.sub(this);
    this.sign = true;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.sign) {
    num.sign = false;
    var r = this.iadd(num);
    num.sign = true;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.sign) {
    this.sign = false;
    this.iadd(num);
    this.sign = true;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.sign = false;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] - b.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.sign = true;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword;
    carry = ncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype._bigMulTo = function _bigMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  if (this.length + num.length < 63)
    res = this._smallMulTo(num, out);
  else
    res = this._bigMulTo(num, out);
  return res;
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
    this.words[0] = 0;
    this.length = 1;
    return this;
  }

  var tlen = this.length;
  var nlen = num.length;

  this.sign = num.sign !== this.sign;
  this.length = this.length + num.length;
  this.words[this.length - 1] = 0;

  for (var k = this.length - 2; k >= 0; k--) {
    // Sum all words with the same `i + j = k` and accumulate `carry`,
    // note that carry could be >= 0x3ffffff
    var carry = 0;
    var rword = 0;
    var maxJ = Math.min(k, nlen - 1);
    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i];
      var b = num.words[j];
      var r = a * b;

      var lo = r & 0x3ffffff;
      carry += (r / 0x4000000) | 0;
      lo += rword;
      rword = lo & 0x3ffffff;
      carry += lo >>> 26;
    }
    this.words[k] = rword;
    this.words[k + 1] += carry;
    carry = 0;
  }

  // Propagate overflows
  var carry = 0;
  for (var i = 1; i < this.length; i++) {
    var w = this.words[i] + carry;
    this.words[i] = w & 0x3ffffff;
    carry = w >>> 26;
  }

  return this.strip();
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = this.words[i] * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.mul(this);
};

// Shift-left in-place
BN.prototype.ishln = function ishln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i];
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  this.strip();

  return this;
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(!this.sign, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.sign) {
    if (this.length === 1 && this.words[0] < num) {
      this.words[0] = num - this.words[0];
      this.sign = false;
      return this;
    }

    this.sign = false;
    this.isubn(num);
    this.sign = true;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.sign) {
    this.sign = false;
    this.iaddn(num);
    this.sign = true;
    return this;
  }

  this.words[0] -= num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    this.words[i] += 0x4000000;
    this.words[i + 1] -= 1;
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.sign = false;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = this.words[i + shift] + carry;
    var right = num.words[i] * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = this.words[i + shift] + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -this.words[i] + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.sign = true;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1];
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.shln(shift);
    a.ishln(shift);
    bhi = b.words[b.length - 1];
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (!diff.sign) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.sign) {
      qj--;
      a.sign = false;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.sign = !a.sign;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.ishrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode) {
  assert(num.cmpn(0) !== 0);

  if (this.sign && !num.sign) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div')
      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
    return {
      div: div,
      mod: mod
    };
  } else if (!this.sign && num.sign) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if (this.sign && num.sign) {
    return this.neg().divmod(num.neg(), mode);
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div').div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod').mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

  var half = num.shrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + this.words[i]) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = this.words[i] + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.sign)
    x = x.mod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.ishrn(1);
    y.ishrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.ishrn(1);
      if (A.isEven() && B.isEven()) {
        A.ishrn(1);
        B.ishrn(1);
      } else {
        A.iadd(yp).ishrn(1);
        B.isub(xp).ishrn(1);
      }
    }

    while (y.isEven()) {
      y.ishrn(1);
      if (C.isEven() && D.isEven()) {
        C.ishrn(1);
        D.ishrn(1);
      } else {
        C.iadd(yp).ishrn(1);
        D.isub(xp).ishrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.ishln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.sign)
    a = a.mod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.ishrn(1);
      if (x1.isEven())
        x1.ishrn(1);
      else
        x1.iadd(delta).ishrn(1);
    }
    while (b.isEven()) {
      b.ishrn(1);
      if (x2.isEven())
        x2.ishrn(1);
      else
        x2.iadd(delta).ishrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  if (a.cmpn(1) === 0)
    return x1;
  else
    return x2;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.sign = false;
  b.sign = false;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.ishrn(1);
    b.ishrn(1);
  }

  do {
    while (a.isEven())
      a.ishrn(1);
    while (b.isEven())
      b.ishrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.ishln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.mod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i];
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.cmpn = function cmpn(num) {
  var sign = num < 0;
  if (sign)
    num = -num;

  if (this.sign && !sign)
    return -1;
  else if (!this.sign && sign)
    return 1;

  num &= 0x3ffffff;
  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    var w = this.words[0];
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.sign)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.sign && !num.sign)
    return -1;
  else if (!this.sign && num.sign)
    return 1;

  var res = this.ucmp(num);
  if (this.sign)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i];
    var b = num.words[i];

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(!this.sign, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.shl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).ishln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.ishrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i];
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i];
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = num.words[i] * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(!a.sign, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert(!a.sign && !b.sign, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.mod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.sign = !r.sign;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.shln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).ishrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.ishrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).ishrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).ishrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).ishln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.sign) {
    inv.sign = false;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  var w = [];

  if (num.cmpn(0) === 0)
    return new BN(1);

  var q = num.clone();

  while (q.cmpn(0) !== 0) {
    w.push(q.andln(1));
    q.ishrn(1);
  }

  // Skip leading zeroes
  var res = a;
  for (var i = 0; i < w.length; i++, res = this.sqr(res))
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
      if (w[i] === 0)
        continue;
      res = this.mul(res, q);
    }
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.mod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).ishln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv.sign = true;
  this.minv = this.minv.mod(this.r);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.shln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],"/opt/privatesky/modules/pskcrypto/lib/asn1/constants/der.js":[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":"/opt/privatesky/modules/pskcrypto/lib/asn1/constants/index.js"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/constants/index.js":[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":"/opt/privatesky/modules/pskcrypto/lib/asn1/constants/der.js"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/decoders/der.js":[function(require,module,exports){
var inherits = require('util').inherits;

var asn1 = require('../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return buffer.raw().toString();
  } else {
    return this.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return this.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../asn1":"/opt/privatesky/modules/pskcrypto/lib/asn1/asn1.js","util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/decoders/index.js":[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":"/opt/privatesky/modules/pskcrypto/lib/asn1/decoders/der.js","./pem":"/opt/privatesky/modules/pskcrypto/lib/asn1/decoders/pem.js"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/decoders/pem.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Buffer = require('buffer').Buffer;

var asn1 = require('../asn1');
var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"../asn1":"/opt/privatesky/modules/pskcrypto/lib/asn1/asn1.js","./der":"/opt/privatesky/modules/pskcrypto/lib/asn1/decoders/der.js","buffer":"buffer","util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/encoders/der.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Buffer = require('buffer').Buffer;

var asn1 = require('../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'octstr')
    return this._createEncoderBuffer(str);
  else if (tag === 'bitstr')
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._createEncoderBuffer(str);
  return this.reporter.error('Encoding of string type: ' + tag +
                             ' unsupported');
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (num.sign === false && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../asn1":"/opt/privatesky/modules/pskcrypto/lib/asn1/asn1.js","buffer":"buffer","util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/encoders/index.js":[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":"/opt/privatesky/modules/pskcrypto/lib/asn1/encoders/der.js","./pem":"/opt/privatesky/modules/pskcrypto/lib/asn1/encoders/pem.js"}],"/opt/privatesky/modules/pskcrypto/lib/asn1/encoders/pem.js":[function(require,module,exports){
var inherits = require('util').inherits;
var Buffer = require('buffer').Buffer;

var asn1 = require('../asn1');
var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"../asn1":"/opt/privatesky/modules/pskcrypto/lib/asn1/asn1.js","./der":"/opt/privatesky/modules/pskcrypto/lib/asn1/encoders/der.js","buffer":"buffer","util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/keyEncoder.js":[function(require,module,exports){
(function (Buffer){
'use strict'

var asn1 = require('./asn1/asn1');
var BN = require('./asn1/bignum/bn');

var ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {
    this.seq().obj(
        this.key('version').int(),
        this.key('privateKey').octstr(),
        this.key('parameters').explicit(0).objid().optional(),
        this.key('publicKey').explicit(1).bitstr().optional()
    )
})

var SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function() {
    this.seq().obj(
        this.key('algorithm').seq().obj(
            this.key("id").objid(),
            this.key("curve").objid()
        ),
        this.key('pub').bitstr()
    )
})

var curves = {
    secp256k1: {
        curveParameters: [1, 3, 132, 0, 10],
        privatePEMOptions: {label: 'EC PRIVATE KEY'},
        publicPEMOptions: {label: 'PUBLIC KEY'}
    }
}

function assert(val, msg) {
    if (!val) {
        throw new Error(msg || 'Assertion failed')
    }
}

function KeyEncoder(options) {
    if (typeof options === 'string') {
        assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);
        options = curves[options]
    }
    this.options = options;
    this.algorithmID = [1, 2, 840, 10045, 2, 1]
}

KeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;
KeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;

KeyEncoder.prototype.privateKeyObject = function(rawPrivateKey, rawPublicKey) {
    var privateKeyObject = {
        version: new BN(1),
        privateKey: new Buffer(rawPrivateKey, 'hex'),
        parameters: this.options.curveParameters,
        pemOptions: {label:"EC PRIVATE KEY"}
    };

    if (rawPublicKey) {
        privateKeyObject.publicKey = {
            unused: 0,
            data: new Buffer(rawPublicKey, 'hex')
        }
    }

    return privateKeyObject
};

KeyEncoder.prototype.publicKeyObject = function(rawPublicKey) {
    return {
        algorithm: {
            id: this.algorithmID,
            curve: this.options.curveParameters
        },
        pub: {
            unused: 0,
            data: new Buffer(rawPublicKey, 'hex')
        },
        pemOptions: { label :"PUBLIC KEY"}
    }
}

KeyEncoder.prototype.encodePrivate = function(privateKey, originalFormat, destinationFormat) {
    var privateKeyObject

    /* Parse the incoming private key and convert it to a private key object */
    if (originalFormat === 'raw') {
        if (!typeof privateKey === 'string') {
            throw 'private key must be a string'
        }
        var privateKeyObject = this.options.curve.keyFromPrivate(privateKey, 'hex'),
            rawPublicKey = privateKeyObject.getPublic('hex')
        privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey)
    } else if (originalFormat === 'der') {
        if (typeof privateKey === 'buffer') {
            // do nothing
        } else if (typeof privateKey === 'string') {
            privateKey = new Buffer(privateKey, 'hex')
        } else {
            throw 'private key must be a buffer or a string'
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der')
    } else if (originalFormat === 'pem') {
        if (!typeof privateKey === 'string') {
            throw 'private key must be a string'
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions)
    } else {
        throw 'invalid private key format'
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return privateKeyObject.privateKey.toString('hex')
    } else if (destinationFormat === 'der') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex')
    } else if (destinationFormat === 'pem') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions)
    } else {
        throw 'invalid destination format for private key'
    }
}

KeyEncoder.prototype.encodePublic = function(publicKey, originalFormat, destinationFormat) {
    var publicKeyObject

    /* Parse the incoming public key and convert it to a public key object */
    if (originalFormat === 'raw') {
        if (!typeof publicKey === 'string') {
            throw 'public key must be a string'
        }
        publicKeyObject = this.publicKeyObject(publicKey)
    } else if (originalFormat === 'der') {
        if (typeof publicKey === 'buffer') {
            // do nothing
        } else if (typeof publicKey === 'string') {
            publicKey = new Buffer(publicKey, 'hex')
        } else {
            throw 'public key must be a buffer or a string'
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der')
    } else if (originalFormat === 'pem') {
        if (!typeof publicKey === 'string') {
            throw 'public key must be a string'
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions)
    } else {
        throw 'invalid public key format'
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return publicKeyObject.pub.data.toString('hex')
    } else if (destinationFormat === 'der') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex')
    } else if (destinationFormat === 'pem') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions)
    } else {
        throw 'invalid destination format for public key'
    }
}

module.exports = KeyEncoder;
}).call(this,require("buffer").Buffer)

},{"./asn1/asn1":"/opt/privatesky/modules/pskcrypto/lib/asn1/asn1.js","./asn1/bignum/bn":"/opt/privatesky/modules/pskcrypto/lib/asn1/bignum/bn.js","buffer":"buffer"}],"/opt/privatesky/modules/pskcrypto/lib/psk-archiver.js":[function(require,module,exports){
(function (Buffer){
const path = require("path");
const yazl = require("yazl");
const yauzl = require("yauzl");
const fs = require("fs");
const DuplexStream = require("./utils/DuplexStream");
const PassThroughStream = require("./utils/PassThroughStream");
const isStream = require("./utils/isStream");

const EventEmitter = require('events');

const countFiles = require('./utils/countFiles');

function PskArchiver() {

    const self = this;

    const event = new EventEmitter();

    this.on = event.on;
    this.off = event.off;
    this.emit = event.emit;

    this.zipStream = function (inputPath, output, callback) {
        let ext = "";
        const zipFile = new yazl.ZipFile();
        const ptStream = new PassThroughStream();

        countFiles.computeSize(inputPath, (err, totalSize) => {
            if (err) {
                return callback(err);
            }

            __addToArchiveRecursively(zipFile, inputPath, "", (err) => {
                if (err) {
                    return callback(err);
                }

                zipFile.end();
                const filename = path.basename(inputPath);
                const splitFilename = filename.split(".");
                if (splitFilename.length >= 2) {
                    ext = "." + splitFilename[splitFilename.length - 1];
                }
                const myStream = zipFile.outputStream.pipe(ptStream);

                let progressLength = 0;
                let totalLength = 0;

                /**
                 * TODO review this
                 * In browser, piping will block the event loop and the stack queue is not called.
                 */
                myStream.on("data", (chunk) => {
                    progressLength += chunk.length;
                    totalLength += chunk.length;

                    if (progressLength > 300000) {
                        myStream.pause();
                        progressLength = 0;
                        setTimeout(function () {
                            myStream.resume();
                        }, 10);
                        emitProgress(totalSize, totalLength)
                    }
                });

                myStream.on('end', () => {
                    emitProgress(totalSize, totalSize);
                    emitTotalSize(totalSize);
                });
                if (isStream.isWritable(output)) {
                    callback(null, myStream.pipe(output));
                } else if (typeof output === "string") {
                   fs.mkdir(output, {recursive: true}, () => {
                        const destinationPath = path.join(output, path.basename(inputPath, ext) + ".zip");
                        myStream.pipe(fs.createWriteStream(destinationPath));
                    });
                }
            });

            function __addToArchiveRecursively(zipFile, inputPath, root = '', callback) {
                root = root || '';
                fs.stat(inputPath, (err, stats) => {
                    if (err) {
                        return callback(err);
                    }
                    if (stats.isFile()) {
                        zipFile.addFile(inputPath, path.join(root, path.basename(inputPath)));
                        callback(null);

                    } else {
                        fs.readdir(inputPath, (err, files) => {
                            if (err) {
                                return callback(err);
                            }
                            const f_length = files.length;
                            let f_add_index = 0;

                            const checkStatus = () => {
                                if (f_length === f_add_index) {
                                    callback(null);
                                    return true;
                                }
                                return false;
                            };

                            if (!checkStatus()) {
                                files.forEach(file => {
                                    const tempPath = path.join(inputPath, file);
                                    __addToArchiveRecursively(zipFile, tempPath, path.join(root, path.basename(inputPath)), (err) => {
                                        if (err) {
                                            return callback(err);
                                        }
                                        f_add_index++;
                                        checkStatus();
                                    })
                                });
                            }
                        })
                    }
                });
            }

        });

    };

    this.unzipStream = function (input, outputPath, callback) {

        let size = 0;

        fs.stat(input, (err, stats) => {
            if (err) {
                return callback(err);
            }

            let totalSize = stats.size;


            yauzl.open(input, {lazyEntries: true}, (err, zipFile) => {
                if (err) {
                    return callback(err);
                }

                let progressLength = 0;
                let totalLength = 0;

                const fileNames = [];
                zipFile.readEntry();
                zipFile.once("end", () => {
                    emitProgress(totalSize, totalSize);
                    callback(null, fileNames);
                });
                zipFile.on("entry", (entry) => {
                    if (entry.fileName.endsWith(path.sep)) {
                        zipFile.readEntry();
                    } else {
                        let folder = path.dirname(entry.fileName);
                        fs.mkdir(path.join(outputPath, folder), {recursive: true}, () => {
                            zipFile.openReadStream(entry, (err, readStream) => {
                                if (err) {
                                    return callback(err);
                                }

                                /**
                                 * TODO review this
                                 * In browser, piping will block the event loop and the stack queue is not called.
                                 */

                                readStream.on("data", (chunk) => {
                                    progressLength += chunk.length;
                                    totalLength += chunk.length;

                                    if (progressLength > 300000) {
                                        readStream.pause();
                                        progressLength = 0;
                                        setTimeout(function () {
                                            readStream.resume();
                                        }, 30);
                                        emitProgress(totalSize, totalLength)
                                    }
                                });


                                readStream.on("end", () => {
                                    zipFile.readEntry();
                                });
                                const ptStream = new PassThroughStream();
                                let fileName = path.join(outputPath, entry.fileName);
                                let folder = path.dirname(fileName);
                                const tempStream = readStream.pipe(ptStream);

                                fs.mkdir(folder, {recursive: true}, (err) => {
                                    if (err) {
                                        return callback(err);
                                    }

                                    size += ptStream.getSize();
                                    let output = fs.createWriteStream(fileName);
                                    fileNames.push(fileName);
                                    tempStream.pipe(output);
                                });
                            });
                        });
                    }
                });
            });

        });

    };

    this.zipInMemory = function (inputObj, depth, callback) {
        const zipFile = new yazl.ZipFile();
        const ds = new DuplexStream();
        zipRecursively(zipFile, inputObj, "", depth, (err) => {
            if (err) {
                return callback(err);
            }
            zipFile.end();
            let buffer = Buffer.alloc(0);
            ds.on('data', (chunk) => {
                buffer = Buffer.concat([buffer, chunk]);
            });

            zipFile.outputStream.pipe(ds).on("finish", (err) => {
                if (err) {
                    return callback(err);
                }
                callback(null, buffer);
            });
        })
    };

    this.unzipInMemory = function (inputZip, callback) {

        function unzipInput(zipFile) {
            zipFile.readEntry();
            const obj = {};
            zipFile.once("end", () => {
                callback(null, obj);
            });

            zipFile.on("entry", (entry) => {
                zipFile.openReadStream(entry, (err, readStream) => {
                    const ds = new DuplexStream();
                    let str = '';
                    if (err) {
                        return callback(err);
                    }
                    readStream.on("end", () => {
                        zipFile.readEntry();
                    });
                    ds.on("data", (chunk) => {
                        str += chunk.toString();
                    });

                    readStream.pipe(ds).on("finish", (err) => {
                        if (err) {
                            return callback(err);
                        }
                        const splitEntry = entry.fileName.split("/");
                        const type = splitEntry.pop();
                        addPropsRecursively(obj, splitEntry, type, new Buffer(str));
                    });

                });
            })
        }

        if (Buffer.isBuffer(inputZip)) {
            yauzl.fromBuffer(inputZip, {lazyEntries: true}, (err, zipFile) => {
                if (err) {
                    return callback(err);
                }
                unzipInput(zipFile)
            });
        } else {
            return callback(new Error("input should be a buffer"));
        }

    };

    function zipRecursively(zipFile, obj, root, depth, callback) {
        if (depth === 0) {
            zipFile.addBuffer(new Buffer(JSON.stringify(obj)), root + "/stringify");
            return;
        }

        if (typeof obj === 'undefined') {
            zipFile.addBuffer(Buffer.alloc(0), root + "/undefined");
        } else if (typeof obj === 'number') {
            zipFile.addBuffer(new Buffer(obj.toString()), root + "/number");
        } else if (typeof obj === 'string') {
            zipFile.addBuffer(new Buffer(obj), root + "/string")
        } else if (obj === null) {
            zipFile.addBuffer(Buffer.alloc(0), root + "/null");
        } else if (Buffer.isBuffer(obj)) {
            zipFile.addBuffer(obj, root + "/buffer");
        } else if (isStream.isReadable(obj)) {
            zipFile.addReadStream(obj, root + "/stream");
        } else if (Array.isArray(obj)) {
            for (let i = 0; i < obj.length; i++) {
                if (obj.length === 0) {
                    zipFile.addBuffer(Buffer.alloc(0), root + "/array")
                } else {
                    zipRecursively(zipFile, obj[i], root + "/array/" + i, depth, (err) => {
                        if (err) {
                            return callback(err);
                        }
                    });
                }
            }
        } else if (obj && typeof obj === 'object') {
            let keys = Object.keys(obj);
            if (keys.length === 0 && obj.constructor === Object) {
                zipFile.addBuffer(Buffer.alloc(0), root + "/object");
            } else {
                const encodedObj = {};
                Object.entries(obj).forEach(([key, value]) => {
                    encodedObj[encodeURIComponent(key)] = value;
                });
                obj = encodedObj;
                keys = Object.keys(obj);
                keys.forEach(key => {
                    let entryName;
                    if (root === "") {
                        entryName = key;
                    } else {
                        entryName = root + "/" + key;
                    }
                    zipRecursively(zipFile, obj[key], entryName, depth - 1, (err) => {
                        if (err) {
                            return callback(err);
                        }
                    });
                });
            }
        } else {
            throw new Error('Should never reach this');
        }
        callback(null);
    }

    function addPropsRecursively(obj, splitName, type, data) {
        if (splitName.length >= 1) {
            const prop = decodeURIComponent(splitName.shift());

            if (splitName.length === 0) {
                switch (type) {
                    case 'undefined':
                        obj[prop] = undefined;
                        break;
                    case 'null':
                        obj[prop] = null;
                        break;
                    case 'number':
                        obj[prop] = parseInt(data.toString());
                        break;
                    case 'string':
                        obj[prop] = data.toString();
                        break;
                    case 'stream':
                        obj[prop] = bufferToStream(data);
                        break;
                    case 'array':
                        obj[prop] = [];
                        break;
                    case 'object':
                        obj[prop] = {};
                        break;
                    case 'stringify':
                        obj[prop] = JSON.parse(data.toString());
                        break;
                    default:
                        throw new Error('Should never reach this');
                }
            } else {
                if (splitName[0] === 'array') {
                    if (!obj.hasOwnProperty(prop)) {
                        obj[prop] = [];
                    }
                    splitName.shift();
                    addPropsRecursively(obj[prop], splitName, type, data);
                } else {
                    if (!obj.hasOwnProperty(prop)) {
                        obj[prop] = {};
                    }
                    addPropsRecursively(obj[prop], splitName, type, data);
                }
            }
        }
    }


    function bufferToStream(buffer) {
        let stream = new require('stream').Readable();
        stream.push(buffer);
        stream.push(null);
        return stream;
    }

    function emitProgress(total, processed) {


        if (processed > total) {
            processed = total;
        }

        const progress = (100 * processed) / total;
        self.emit('progress', progress);
    }

    function emitTotalSize(total) {
        self.emit('total', total);
    }


}

module.exports = PskArchiver;
}).call(this,require("buffer").Buffer)

},{"./utils/DuplexStream":"/opt/privatesky/modules/pskcrypto/lib/utils/DuplexStream.js","./utils/PassThroughStream":"/opt/privatesky/modules/pskcrypto/lib/utils/PassThroughStream.js","./utils/countFiles":"/opt/privatesky/modules/pskcrypto/lib/utils/countFiles.js","./utils/isStream":"/opt/privatesky/modules/pskcrypto/lib/utils/isStream.js","buffer":"buffer","events":"events","fs":false,"path":"path","yauzl":false,"yazl":false}],"/opt/privatesky/modules/pskcrypto/lib/utils/DuplexStream.js":[function(require,module,exports){
const stream = require('stream');
const util = require('util');

const Duplex = stream.Duplex;

function DuplexStream(options) {
	if (!(this instanceof DuplexStream)) {
		return new DuplexStream(options);
	}
	Duplex.call(this, options);
}
util.inherits(DuplexStream, Duplex);

DuplexStream.prototype._write = function (chunk, enc, cb) {
	this.push(chunk);
	cb();
};


DuplexStream.prototype._read = function (n) {

};

module.exports = DuplexStream;
},{"stream":"stream","util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/utils/PassThroughStream.js":[function(require,module,exports){
const stream = require('stream');
const util = require('util');

const PassThrough = stream.PassThrough;

function PassThroughStream(options) {
    if (!(this instanceof PassThroughStream)) {
        return new PassThroughStream(options);
    }
    PassThrough.call(this, options);

    let size = 0;

    this.addToSize = function (amount) {
        size += amount;
    };

    this.getSize = function () {
        return size;
    }
}

util.inherits(PassThroughStream, PassThrough);

PassThroughStream.prototype._write = function (chunk, enc, cb) {
    this.addToSize(chunk.length);
    this.push(chunk);
    cb();
};


PassThroughStream.prototype._read = function (n) {

};

module.exports = PassThroughStream;
},{"stream":"stream","util":"util"}],"/opt/privatesky/modules/pskcrypto/lib/utils/countFiles.js":[function(require,module,exports){
const fs = require('fs');
const path = require('path');
const yauzl = require('yauzl');

function countFiles(inputPath, callback) {
    let total = 0;

    fs.stat(inputPath, (err, stats) => {
        if (err) {
            return callback(err);
        }

        if (stats.isFile()) {
            return callback(undefined, 1);
        }

        fs.readdir(inputPath, (err, files) => {
            if (err) {
                return callback(err);
            }


            total = files.length;
            let count = files.length;

            if (total === 0) {
                return callback(undefined, 0);
            }

            files.forEach(file => {
                fs.stat(path.join(inputPath, file), (err, stats) => {
                    if (err) {
                        return callback(err);
                    }

                    if (stats.isDirectory()) {
                        --total;
                        countFiles(path.join(inputPath, file), (err, filesNumber) => {
                            if (err) {
                                return callback(err);
                            }

                            total += filesNumber;


                            if (--count === 0) {
                                callback(undefined, total);
                            }
                        });
                    } else {
                        if (!stats.isFile()) {
                            --total;
                        }

                        if (--count === 0) {
                            callback(undefined, total);
                        }
                    }
                });
            })
        });
    });
}

function countZipEntries(inputPath, callback) {
    let processed = 0;

    yauzl.open(inputPath, {lazyEntries: true}, (err, zipFile) => {
        if (err) {
            return callback(err);
        }

        zipFile.readEntry();
        zipFile.once("end", () => {
            callback(null, processed);
        });

        zipFile.on("entry", (entry) => {
            ++processed;

            zipFile.readEntry();
        });
    });
}

function computeSize(inputPath, callback) {
    let totalSize = 0;
    fs.stat(inputPath, (err, stats) => {
        if (err) {
            return callback(err);
        }

        if (stats.isFile()) {
            return callback(undefined, stats.size);
        }

        fs.readdir(inputPath, (err, files) => {
            if (err) {
                return callback(err);
            }


            let count = files.length;

            if (count === 0) {
                return callback(undefined, 0);
            }

            files.forEach(file => {
                fs.stat(path.join(inputPath, file), (err, stats) => {
                    if (err) {
                        return callback(err);
                    }

                    if (stats.isDirectory()) {
                        computeSize(path.join(inputPath, file), (err, filesSize) => {
                            if (err) {
                                return callback(err);
                            }

                            totalSize += filesSize;

                            if (--count === 0) {
                                callback(undefined, totalSize);
                            }
                        });
                    } else {

                        totalSize += stats.size;

                        if (--count === 0) {
                            callback(undefined, totalSize);
                        }
                    }
                });
            })
        });
    });
}

module.exports = {
    countFiles,
    countZipEntries,
    computeSize
};

},{"fs":false,"path":"path","yauzl":false}],"/opt/privatesky/modules/pskcrypto/lib/utils/cryptoUtils.js":[function(require,module,exports){
(function (Buffer){
const crypto = require('crypto');
const fs = require('fs');
const path = require("path");

const algorithm = 'aes-256-gcm';


const iterations_number = 1000;

function encode(buffer) {
	return buffer.toString('base64')
		.replace(/\+/g, '')
		.replace(/\//g, '')
		.replace(/=+$/, '');
}

function deleteRecursively(inputPath, callback) {

	fs.stat(inputPath, function (err, stats) {
		if (err) {
			callback(err, stats);
			return;
		}
		if (stats.isFile()) {
			fs.unlink(inputPath, function (err) {
				if (err) {
					callback(err, null);
				} else {
					callback(null, true);
				}
			});
		} else if (stats.isDirectory()) {
			fs.readdir(inputPath, function (err, files) {
				if (err) {
					callback(err, null);
					return;
				}
				const f_length = files.length;
				let f_delete_index = 0;

				const checkStatus = function () {
					if (f_length === f_delete_index) {
						fs.rmdir(inputPath, function (err) {
							if (err) {
								callback(err, null);
							} else {
								callback(null, true);
							}
						});
						return true;
					}
					return false;
				};
				if (!checkStatus()) {
					files.forEach(function (file) {
						const tempPath = path.join(inputPath, file);
						deleteRecursively(tempPath, function removeRecursiveCB(err, status) {
							if (!err) {
								f_delete_index++;
								checkStatus();
							} else {
								callback(err, null);
							}
						});
					});
				}
			});
		}
	});
}





function createPskHash(data) {
	const pskHash = new PskHash();
	pskHash.update(data);
	return pskHash.digest();
}

function PskHash() {
	const sha512 = crypto.createHash('sha512');
	const sha256 = crypto.createHash('sha256');

	function update(data) {
		sha512.update(data);
	}

	function digest() {
		sha256.update(sha512.digest());
		return sha256.digest();
	}

	return {
		update,
		digest
	}
}


function generateSalt(inputData, saltLen) {
	const hash = crypto.createHash('sha512');
	hash.update(inputData);
	const digest = Buffer.from(hash.digest('hex'), 'binary');

	return digest.slice(0, saltLen);
}

function encrypt(data, password) {
	const keySalt = crypto.randomBytes(32);
	const key = crypto.pbkdf2Sync(password, keySalt, iterations_number, 32, 'sha512');

	const aadSalt = crypto.randomBytes(32);
	const aad = crypto.pbkdf2Sync(password, aadSalt, iterations_number, 32, 'sha512');

	const salt = Buffer.concat([keySalt, aadSalt]);
	const iv = crypto.pbkdf2Sync(password, salt, iterations_number, 12, 'sha512');

	const cipher = crypto.createCipheriv(algorithm, key, iv);
	cipher.setAAD(aad);
	let encryptedText = cipher.update(data, 'binary');
	const final = Buffer.from(cipher.final('binary'), 'binary');
	const tag = cipher.getAuthTag();

	encryptedText = Buffer.concat([encryptedText, final]);

	return Buffer.concat([salt, encryptedText, tag]);
}

function decrypt(encryptedData, password) {
	const salt = encryptedData.slice(0, 64);
	const keySalt = salt.slice(0, 32);
	const aadSalt = salt.slice(-32);

	const iv = crypto.pbkdf2Sync(password, salt, iterations_number, 12, 'sha512');
	const key = crypto.pbkdf2Sync(password, keySalt, iterations_number, 32, 'sha512');
	const aad = crypto.pbkdf2Sync(password, aadSalt, iterations_number, 32, 'sha512');

	const ciphertext = encryptedData.slice(64, encryptedData.length - 16);
	const tag = encryptedData.slice(-16);

	const decipher = crypto.createDecipheriv(algorithm, key, iv);
	decipher.setAuthTag(tag);
	decipher.setAAD(aad);

	let plaintext = Buffer.from(decipher.update(ciphertext, 'binary'), 'binary');
	const final = Buffer.from(decipher.final('binary'), 'binary');
	plaintext = Buffer.concat([plaintext, final]);
	return plaintext;
}

function encryptObjectInMemory(inputObj, password, depth, callback) {
	const PskArchiver = require("../psk-archiver");
	const archiver = new PskArchiver();

	archiver.zipInMemory(inputObj, depth, function (err, zippedObj) {
		if (err) {
			return callback(err);
		}
		const cipherText = encrypt(zippedObj, password);
		callback(null, cipherText);
	})
}

function decryptObjectInMemory(encryptedObject, password, callback) {
	const archiver = new PskArchiver();

	const zippedObject = decrypt(encryptedObject, password);
	archiver.unzipInMemory(zippedObject, function (err, obj) {
		if (err) {
			return callback(err);
		}
		callback(null, obj);
	})
}


module.exports = {
	createPskHash,
	encrypt,
	encryptObjectInMemory,
	decrypt,
	decryptObjectInMemory,
	deleteRecursively,
	encode,
	generateSalt,
	iterations_number,
	algorithm,
	PskHash
};


}).call(this,require("buffer").Buffer)

},{"../psk-archiver":"/opt/privatesky/modules/pskcrypto/lib/psk-archiver.js","buffer":"buffer","crypto":"crypto","fs":false,"path":"path"}],"/opt/privatesky/modules/pskcrypto/lib/utils/isStream.js":[function(require,module,exports){
const stream = require('stream');


function isStream (obj) {
	return obj instanceof stream.Stream || obj instanceof stream.Duplex;
}


function isReadable (obj) {
	return isStream(obj) && typeof obj._read === 'function' && typeof obj._readableState === 'object'
}


function isWritable (obj) {
	return isStream(obj) && typeof obj._write === 'function' && typeof obj._writableState === 'object'
}


function isDuplex (obj) {
	return isReadable(obj) && isWritable(obj)
}


module.exports            = isStream;
module.exports.isReadable = isReadable;
module.exports.isWritable = isWritable;
module.exports.isDuplex   = isDuplex;
},{"stream":"stream"}],"/opt/privatesky/modules/pskcrypto/signsensusDS/ssutil.js":[function(require,module,exports){
/*
 SignSens helper functions
 */
const crypto = require('crypto');

exports.wipeOutsidePayload = function wipeOutsidePayload(hashStringHexa, pos, size){
    var result;
    var sz = hashStringHexa.length;

    var end = (pos + size) % sz;

    if(pos < end){
        result = '0'.repeat(pos) +  hashStringHexa.substring(pos, end) + '0'.repeat(sz - end);
    }
    else {
        result = hashStringHexa.substring(0, end) + '0'.repeat(pos - end) + hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.extractPayload = function extractPayload(hashStringHexa, pos, size){
    var result;

    var sz = hashStringHexa.length;
    var end = (pos + size) % sz;

    if( pos < end){
        result = hashStringHexa.substring(pos, pos + size);
    } else{

        if(0 != end){
            result = hashStringHexa.substring(0, end)
        }  else {
            result = "";
        }
        result += hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.fillPayload = function fillPayload(payload, pos, size){
    var sz = 64;
    var result = "";

    var end = (pos + size) % sz;

    if( pos < end){
        result = '0'.repeat(pos) + payload + '0'.repeat(sz - end);
    } else{
        result = payload.substring(0,end);
        result += '0'.repeat(pos - end);
        result += payload.substring(end);
    }
    return result;
}



exports.generatePosHashXTimes = function generatePosHashXTimes(buffer, pos, size, count){ //generate positional hash
    var result  = buffer.toString("hex");

    /*if(pos != -1 )
        result[pos] = 0; */

    for(var i = 0; i < count; i++){
        var hash = crypto.createHash('sha256');
        result = exports.wipeOutsidePayload(result, pos, size);
        hash.update(result);
        result = hash.digest('hex');
    }
    return exports.wipeOutsidePayload(result, pos, size);
}

exports.hashStringArray = function (counter, arr, payloadSize){

    const hash = crypto.createHash('sha256');
    var result = counter.toString(16);

    for(var i = 0 ; i < 64; i++){
        result += exports.extractPayload(arr[i],i, payloadSize);
    }

    hash.update(result);
    var result = hash.digest('hex');
    return result;
}






function dumpMember(obj){
    var type = Array.isArray(obj) ? "array" : typeof obj;
    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    switch(type){
        case "number":
        case "string":return obj.toString(); break;
        case "object": return exports.dumpObjectForHashing(obj); break;
        case "boolean": return  obj? "true": "false"; break;
        case "array":
            var result = "";
            for(var i=0; i < obj.length; i++){
                result += exports.dumpObjectForHashing(obj[i]);
            }
            return result;
            break;
        default:
            throw new Error("Type " +  type + " cannot be cryptographically digested");
    }

}


exports.dumpObjectForHashing = function(obj){
    var result = "";

    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    var basicTypes = {
        "array"     : true,
        "number"    : true,
        "boolean"   : true,
        "string"    : true,
        "object"    : false
    }

    var type = Array.isArray(obj) ? "array" : typeof obj;
    if( basicTypes[type]){
        return dumpMember(obj);
    }

    var keys = Object.keys(obj);
    keys.sort();


    for(var i=0; i < keys.length; i++){
        result += dumpMember(keys[i]);
        result += dumpMember(obj[keys[i]]);
    }

    return result;
}


exports.hashValues  = function (values){
    const hash = crypto.createHash('sha256');
    var result = exports.dumpObjectForHashing(values);
    hash.update(result);
    return hash.digest('hex');
};

exports.getJSONFromSignature = function getJSONFromSignature(signature, size){
    var result = {
        proof:[]
    };
    var a = signature.split(":");
    result.agent        = a[0];
    result.counter      =  parseInt(a[1], "hex");
    result.nextPublic   =  a[2];

    var proof = a[3]


    if(proof.length/size != 64) {
        throw new Error("Invalid signature " + proof);
    }

    for(var i = 0; i < 64; i++){
        result.proof.push(exports.fillPayload(proof.substring(i * size,(i+1) * size ), i, size))
    }

    return result;
}

exports.createSignature = function (agent,counter, nextPublic, arr, size){
    var result = "";

    for(var i = 0; i < arr.length; i++){
        result += exports.extractPayload(arr[i], i , size);
    }

    return agent + ":" + counter + ":" + nextPublic + ":" + result;
}
},{"crypto":"crypto"}],"/opt/privatesky/modules/psklogger/src/LoggerClient/GenericLoggerClient.js":[function(require,module,exports){
const LogFactory = require('./LogFactory');

/**
 *
 * @param {TransportInterface} messagePublisher
 * @constructor
 */
function GenericLoggerClient(messagePublisher) {
    /**
     * This is to be used to send normal logs. They will be published in a subchannel of the "logs" channel.
     * It is easier to trace only user and platform logs if they are separated in this channel
     *
     * @param {{code: Number, name: string}} logLevel
     * @param {Object} meta
     * @param {Array<any>} messages
     *
     * @return {{level, meta, time, msTime, messages}}
     */
    function log(logLevel, meta, messages) {
        const log = LogFactory.createLog(logLevel, meta, messages);

        const logChannel = `logs.${logLevel.name}`;
        messagePublisher.send(logChannel, log);

        return log;
    }


    /**
     * This is to be used for sending custom events when messages don't happen in the normal flow of the platform
     * or they shouldn't interfere with the tracing of logs
     * For example, sending statistics about a node or a sandbox is happening periodically and not as a result of
     * users' running code, therefore this should not be merged with logs
     *
     * @param {string} channel
     * @param {Object} meta
     * @param {Array<any>} messages
     * @return {{meta, messages, time}}
     */
    function event(channel, meta, messages) {
        const event = LogFactory.createEvent(meta, messages);

        const logChannel = `events.${channel}`;
        messagePublisher.send(logChannel, event);

        return event;
    }

    function publish(channel, message) {
        messagePublisher.send(channel, message);

        return message;
    }

    this.event  = event;
    this.log    = log;
    this.publish = publish;
}

module.exports = GenericLoggerClient;

},{"./LogFactory":"/opt/privatesky/modules/psklogger/src/LoggerClient/LogFactory.js"}],"/opt/privatesky/modules/psklogger/src/LoggerClient/LogFactory.js":[function(require,module,exports){
function getTime() {
    if(process.env.context === 'sandbox') {

        return Date.now()
    } else {
        const {performance} = require('perf_hooks');

        return performance.now() + performance.timeOrigin;
    }
}


function createLog(logLevel, meta, messages) {
    return {
        level: logLevel,
        messages: messages,
        meta: meta,
        time: getTime()
    }
}

function createEvent(meta, messages) {
    return {
        messages,
        meta,
        time: getTime()
    };
}

module.exports = {
    createLog,
    createEvent
};

},{"perf_hooks":false}],"/opt/privatesky/modules/psklogger/src/LoggerClient/LoggerClient.js":[function(require,module,exports){
const GenericLoggerClient = require('./GenericLoggerClient');
const LogLevel = require('../utils/LogLevel');
const LoggerInterface = require('./LoggerInterface');

/**
 *
 * @param {TransportInterface} messagePublisher
 * @implements LoggerInterface
 * @constructor
 */
function LoggerClient(messagePublisher) {
    LoggerInterface.call(this);

    const genericLoggerClient = new GenericLoggerClient(messagePublisher);


    /************* PUBLIC METHODS *************/

    function debug(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.debug);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function error(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.error);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function info(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.info);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function log(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.log);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function warn(meta = {}, ...params) {
        const logLevel = _getLogLevel(LogLevel.warn);

        return genericLoggerClient.log(logLevel, meta, params);
    }

    function event(channel, meta = {}, ...params) {
        return genericLoggerClient.event(channel, meta, ...params);
    }
    
    function redirect(channel, logObject) {
        return genericLoggerClient.publish(channel, logObject)
    }


    /************* PRIVATE METHODS *************/

    function _getLogLevel(levelCode) {
        return {
            code: levelCode,
            name: LogLevel[levelCode]
        };
    }


    /************* EXPORTS *************/

    this.debug    = debug;
    this.error    = error;
    this.event    = event;
    this.info     = info;
    this.log      = log;
    this.redirect = redirect;
    this.warn     = warn;
}

module.exports = LoggerClient;

},{"../utils/LogLevel":"/opt/privatesky/modules/psklogger/src/utils/LogLevel.js","./GenericLoggerClient":"/opt/privatesky/modules/psklogger/src/LoggerClient/GenericLoggerClient.js","./LoggerInterface":"/opt/privatesky/modules/psklogger/src/LoggerClient/LoggerInterface.js"}],"/opt/privatesky/modules/psklogger/src/LoggerClient/LoggerInterface.js":[function(require,module,exports){
/**
 * @interface
 */
function LoggerInterface() {
    function genericMethod(channel, logObject) {
        throw new Error('Not implemented');
    }

    this.debug    = genericMethod;
    this.error    = genericMethod;
    this.event    = genericMethod;
    this.info     = genericMethod;
    this.log      = genericMethod;
    this.redirect = genericMethod;
    this.warn     = genericMethod;
}

module.exports = LoggerInterface;

},{}],"/opt/privatesky/modules/psklogger/src/LoggerClient/index.js":[function(require,module,exports){
const GenericLoggerClient = require('./GenericLoggerClient');
const LogFactory          = require('./LogFactory');
const LoggerClient        = require('./LoggerClient');
const LoggerInterface     = require('./LoggerInterface');


module.exports = {
    GenericLoggerClient,
    LogFactory,
    LoggerClient,
    LoggerInterface
};

},{"./GenericLoggerClient":"/opt/privatesky/modules/psklogger/src/LoggerClient/GenericLoggerClient.js","./LogFactory":"/opt/privatesky/modules/psklogger/src/LoggerClient/LogFactory.js","./LoggerClient":"/opt/privatesky/modules/psklogger/src/LoggerClient/LoggerClient.js","./LoggerInterface":"/opt/privatesky/modules/psklogger/src/LoggerClient/LoggerInterface.js"}],"/opt/privatesky/modules/psklogger/src/MessagePublisher/MessagePublisher.js":[function(require,module,exports){
const TransportInterface = require('./TransportInterface');
const utils = require('../utils');
const zeroMQ = require('zeromq');


/**
 * Creates a ZeroMQ Publisher Socket and connects to the specified address for a ZeroMQ Subscriber
 * @param {string!} address - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @implements TransportInterface
 * @constructor
 */
function MessagePublisher(address) {
    TransportInterface.call(this);

    const zmqSocket = zeroMQ.createSocket('pub');

    // uncomment next line if messages are lost
    // zmqSocket.setsockopt(zeroMQ.ZMQ_SNDHWM, 0);
    const socket = new utils.BufferedSocket(zmqSocket, utils.SocketType.connectable);


    /************* PUBLIC METHODS *************/

    /**
     *
     * @param {string} channel
     * @param {Object} logObject
     */
    this.send = function (channel, logObject) {
        try {
            const serializedLog = JSON.stringify(logObject);

            socket.send([channel, serializedLog]);
        } catch (e) {
            process.stderr.write('Error while sending or serializing message');
        }
    };


    /************* MONITOR SOCKET *************/

    zmqSocket.connect(address);
}

module.exports = MessagePublisher;

},{"../utils":"/opt/privatesky/modules/psklogger/src/utils/index.js","./TransportInterface":"/opt/privatesky/modules/psklogger/src/MessagePublisher/TransportInterface.js","zeromq":false}],"/opt/privatesky/modules/psklogger/src/MessagePublisher/MessagePublisherForSandbox.js":[function(require,module,exports){
(function (global){
const TransportInterface = require('./TransportInterface');

/**
 * This assumes it is executed inside a sandbox and that exists an object "logger" on "global" with a method "send".
 * Sandboxes can't connect directly to ZeroMQ therefore this just relays the message outside the sandbox.
 *
 * @implements TransportInterface
 * @constructor
 */
function MessagePublisherForSandbox() {

    TransportInterface.call(this);

    /************* PUBLIC METHODS *************/

    /**
     *
     * @param {string} channel
     * @param {Object} logObject
     */
    this.send = function (channel, logObject) {
        try {
            global.logger.send([channel, logObject]);
        } catch (e) {
            console.error('Error while sending or serializing message');
        }
    };

}

module.exports = MessagePublisherForSandbox;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./TransportInterface":"/opt/privatesky/modules/psklogger/src/MessagePublisher/TransportInterface.js"}],"/opt/privatesky/modules/psklogger/src/MessagePublisher/TransportInterface.js":[function(require,module,exports){
/**
 *
 * @interface
 */
function TransportInterface() {
    this.send = function (channel, logObject) {
        throw new Error('Not implemented');
    }
}

module.exports = TransportInterface;

},{}],"/opt/privatesky/modules/psklogger/src/MessagePublisher/index.js":[function(require,module,exports){
const TransportInterface = require('./TransportInterface');

module.exports = {
    TransportInterface
};

if(process.env.context === 'sandbox') {
    module.exports.MessagePublisher = require('./MessagePublisherForSandbox');
} else {
    module.exports.MessagePublisher = require('./MessagePublisher');
}

},{"./MessagePublisher":"/opt/privatesky/modules/psklogger/src/MessagePublisher/MessagePublisher.js","./MessagePublisherForSandbox":"/opt/privatesky/modules/psklogger/src/MessagePublisher/MessagePublisherForSandbox.js","./TransportInterface":"/opt/privatesky/modules/psklogger/src/MessagePublisher/TransportInterface.js"}],"/opt/privatesky/modules/psklogger/src/MessageSubscriber/MessageSubscriber.js":[function(require,module,exports){
const zeroMQ = require('zeromq');

/**
 * Creates a ZeroMQ Subscriber that listens for provided topics on the specified address for a publisher
 * @param {string!} address - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @param {Array<string>|function?} subscriptions - a list of subscription topics, if missing it will subscribe to everything
 * @param {function!} onMessageCallback
 * @constructor
 */
function MessageSubscriber(address, subscriptions, onMessageCallback) {
    const zmqSocket = zeroMQ.createSocket('sub');

    // uncomment next line if messages are lost
    // zmqSocket.setsockopt(zeroMQ.ZMQ_RCVHWM, 0);

    if(arguments.length === 2 && typeof subscriptions === 'function') {
        onMessageCallback = subscriptions;
        subscriptions = [''];
    }

    subscriptions.forEach(subscription => zmqSocket.subscribe(subscription));

    zmqSocket.connect(address);

    zmqSocket.on('message', onMessageCallback);

    const events = ["SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];

    events.forEach(event => {
        process.on(event, () => {
            zmqSocket.close();
        });
    });
}

module.exports = MessageSubscriber;

},{"zeromq":false}],"/opt/privatesky/modules/psklogger/src/MessageSubscriber/index.js":[function(require,module,exports){
const MessageSubscriber = require('./MessageSubscriber');

module.exports = {MessageSubscriber};

},{"./MessageSubscriber":"/opt/privatesky/modules/psklogger/src/MessageSubscriber/MessageSubscriber.js"}],"/opt/privatesky/modules/psklogger/src/PSKLoggerClient/GenericPSKLogger.js":[function(require,module,exports){
(function (global){
const LoggerClientModule = require('../LoggerClient');

const LoggerClient = LoggerClientModule.LoggerClient;
const LoggerInterface = LoggerClientModule.LoggerInterface;


/**
 *
 * @param messagePublisher
 * @implements LoggerInterface
 * @constructor
 */
function GenericPSKLogger(messagePublisher) {
    LoggerInterface.call(this);

    const logger = new LoggerClient(messagePublisher);

    function debug(...params) {
        const meta = prepareMeta();
        return logger.debug(meta, ...params);
    }

    function error(...params) {
        const meta = prepareMeta();
        return logger.error(meta, ...params);
    }

    function info(...params) {
        const meta = prepareMeta();
        return logger.info(meta, ...params);
    }

    function log(...params) {
        const meta = prepareMeta();
        return logger.log(meta, ...params);
    }

    function warn(...params) {
        const meta = prepareMeta();
        return logger.warn(meta, ...params);
    }

    function event(event, ...params) {
        const meta = prepareMeta();
        return logger.event(event, meta, params);
    }
    
    function redirect(logType, logObject) {
        const logMeta = logObject.meta;
        const meta = prepareMeta();
        
        Object.assign(meta, logMeta);

        logObject.meta = meta;

        return logger.redirect(logType, logObject);
    }

    function prepareMeta() {
        if (global.$$.getEnvironmentData) {
            return global.$$.getEnvironmentData();
        }
        
        return {};
    }


    this.debug    = debug;
    this.error    = error;
    this.event    = event;
    this.info     = info;
    this.log      = log;
    this.redirect = redirect;
    this.warn     = warn;

}

module.exports = GenericPSKLogger;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../LoggerClient":"/opt/privatesky/modules/psklogger/src/LoggerClient/index.js"}],"/opt/privatesky/modules/psklogger/src/PSKLoggerClient/index.js":[function(require,module,exports){
const Configurator     = require('../utils/Configurator');
const GenericPSKLogger = require('./GenericPSKLogger');
const MessagePublisher = require('../MessagePublisher').MessagePublisher;

function getLogger() {
    let messagePublisher;

    if (process.env.context === 'sandbox') {

        messagePublisher = new MessagePublisher();
    } else {
        const config = Configurator.getConfig();
        messagePublisher = new MessagePublisher(config.addressForPublishers);
    }

    return new GenericPSKLogger(messagePublisher);
}

module.exports = {
    getLogger
};

},{"../MessagePublisher":"/opt/privatesky/modules/psklogger/src/MessagePublisher/index.js","../utils/Configurator":"/opt/privatesky/modules/psklogger/src/utils/Configurator.js","./GenericPSKLogger":"/opt/privatesky/modules/psklogger/src/PSKLoggerClient/GenericPSKLogger.js"}],"/opt/privatesky/modules/psklogger/src/PubSubProxy/PubSubProxy.js":[function(require,module,exports){
const zeroMQ = require('zeromq');
const utils = require('../utils');

/**
 * Proxy between publishers and subscribers to avoid star topology communication
 * Subscribers should connect first otherwise no subscription request will be sent to publishers and therefore they
 * won't even send the messages to the proxy. This is because the filtering is done on the publisher for tcp or ipc,
 * view http://zguide.zeromq.org/page:all#Getting-the-Message-Out for more info
 * @param {string!} addressForPublishers - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @param {string!} addressForSubscribers - Base address including protocol and port (ex: tcp://127.0.0.1:8080)
 * @constructor
 */
function PubSubProxy({addressForPublishers, addressForSubscribers}) {
    const frontend = zeroMQ.createSocket('xsub');
    const backend = zeroMQ.createSocket('xpub');
    const bufferedBackend = new utils.BufferedSocket(backend, utils.SocketType.bindable);

    // By default xpub only signals new subscriptions
    // Settings it to verbose = 1 , will signal on every new subscribe
    // uncomment next lines if messages are lost
    // backend.setsockopt(zeroMQ.ZMQ_XPUB_VERBOSE, 1);
    // backend.setsockopt(zeroMQ.ZMQ_SNDHWM, 0);
    // backend.setsockopt(zeroMQ.ZMQ_RCVHWM, 0);
    // frontend.setsockopt(zeroMQ.ZMQ_RCVHWM, 0);
    // frontend.setsockopt(zeroMQ.ZMQ_SNDHWM, 0);

    // When we receive data on frontend, it means someone is publishing
    frontend.on('message', (...args) => {
        // We just relay it to the backend, so subscribers can receive it
        bufferedBackend.send(args);
    });

    // When backend receives a message, it's subscribe requests
    backend.on('message', (data) => {
        // We send it to frontend, so it knows to what channels to listen to
        frontend.send(data);
    });

    /************* MONITOR SOCKET *************/

    frontend.bindSync(addressForPublishers);
    backend.bindSync(addressForSubscribers);

    const events = ["SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];

    events.forEach(event => {
        process.on(event, () => {
            frontend.close();
            backend.close();
        });
    });
}

module.exports = PubSubProxy;

},{"../utils":"/opt/privatesky/modules/psklogger/src/utils/index.js","zeromq":false}],"/opt/privatesky/modules/psklogger/src/PubSubProxy/index.js":[function(require,module,exports){
const PubSubProxy = require('./PubSubProxy');

module.exports = {PubSubProxy};

},{"./PubSubProxy":"/opt/privatesky/modules/psklogger/src/PubSubProxy/PubSubProxy.js"}],"/opt/privatesky/modules/psklogger/src/utils/BufferedSocket.js":[function(require,module,exports){
const SocketType = require('./SocketType');

/**
 * Wrapper for ZeroMQ socket that tries to prevent 'slow joiner', meaning it buffers the first messages until the
 * connection is established, otherwise the first messages would be lost
 * @param {Socket} socket - instance of ZeroMQ Socket
 * @param {SocketType<number>} type - used to determine if should listen for 'connect' or 'accept' event
 * @param {Number?} maxSize = 1000 - Max size for the internal buffer, if 0 the buffer is infinite but can cause memory leak
 * @constructor
 */
function BufferedSocket(socket, type, maxSize = 10000) {
    if(maxSize < 0) {
        maxSize = 1000;
    }

    let messageQueue = [];
    let isConnected = false;
    let currentBufferSize = 0;

    socket.monitor();
    const event = _getEventForType(type);

    socket.on(event, () => {
        isConnected = true;
        _flushQueue();
    });

    /************* PUBLIC METHODS *************/

    function send(message) {
        if (!isConnected) {
            if (maxSize !== 0 && currentBufferSize < maxSize) {
                currentBufferSize += 1;
                messageQueue.push(message);
            }
        } else {
            socket.send(message);
        }
    }

    /************* PRIVATE METHODS *************/

    function _flushQueue() {
        for (const message of messageQueue) {
            socket.send(message);
        }

        messageQueue = [];
        currentBufferSize = 0;
    }

    function _getEventForType(type) {
        if (type === SocketType.connectable) {
            return 'connect';
        } else if (type === SocketType.bindable) {
            return 'accept';
        }
    }

    /************* EXPORTS *************/

    this.send = send;
}


module.exports = BufferedSocket;

},{"./SocketType":"/opt/privatesky/modules/psklogger/src/utils/SocketType.js"}],"/opt/privatesky/modules/psklogger/src/utils/Configurator.js":[function(require,module,exports){
const config = {
    addressForPublishers: 'tcp://127.0.0.1:7000',
    addressForSubscribers: 'tcp://127.0.0.1:7001',
    addressForCollector: 'tcp://127.0.0.1:5558'
};

module.exports = {
    getConfig () {
        return Object.freeze(config);
    }
};

},{}],"/opt/privatesky/modules/psklogger/src/utils/EnvironmentDataProvider.js":[function(require,module,exports){


function getEnvironmentData () {
    const path = require('path');
    const os = require('os');
    const platform = os.platform();

    const processPath = process.argv[1];
    const lastSep = processPath.lastIndexOf(path.sep);
    const processStartFile = processPath.substring(lastSep + 1);
    return {
        origin: 'node',
        context: processStartFile,
        processStartFile: processStartFile,
        platform: platform
    };
}

function getEnvironmentDataForDomain() {
    const os = require('os');
    const platform = os.platform();

    return {
        origin: 'domain',
        domain: process.env.PRIVATESKY_DOMAIN_NAME,
        platform: platform
    }
}

function getEnvironmentDataForAgent() {
    const os = require('os');
    const platform = os.platform();

    return {
        origin: 'agent',
        domain: process.env.PRIVATESKY_DOMAIN_NAME,
        agent: process.env.PRIVATESKY_AGENT_NAME,
        platform: platform
    }
}

function getEnvironmentDataForSandbox() {
    return {
        origin: 'sandbox'
    }
}

module.exports = {
    getEnvironmentData,
    getEnvironmentDataForAgent,
    getEnvironmentDataForDomain,
    getEnvironmentDataForSandbox
};

},{"os":"os","path":"path"}],"/opt/privatesky/modules/psklogger/src/utils/LogLevel.js":[function(require,module,exports){
const LogLevel = {};

LogLevel[LogLevel["error"] = 0] = "error";
LogLevel[LogLevel["warn"]  = 1] = "warn";
LogLevel[LogLevel["info"]  = 2] = "info";
LogLevel[LogLevel["debug"] = 3] = "debug";
LogLevel[LogLevel["log"]   = 4] = "log";

module.exports = Object.freeze(LogLevel);

},{}],"/opt/privatesky/modules/psklogger/src/utils/SocketType.js":[function(require,module,exports){
const SocketType = {};
SocketType[SocketType["connectable"] = 0] = "connectable"; // if .connect is called on socket
SocketType[SocketType["bindable"] = 1] = "bindable"; // if .bind is called on socket

module.exports = Object.freeze(SocketType);

},{}],"/opt/privatesky/modules/psklogger/src/utils/index.js":[function(require,module,exports){
const Configurator            = require('./Configurator');
const EnvironmentDataProvider = require('./EnvironmentDataProvider');
const LogLevel                = require('./LogLevel');
const BufferedSocket          = require('./BufferedSocket');
const SocketType              = require('./SocketType');

module.exports = {
    Configurator,
    EnvironmentDataProvider,
    LogLevel,
    BufferedSocket,
    SocketType
};

},{"./BufferedSocket":"/opt/privatesky/modules/psklogger/src/utils/BufferedSocket.js","./Configurator":"/opt/privatesky/modules/psklogger/src/utils/Configurator.js","./EnvironmentDataProvider":"/opt/privatesky/modules/psklogger/src/utils/EnvironmentDataProvider.js","./LogLevel":"/opt/privatesky/modules/psklogger/src/utils/LogLevel.js","./SocketType":"/opt/privatesky/modules/psklogger/src/utils/SocketType.js"}],"/opt/privatesky/modules/soundpubsub/lib/soundPubSub.js":[function(require,module,exports){
/*
Initial License: (c) Axiologic Research & Alboaie Sînică.
Contributors: Axiologic Research , PrivateSky project
Code License: LGPL or MIT.
*/


/**
 *   Usually an event could cause execution of other callback events . We say that is a level 1 event if is causeed by a level 0 event and so on
 *
 *      SoundPubSub provides intuitive results regarding to asynchronous calls of callbacks and computed values/expressions:
 *   we prevent immediate execution of event callbacks to ensure the intuitive final result is guaranteed as level 0 execution
 *   we guarantee that any callback function is "re-entrant"
 *   we are also trying to reduce the number of callback execution by looking in queues at new messages published by
 *   trying to compact those messages (removing duplicate messages, modifying messages, or adding in the history of another event ,etc)
 *
 *      Example of what can be wrong without non-sound asynchronous calls:
 *
 *  Step 0: Initial state:
 *   a = 0;
 *   b = 0;
 *
 *  Step 1: Initial operations:
 *   a = 1;
 *   b = -1;
 *
 *  // an observer reacts to changes in a and b and compute CORRECT like this:
 *   if( a + b == 0) {
 *       CORRECT = false;
 *       notify(...); // act or send a notification somewhere..
 *   } else {
 *      CORRECT = false;
 *   }
 *
 *    Notice that: CORRECT will be true in the end , but meantime, after a notification was sent and CORRECT was wrongly, temporarily false!
 *    soundPubSub guarantee that this does not happen because the syncronous call will before any observer (bot asignation on a and b)
 *
 *   More:
 *   you can use blockCallBacks and releaseCallBacks in a function that change a lot a collection or bindable objects and all
 *   the notifications will be sent compacted and properly
 */

// TODO: optimisation!? use a more efficient queue instead of arrays with push and shift!?
// TODO: see how big those queues can be in real applications
// for a few hundreds items, queues made from array should be enough
//*   Potential TODOs:
//    *     prevent any form of problem by calling callbacks in the expected order !?
//*     preventing infinite loops execution cause by events!?
//*
//*
// TODO: detect infinite loops (or very deep propagation) It is possible!?

const Queue = require('swarmutils').Queue;

function SoundPubSub(){

	/**
	 * publish
	 *      Publish a message {Object} to a list of subscribers on a specific topic
	 *
	 * @params {String|Number} target,  {Object} message
	 * @return number of channel subscribers that will be notified
	 */
	this.publish = function(target, message){
		if(!invalidChannelName(target) && !invalidMessageType(message) && (typeof channelSubscribers[target] != 'undefined')){
			compactAndStore(target, message);
			setTimeout(dispatchNext, 0);
			return channelSubscribers[target].length;
		} else{
			return null;
		}
	};

	/**
	 * subscribe
	 *      Subscribe / add a {Function} callBack on a {String|Number}target channel subscribers list in order to receive
	 *      messages published if the conditions defined by {Function}waitForMore and {Function}filter are passed.
	 *
	 * @params {String|Number}target, {Function}callBack, {Function}waitForMore, {Function}filter
	 *
	 *          target      - channel name to subscribe
	 *          callback    - function to be called when a message was published on the channel
	 *          waitForMore - a intermediary function that will be called after a successfuly message delivery in order
	 *                          to decide if a new messages is expected...
	 *          filter      - a function that receives the message before invocation of callback function in order to allow
	 *                          relevant message before entering in normal callback flow
	 * @return
	 */
	this.subscribe = function(target, callBack, waitForMore, filter){
		if(!invalidChannelName(target) && !invalidFunction(callBack)){
			var subscriber = {"callBack":callBack, "waitForMore":waitForMore, "filter":filter};
			var arr = channelSubscribers[target];
			if(typeof arr == 'undefined'){
				arr = [];
				channelSubscribers[target] = arr;
			}
			arr.push(subscriber);
		}
	};

	/**
	 * unsubscribe
	 *      Unsubscribe/remove {Function} callBack from the list of subscribers of the {String|Number} target channel
	 *
	 * @params {String|Number} target, {Function} callBack, {Function} filter
	 *
	 *          target      - channel name to unsubscribe
	 *          callback    - reference of the original function that was used as subscribe
	 *          filter      - reference of the original filter function
	 * @return
	 */
	this.unsubscribe = function(target, callBack, filter){
		if(!invalidFunction(callBack)){
			var gotit = false;
			if(channelSubscribers[target]){
				for(var i = 0; i < channelSubscribers[target].length;i++){
					var subscriber =  channelSubscribers[target][i];
					if(subscriber.callBack === callBack && ( typeof filter === 'undefined' || subscriber.filter === filter )){
						gotit = true;
						subscriber.forDelete = true;
						subscriber.callBack = undefined;
						subscriber.filter = undefined;
					}
				}
			}
			if(!gotit){
				wprint("Unable to unsubscribe a callback that was not subscribed!");
			}
		}
	};

	/**
	 * blockCallBacks
	 *
	 * @params
	 * @return
	 */
	this.blockCallBacks = function(){
		level++;
	};

	/**
	 * releaseCallBacks
	 *
	 * @params
	 * @return
	 */
	this.releaseCallBacks = function(){
		level--;
		//hack/optimisation to not fill the stack in extreme cases (many events caused by loops in collections,etc)
		while(level === 0 && dispatchNext(true)){
			//nothing
		}

		while(level === 0 && callAfterAllEvents()){
            //nothing
		}
	};

	/**
	 * afterAllEvents
	 *
	 * @params {Function} callback
	 *
	 *          callback - function that needs to be invoked once all events are delivered
	 * @return
	 */
	this.afterAllEvents = function(callBack){
		if(!invalidFunction(callBack)){
			afterEventsCalls.push(callBack);
		}
		this.blockCallBacks();
		this.releaseCallBacks();
	};

	/**
	 * hasChannel
	 *
	 * @params {String|Number} channel
	 *
	 *          channel - name of the channel that need to be tested if present
	 * @return
	 */
	this.hasChannel = function(channel){
		return !invalidChannelName(channel) && (typeof channelSubscribers[channel] != 'undefined') ? true : false;
	};

	/**
	 * addChannel
	 *
	 * @params {String} channel
	 *
	 *          channel - name of a channel that needs to be created and added to soundpubsub repository
	 * @return
	 */
	this.addChannel = function(channel){
		if(!invalidChannelName(channel) && !this.hasChannel(channel)){
			channelSubscribers[channel] = [];
		}
	};

	/* ---------------------------------------- protected stuff ---------------------------------------- */
	var self = this;
	// map channelName (object local id) -> array with subscribers
	var channelSubscribers = {};

	// map channelName (object local id) -> queue with waiting messages
	var channelsStorage = {};

	// object
	var typeCompactor = {};

	// channel names
	var executionQueue = new Queue();
	var level = 0;



	/**
	 * registerCompactor
	 *
	 *       An compactor takes a newEvent and and oldEvent and return the one that survives (oldEvent if
	 *  it can compact the new one or the newEvent if can't be compacted)
	 *
	 * @params {String} type, {Function} callBack
	 *
	 *          type        - channel name to unsubscribe
	 *          callBack    - handler function for that specific event type
	 * @return
	 */
	this.registerCompactor = function(type, callBack) {
		if(!invalidFunction(callBack)){
			typeCompactor[type] = callBack;
		}
	};

	/**
	 * dispatchNext
	 *
	 * @param fromReleaseCallBacks: hack to prevent too many recursive calls on releaseCallBacks
	 * @return {Boolean}
	 */
	function dispatchNext(fromReleaseCallBacks){
		if(level > 0) {
			return false;
		}
		const channelName = executionQueue.front();
		if(typeof channelName != 'undefined'){
			self.blockCallBacks();
			try{
				let message;
				if(!channelsStorage[channelName].isEmpty()) {
					message = channelsStorage[channelName].front();
				}
				if(typeof message == 'undefined'){
					if(!channelsStorage[channelName].isEmpty()){
						wprint("Can't use as message in a pub/sub channel this object: " + message);
					}
					executionQueue.pop();
				} else {
					if(typeof message.__transmisionIndex == 'undefined'){
						message.__transmisionIndex = 0;
						for(var i = channelSubscribers[channelName].length-1; i >= 0 ; i--){
							var subscriber =  channelSubscribers[channelName][i];
							if(subscriber.forDelete === true){
								channelSubscribers[channelName].splice(i,1);
							}
						}
					} else{
						message.__transmisionIndex++;
					}
					//TODO: for immutable objects it will not work also, fix for shape models
					if(typeof message.__transmisionIndex == 'undefined'){
						wprint("Can't use as message in a pub/sub channel this object: " + message);
					}
					subscriber = channelSubscribers[channelName][message.__transmisionIndex];
					if(typeof subscriber == 'undefined'){
						delete message.__transmisionIndex;
						channelsStorage[channelName].pop();
					} else{
						if(subscriber.filter === null || typeof subscriber.filter === "undefined" || (!invalidFunction(subscriber.filter) && subscriber.filter(message))){
							if(!subscriber.forDelete){
								subscriber.callBack(message);
								if(subscriber.waitForMore && !invalidFunction(subscriber.waitForMore) && !subscriber.waitForMore(message)){
									subscriber.forDelete = true;
								}
							}
						}
					}
				}
			} catch(err){
				wprint("Event callback failed: "+ subscriber.callBack +"error: " + err.stack);
			}
			//
			if(fromReleaseCallBacks){
				level--;
			} else{
				self.releaseCallBacks();
			}
			return true;
		} else{
			return false;
		}
	}

	function compactAndStore(target, message){
		var gotCompacted = false;
		var arr = channelsStorage[target];
		if(typeof arr == 'undefined'){
			arr = new Queue();
			channelsStorage[target] = arr;
		}

		if(message && typeof message.type != 'undefined'){
			var typeCompactorCallBack = typeCompactor[message.type];

			if(typeof typeCompactorCallBack != 'undefined'){
				for(let channel of arr) {
					if(typeCompactorCallBack(message, channel) === channel) {
						if(typeof channel.__transmisionIndex == 'undefined') {
							gotCompacted = true;
							break;
						}
					}
				}
			}
		}

		if(!gotCompacted && message){
			arr.push(message);
			executionQueue.push(target);
		}
	}

	var afterEventsCalls = new Queue();
	function callAfterAllEvents (){
		if(!afterEventsCalls.isEmpty()){
			var callBack = afterEventsCalls.pop();
			//do not catch exceptions here..
			callBack();
		}
		return !afterEventsCalls.isEmpty();
	}

	function invalidChannelName(name){
		var result = false;
		if(!name || (typeof name != "string" && typeof name != "number")){
			result = true;
			wprint("Invalid channel name: " + name);
		}

		return result;
	}

	function invalidMessageType(message){
		var result = false;
		if(!message || typeof message != "object"){
			result = true;
			wprint("Invalid messages types: " + message);
		}
		return result;
	}

	function invalidFunction(callback){
		var result = false;
		if(!callback || typeof callback != "function"){
			result = true;
			wprint("Expected to be function but is: " + callback);
		}
		return result;
	}
}

exports.soundPubSub = new SoundPubSub();
},{"swarmutils":"swarmutils"}],"/opt/privatesky/modules/swarmutils/lib/Combos.js":[function(require,module,exports){
function product(args) {
    if(!args.length){
        return [ [] ];
    }
    var prod = product(args.slice(1)), r = [];
    args[0].forEach(function(x) {
        prod.forEach(function(p) {
            r.push([ x ].concat(p));
        });
    });
    return r;
}

function objectProduct(obj) {
    var keys = Object.keys(obj),
        values = keys.map(function(x) { return obj[x]; });

    return product(values).map(function(p) {
        var e = {};
        keys.forEach(function(k, n) { e[k] = p[n]; });
        return e;
    });
}

module.exports = objectProduct;
},{}],"/opt/privatesky/modules/swarmutils/lib/OwM.js":[function(require,module,exports){
var meta = "meta";

function OwM(serialized){

    if(serialized){
        return OwM.prototype.convert(serialized);
    }

    Object.defineProperty(this, meta, {
        writable: false,
        enumerable: true,
        value: {}
    });

    Object.defineProperty(this, "setMeta", {
        writable: false,
        enumerable: false,
        configurable:false,
        value: function(prop, value){
            if(typeof prop == "object" && typeof value == "undefined"){
                for(var p in prop){
                    this[meta][p] = prop[p];
                }
                return prop;
            }
            this[meta][prop] = value;
            return value;
        }
    });

    Object.defineProperty(this, "getMeta", {
        writable: false,
        value: function(prop){
            return this[meta][prop];
        }
    });
}

function testOwMSerialization(obj){
    let res = false;

    if(obj){
        res = typeof obj[meta] != "undefined" && !(obj instanceof OwM);
    }

    return res;
}

OwM.prototype.convert = function(serialized){
    const owm = new OwM();

    for(var metaProp in serialized.meta){
        if(!testOwMSerialization(serialized[metaProp])) {
            owm.setMeta(metaProp, serialized.meta[metaProp]);
        }else{
            owm.setMeta(metaProp, OwM.prototype.convert(serialized.meta[metaProp]));
        }
    }

    for(var simpleProp in serialized){
        if(simpleProp === meta) {
            continue;
        }

        if(!testOwMSerialization(serialized[simpleProp])){
            owm[simpleProp] = serialized[simpleProp];
        }else{
            owm[simpleProp] = OwM.prototype.convert(serialized[simpleProp]);
        }
    }

    return owm;
};

OwM.prototype.getMetaFrom = function(obj, name){
    var res;
    if(!name){
        res = obj[meta];
    }else{
        res = obj[meta][name];
    }
    return res;
};

OwM.prototype.setMetaFor = function(obj, name, value){
    obj[meta][name] = value;
    return obj[meta][name];
};

module.exports = OwM;
},{}],"/opt/privatesky/modules/swarmutils/lib/Queue.js":[function(require,module,exports){
function QueueElement(content) {
	this.content = content;
	this.next = null;
}

function Queue() {
	this.head = null;
	this.tail = null;
	this.length = 0;
	this.push = function (value) {
		const newElement = new QueueElement(value);
		if (!this.head) {
			this.head = newElement;
			this.tail = newElement;
		} else {
			this.tail.next = newElement;
			this.tail = newElement;
		}
		this.length++;
	};

	this.pop = function () {
		if (!this.head) {
			return null;
		}
		const headCopy = this.head;
		this.head = this.head.next;
		this.length--;

		//fix???????
		if(this.length === 0){
            this.tail = null;
		}

		return headCopy.content;
	};

	this.front = function () {
		return this.head ? this.head.content : undefined;
	};

	this.isEmpty = function () {
		return this.head === null;
	};

	this[Symbol.iterator] = function* () {
		let head = this.head;
		while(head !== null) {
			yield head.content;
			head = head.next;
		}
	}.bind(this);
}

Queue.prototype.toString = function () {
	let stringifiedQueue = '';
	let iterator = this.head;
	while (iterator) {
		stringifiedQueue += `${JSON.stringify(iterator.content)} `;
		iterator = iterator.next;
	}
	return stringifiedQueue;
};

Queue.prototype.inspect = Queue.prototype.toString;

module.exports = Queue;
},{}],"/opt/privatesky/modules/swarmutils/lib/beesHealer.js":[function(require,module,exports){
const OwM = require("./OwM");

/*
    Prepare the state of a swarm to be serialised
*/

exports.asJSON = function(valueObj, phaseName, args, callback){

        let valueObject = valueObj.valueOf();
        let res = new OwM();
        res.publicVars          = valueObject.publicVars;
        res.privateVars         = valueObject.privateVars;

        res.setMeta("swarmTypeName", OwM.prototype.getMetaFrom(valueObject, "swarmTypeName"));
        res.setMeta("swarmId",       OwM.prototype.getMetaFrom(valueObject, "swarmId"));
        res.setMeta("target",        OwM.prototype.getMetaFrom(valueObject, "target"));
        res.setMeta("homeSecurityContext",        OwM.prototype.getMetaFrom(valueObject, "homeSecurityContext"));
        res.setMeta("requestId",        OwM.prototype.getMetaFrom(valueObject, "requestId"));

        if(!phaseName){
            res.setMeta("command", "stored");
        } else {
            res.setMeta("phaseName", phaseName);
            res.setMeta("phaseId", $$.uidGenerator.safe_uuid());
            res.setMeta("args", args);
            res.setMeta("command", OwM.prototype.getMetaFrom(valueObject, "command") || "executeSwarmPhase");
        }

        res.setMeta("waitStack", valueObject.meta.waitStack); //TODO: think if is not better to be deep cloned and not referenced!!!

        if(callback){
            return callback(null, res);
        }
        //console.log("asJSON:", res, valueObject);
        return res;
};

exports.jsonToNative = function(serialisedValues, result){

    for(let v in serialisedValues.publicVars){
        result.publicVars[v] = serialisedValues.publicVars[v];

    };
    for(let l in serialisedValues.privateVars){
        result.privateVars[l] = serialisedValues.privateVars[l];
    };

    for(let i in OwM.prototype.getMetaFrom(serialisedValues)){
        OwM.prototype.setMetaFor(result, i, OwM.prototype.getMetaFrom(serialisedValues, i));
    };

};
},{"./OwM":"/opt/privatesky/modules/swarmutils/lib/OwM.js"}],"/opt/privatesky/modules/swarmutils/lib/pskconsole.js":[function(require,module,exports){
var commands = {};
var commands_help = {};

//global function addCommand
addCommand = function addCommand(verb, adverbe, funct, helpLine){
    var cmdId;
    if(!helpLine){
        helpLine = " ";
    } else {
        helpLine = " " + helpLine;
    }
    if(adverbe){
        cmdId = verb + " " +  adverbe;
        helpLine = verb + " " +  adverbe + helpLine;
    } else {
        cmdId = verb;
        helpLine = verb + helpLine;
    }
    commands[cmdId] = funct;
        commands_help[cmdId] = helpLine;
};

function doHelp(){
    console.log("List of commands:");
    for(var l in commands_help){
        console.log("\t", commands_help[l]);
    }
}

addCommand("-h", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("/?", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("help", null, doHelp, "\t\t\t\t\t\t |just print the help");


function runCommand(){
  var argv = Object.assign([], process.argv);
  var cmdId = null;
  var cmd = null;
  argv.shift();
  argv.shift();

  if(argv.length >=1){
      cmdId = argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }


  if(!cmd && argv.length >=1){
      cmdId = cmdId + " " + argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }

  if(!cmd){
    if(cmdId){
        console.log("Unknown command: ", cmdId);
    }
    cmd = doHelp;
  }

  cmd.apply(null,argv);

}

module.exports = {
    runCommand
};


},{}],"/opt/privatesky/modules/swarmutils/lib/safe-uuid.js":[function(require,module,exports){

function encode(buffer) {
    return buffer.toString('base64')
        .replace(/\+/g, '')
        .replace(/\//g, '')
        .replace(/=+$/, '');
};

function stampWithTime(buf, salt, msalt){
    if(!salt){
        salt = 1;
    }
    if(!msalt){
        msalt = 1;
    }
    var date = new Date;
    var ct = Math.floor(date.getTime() / salt);
    var counter = 0;
    while(ct > 0 ){
        //console.log("Counter", counter, ct);
        buf[counter*msalt] = Math.floor(ct % 256);
        ct = Math.floor(ct / 256);
        counter++;
    }
}

/*
    The uid contains around 256 bits of randomness and are unique at the level of seconds. This UUID should by cryptographically safe (can not be guessed)

    We generate a safe UID that is guaranteed unique (by usage of a PRNG to geneate 256 bits) and time stamping with the number of seconds at the moment when is generated
    This method should be safe to use at the level of very large distributed systems.
    The UUID is stamped with time (seconds): does it open a way to guess the UUID? It depends how safe is "crypto" PRNG, but it should be no problem...

 */

var generateUid = null;


exports.init = function(externalGenerator){
    generateUid = externalGenerator.generateUid;
    return module.exports;
};

exports.safe_uuid = function() {
    var buf = generateUid(32);
    stampWithTime(buf, 1000, 3);
    return encode(buf);
};



/*
    Try to generate a small UID that is unique against chance in the same millisecond second and in a specific context (eg in the same choreography execution)
    The id contains around 6*8 = 48  bits of randomness and are unique at the level of milliseconds
    This method is safe on a single computer but should be used with care otherwise
    This UUID is not cryptographically safe (can be guessed)
 */
exports.short_uuid = function(callback) {
    require('crypto').randomBytes(12, function (err, buf) {
        if (err) {
            callback(err);
            return;
        }
        stampWithTime(buf,1,2);
        callback(null, encode(buf));
    });
};
},{"crypto":"crypto"}],"/opt/privatesky/modules/swarmutils/lib/uidGenerator.js":[function(require,module,exports){
(function (Buffer){
const crypto = require('crypto');
const Queue = require("./Queue");
var PSKBuffer = typeof $$ !== "undefined" && $$.PSKBuffer ? $$.PSKBuffer : Buffer;

function UidGenerator(minBuffers, buffersSize) {
	var buffers = new Queue();
	var lowLimit = .2;

	function fillBuffers(size){
		//notifyObserver();
		const sz = size || minBuffers;
		if(buffers.length < Math.floor(minBuffers*lowLimit)){
			for(var i=0+buffers.length; i < sz; i++){
				generateOneBuffer(null);
			}
		}
	}

	fillBuffers();

	function generateOneBuffer(b){
		if(!b){
			b = PSKBuffer.alloc(0);
		}
		const sz = buffersSize - b.length;
		/*crypto.randomBytes(sz, function (err, res) {
			buffers.push(Buffer.concat([res, b]));
			notifyObserver();
		});*/
		buffers.push(PSKBuffer.concat([ crypto.randomBytes(sz), b ]));
		notifyObserver();
	}

	function extractN(n){
		var sz = Math.floor(n / buffersSize);
		var ret = [];

		for(var i=0; i<sz; i++){
			ret.push(buffers.pop());
			setTimeout(generateOneBuffer, 1);
		}



		var remainder = n % buffersSize;
		if(remainder > 0){
			var front = buffers.pop();
			ret.push(front.slice(0,remainder));
			//generateOneBuffer(front.slice(remainder));
			setTimeout(function(){
				generateOneBuffer(front.slice(remainder));
			},1);
		}

		//setTimeout(fillBuffers, 1);

		return Buffer.concat(ret);
	}

	var fillInProgress = false;

	this.generateUid = function(n){
		var totalSize = buffers.length * buffersSize;
		if(n <= totalSize){
			return extractN(n);
		} else {
			if(!fillInProgress){
				fillInProgress = true;
				setTimeout(function(){
					fillBuffers(Math.floor(minBuffers*2.5));
					fillInProgress = false;
				}, 1);
			}
			return crypto.randomBytes(n);
		}
	};

	var observer;
	this.registerObserver = function(obs){
		if(observer){
			console.error(new Error("One observer allowed!"));
		}else{
			if(typeof obs == "function"){
				observer = obs;
				//notifyObserver();
			}
		}
	};

	function notifyObserver(){
		if(observer){
			var valueToReport = buffers.length*buffersSize;
			setTimeout(function(){
				observer(null, {"size": valueToReport});
			}, 10);
		}
	}
}

module.exports.createUidGenerator = function (minBuffers, bufferSize) {
	return new UidGenerator(minBuffers, bufferSize);
};

}).call(this,require("buffer").Buffer)

},{"./Queue":"/opt/privatesky/modules/swarmutils/lib/Queue.js","buffer":"buffer","crypto":"crypto"}],"/opt/privatesky/psknode/core/sandboxes/util/SandBoxManager.js":[function(require,module,exports){
var mq = $$.require("foldermq");

const path = require('path');
const child_process = require("child_process");
const fs = require('fs');

const RESTART_TIMEOUT = 500;
const RESTART_TIMEOUT_LIMIT = 50000;

var sandboxes = {};
var exitHandler = require("../../utils/exitHandler")(sandboxes);

var bootSandBox = $$.flow.describe("PrivateSky.swarm.engine.bootInLauncher", {
    boot:function(sandBox, spaceName, folder, codeFolder, callback){
        // console.log("Booting in ", folder, " context ", spaceName);

        this.callback   = callback;
        this.folder     = folder;
        this.spaceName  = spaceName;
        this.sandBox    = sandBox;
        this.codeFolder    = codeFolder;
        this.timeoutMultiplier = 1;

        var task = this.serial(this.ensureFoldersExists);

        task.folderShouldExist(path.join(this.folder, "mq"),    task.progress);
        task.folderShouldExist(path.join(this.folder, "bundles"),  task.progress);
        task.folderShouldExist(path.join(this.folder, "tmp"),   task.progress);
    },
    folderShouldExist:  function(path, progress){
        fs.mkdir(path, {recursive: true}, progress);
    },
    copyFolder: function(sourcePath, targetPath, callback){
        let fsExt = require("utils").fsExt;
        try{
            fsExt.copy(sourcePath, targetPath, {overwrite: true}, callback);
        }catch(err){
            console.log("Got something...", err);
        }
    },
    ensureFoldersExists: function(err, res){
        if(err){
            console.log(err);
        } else {
            var task = this.parallel(this.runCode);
            this.sandBox.inbound = mq.createQue(path.join(this.folder, "mq/inbound"), this.progress);
            this.sandBox.outbound = mq.createQue(path.join(this.folder, "mq/outbound"), this.progress);

            console.log("Preparing to copy", path.join(this.codeFolder, "bundles"), path.resolve(path.join(this.folder, "bundles")));
            this.copyFolder(path.join(this.codeFolder, "bundles"), path.resolve(path.join(this.folder, "bundles")), task.progress);
        }

    },
    runCode: function(err, res){
        if(!err){
            var mainFile = path.join(process.env.PRIVATESKY_ROOT_FOLDER, "core", "sandboxes", "agentSandbox.js");
            var args = [this.spaceName, process.env.PRIVATESKY_ROOT_FOLDER, path.resolve(process.env.PRIVATESKY_DOMAIN_BUILD)];
            var opts = {stdio: [0, 1, 2, "ipc"]};

            var startChild = (mainFile, args, opts) => {
				console.log("Running: ", mainFile, args, opts);

				// passing options.env might break the agentSandbox, it relies on some inherited env variables from domain
				var child = child_process.fork(mainFile, args);
				sandboxes[this.spaceName] = child;

				this.sandBox.inbound.setIPCChannel(child);
				this.sandBox.outbound.setIPCChannel(child);

				child.on("exit", (code, signal)=>{
				    if(code === 0){
				        console.log(`Sandbox <${this.spaceName}> shutting down.`);
				        return;
                    }
				    let timeout = (this.timeoutMultiplier*RESTART_TIMEOUT) % RESTART_TIMEOUT_LIMIT;
				    console.log(`Sandbox <${this.spaceName}> exits with code ${code}. Restarting in ${timeout} ms.`);
					setTimeout(()=>{
						startChild(mainFile, args, opts);
                        this.timeoutMultiplier *= 1.5;
                    }, timeout);
				});

				return child;
            };

            this.callback(null, startChild(mainFile, args, opts));
        } else {
            console.log("Error executing sandbox!:", err);
            this.callback(err, null);
        }
    }

});

function SandBoxHandler(spaceName, folder, codeFolder, resultCallBack){

    var self = this;
    var mqHandler;


    bootSandBox().boot(this, spaceName,folder, codeFolder, function(err, childProcess){
        if(!err){
            self.childProcess = childProcess;


            /*self.outbound.registerConsumer(function(err, swarm){
                $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, swarm);
            });*/

            self.outbound.registerAsIPCConsumer(function(err, swarm){
                $$.PSK_PubSub.publish($$.CONSTANTS.SWARM_FOR_EXECUTION, swarm);
            });

            mqHandler = self.inbound.getHandler();
            if(pendingMessages.length){
                pendingMessages.map(function(item){
                    self.send(item);
                });
                pendingMessages = null;
            }
        }
    });

    var pendingMessages = [];

    this.send = function (swarm, callback) {
        if(mqHandler){
            mqHandler.sendSwarmForExecution(swarm, callback);
        } else {
            pendingMessages.push(swarm); //TODO: well, a deep clone will not be a better idea?
        }
    }

}


function SandBoxManager(sandboxesFolder, codeFolder, callback){
    var self = this;

    var sandBoxes = {

    };
    function belongsToReplicatedSpace(){
        return true;
    }

    //console.log("Subscribing to:", $$.CONSTANTS.SWARM_FOR_EXECUTION);
    $$.PSK_PubSub.subscribe($$.CONSTANTS.SWARM_FOR_EXECUTION, function(swarm){
        console.log("Executing in sandbox towards: ", swarm.meta.target);

        if(swarm.meta.target == "system" || swarm.meta.command == "asyncReturn"){
            $$.swarmsInstancesManager.revive_swarm(swarm);
            //$$.swarms.restart(swarm.meta.swarmTypeName, swarm);
        } else
        if(swarm.meta.target == "pds"){
            //
        } else
        if(belongsToReplicatedSpace(swarm.meta.target)){
            self.pushToSpaceASwarm(swarm.meta.target, swarm);
        } else {
            //TODO: send towards network
        }

    });


    function startSandBox(spaceName){
        var sandBox = new SandBoxHandler(spaceName, path.join(sandboxesFolder, spaceName), codeFolder);
        sandBoxes[spaceName] = sandBox;
        return sandBox;
    }


    this.pushToSpaceASwarm = function(spaceName, swarm, callback){

        console.log("pushToSpaceASwarm " , spaceName);
        var sandbox = sandBoxes[spaceName];
        if(!sandbox){
            sandbox = sandBoxes[spaceName] = startSandBox(spaceName);
        }
        sandbox.send(swarm, callback);
    }

    callback(null, this);
}


exports.create = function(folder, codeFolder, callback){
    new SandBoxManager(folder, codeFolder, callback);
};



},{"../../utils/exitHandler":"/opt/privatesky/psknode/core/utils/exitHandler.js","child_process":false,"fs":false,"path":"path","utils":"utils"}],"/opt/privatesky/psknode/core/utils/exitHandler.js":[function(require,module,exports){
const events = ["exit", "SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];

module.exports = function manageShutdownProcess(childrenList){

    let shutting = false;
    function handler(){
        //console.log("Handling exit event on", process.pid, "arguments:", arguments);
        var childrenNames = Object.keys(childrenList);
        for(let j=0; j<childrenNames.length; j++){
            var child = childrenList[childrenNames[j]];
            //console.log(`[${process.pid}]`, "Sending kill signal to PID:", child.pid);
            try{
                process.kill(child.pid);
            }catch(err){
                //...
            }
        }

        if(!shutting){
            try{
                process.stdout.cursorTo(0);
                process.stdout.write(`[PID: ${process.pid}] [Timestamp: ${new Date().getTime()}] [Process argv: ${process.argv}]- Shutting down...\n`);
            }catch(err)
            {
                //...
            }
            shutting = true;
        }

        setTimeout(()=>{
            process.exit(0);
        }, 0);
    }

    process.stdin.resume();
    for(let i=0; i<events.length; i++){
        var eventType = events[i];
        process.on(eventType, handler);
    }
    //console.log("Exit handler setup!", `[${process.pid}]`);
};
},{}],"@msgpack/msgpack":[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.MessagePack=t():e.MessagePack=t()}(this,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);var n=function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return s},i=function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e},o="undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder;function s(e){for(var t=e.length,r=0,n=0;n<t;){var i=e.charCodeAt(n++);if(0!=(4294967168&i))if(0==(4294965248&i))r+=2;else{if(i>=55296&&i<=56319&&n<t){var o=e.charCodeAt(n);56320==(64512&o)&&(++n,i=((1023&i)<<10)+(1023&o)+65536)}r+=0==(4294901760&i)?3:4}else r++}return r}var a=o?new TextEncoder:void 0;var u=a&&a.encodeInto?function(e,t,r){a.encodeInto(e,t.subarray(r))}:function(e,t,r){t.set(a.encode(e),r)},h=65536;var c=o?new TextDecoder:null;var f=function(e,t){this.type=e,this.data=t};function l(e,t,r){var n=Math.floor(r/4294967296),i=r;e.setUint32(t,n),e.setUint32(t+4,i)}function p(e,t){return 4294967296*e.getInt32(t)+e.getUint32(t+4)}var d=4294967295,y=17179869183;function w(e){var t=e.sec,r=e.nsec;if(t>=0&&r>=0&&t<=y){if(0===r&&t<=d){var n=new Uint8Array(4);return(s=new DataView(n.buffer)).setUint32(0,t),n}var i=t/4294967296,o=4294967295&t;n=new Uint8Array(8);return(s=new DataView(n.buffer)).setUint32(0,r<<2|3&i),s.setUint32(4,o),n}var s;n=new Uint8Array(12);return(s=new DataView(n.buffer)).setUint32(0,r),l(s,4,t),n}function v(e){var t=e.getTime(),r=Math.floor(t/1e3),n=1e6*(t-1e3*r),i=Math.floor(n/1e9);return{sec:r+i,nsec:n-1e9*i}}function b(e){return e instanceof Date?w(v(e)):null}function g(e){var t=new DataView(e.buffer,e.byteOffset,e.byteLength);switch(e.byteLength){case 4:return{sec:t.getUint32(0),nsec:0};case 8:var r=t.getUint32(0);return{sec:4294967296*(3&r)+t.getUint32(4),nsec:r>>>2};case 12:return{sec:p(t,4),nsec:t.getUint32(0)};default:throw new Error("Unrecognized data size for timestamp: "+e.length)}}function U(e){var t=g(e);return new Date(1e3*t.sec+t.nsec/1e6)}var m={type:-1,encode:b,decode:U},x=function(){function e(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(m)}return e.prototype.register=function(e){var t=e.type,r=e.encode,n=e.decode;if(t>=0)this.encoders[t]=r,this.decoders[t]=n;else{var i=1+t;this.builtInEncoders[i]=r,this.builtInDecoders[i]=n}},e.prototype.tryToEncode=function(e){for(var t=0;t<this.builtInEncoders.length;t++){if(null!=(r=this.builtInEncoders[t]))if(null!=(n=r(e)))return new f(-1-t,n)}for(t=0;t<this.encoders.length;t++){var r,n;if(null!=(r=this.encoders[t]))if(null!=(n=r(e)))return new f(t,n)}return e instanceof f?e:null},e.prototype.decode=function(e,t){var r=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return r?r(e,t):new f(t,e)},e.defaultCodec=new e,e}();function S(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?new Uint8Array(e):Uint8Array.from(e)}var A=null,E=!!A;function B(e,t,r){var n=e.length,i=2*n,o=A.malloc(i);!function(e,t,r,n){for(var i=new DataView(A.memory.buffer,e,t),o=0;o<n;o++)i.setUint16(2*o,r.charCodeAt(o))}(o,i,e,n);var s=A.malloc(5+4*n);try{var a=A.utf8EncodeUint16Array(s,o,n);return t.set(new Uint8Array(A.memory.buffer,s,a),r),a}finally{A.free(o),A.free(s)}}var L=65536;function T(e,t,r){var n,i,o,s=A.malloc(r),a=A.malloc(2*r);try{n=s,i=e.subarray(t,t+r),o=r,new Uint8Array(A.memory.buffer,n,o).set(i);var u=A.utf8DecodeToUint16Array(a,s,r);return function(e){if(e.length<=L)return String.fromCharCode.apply(String,e);for(var t="",r=0;r<e.length;r++){var n=e.subarray(r*L,(r+1)*L);t+=String.fromCharCode.apply(String,n)}return t}(new Uint16Array(A.memory.buffer,a,u))}finally{A.free(s),A.free(a)}}var I=function(e){var t="function"==typeof Symbol&&e[Symbol.iterator],r=0;return t?t.call(e):{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}},M=100,k=2048,P=function(){function e(e,t,r,n,i){void 0===e&&(e=x.defaultCodec),void 0===t&&(t=M),void 0===r&&(r=k),void 0===n&&(n=!1),void 0===i&&(i=!1),this.extensionCodec=e,this.maxDepth=t,this.initialBufferSize=r,this.sortKeys=n,this.forceFloat32=i,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return e.prototype.encode=function(e,t){if(t>this.maxDepth)throw new Error("Too deep objects in depth "+t);null==e?this.encodeNil():"boolean"==typeof e?this.encodeBoolean(e):"number"==typeof e?this.encodeNumber(e):"string"==typeof e?this.encodeString(e):this.encodeObject(e,t)},e.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},e.prototype.ensureBufferSizeToWrite=function(e){var t=this.pos+e;this.view.byteLength<t&&this.resizeBuffer(2*t)},e.prototype.resizeBuffer=function(e){var t=new ArrayBuffer(e),r=new Uint8Array(t),n=new DataView(t);r.set(this.bytes),this.view=n,this.bytes=r},e.prototype.encodeNil=function(){this.writeU8(192)},e.prototype.encodeBoolean=function(e){!1===e?this.writeU8(194):this.writeU8(195)},e.prototype.encodeNumber=function(e){Number.isSafeInteger(e)?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):(this.writeU8(211),this.writeI64(e)):this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))},e.prototype.writeStringHeader=function(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too long string: "+e+" bytes in UTF-8");this.writeU8(219),this.writeU32(e)}},e.prototype.encodeString=function(e){var t=e.length;if(o&&t>200){var r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),u(e,this.bytes,this.pos),this.pos+=r}else{if(E&&t>1024){var n=5+4*t;this.ensureBufferSizeToWrite(n);var i=B(e,this.bytes,this.pos);return void(this.pos+=i)}r=s(e);this.ensureBufferSizeToWrite(5+r),this.writeStringHeader(r),function(e,t,r){for(var n=e.length,i=r,o=0;o<n;){var s=e.charCodeAt(o++);if(0!=(4294967168&s)){if(0==(4294965248&s))t[i++]=s>>6&31|192;else{if(s>=55296&&s<=56319&&o<n){var a=e.charCodeAt(o);56320==(64512&a)&&(++o,s=((1023&s)<<10)+(1023&a)+65536)}0==(4294901760&s)?(t[i++]=s>>12&15|224,t[i++]=s>>6&63|128):(t[i++]=s>>18&7|240,t[i++]=s>>12&63|128,t[i++]=s>>6&63|128)}t[i++]=63&s|128}else t[i++]=s}}(e,this.bytes,this.pos),this.pos+=r}},e.prototype.encodeObject=function(e,t){var r=this.extensionCodec.tryToEncode(e);if(null!=r)this.encodeExtension(r);else if(Array.isArray(e))this.encodeArray(e,t);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else{if("object"!=typeof e)throw new Error("Unrecognized object: "+Object.prototype.toString.apply(e));this.encodeMap(e,t)}},e.prototype.encodeBinary=function(e){var t=e.byteLength;if(t<256)this.writeU8(196),this.writeU8(t);else if(t<65536)this.writeU8(197),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large binary: "+t);this.writeU8(198),this.writeU32(t)}var r=S(e);this.writeU8a(r)},e.prototype.encodeArray=function(e,t){var r,n,i=e.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else{if(!(i<4294967296))throw new Error("Too large array: "+i);this.writeU8(221),this.writeU32(i)}try{for(var o=I(e),s=o.next();!s.done;s=o.next()){var a=s.value;this.encode(a,t+1)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}},e.prototype.encodeMap=function(e,t){var r=Object.keys(e);this.sortKeys&&r.sort();var n=r.length;if(n<16)this.writeU8(128+n);else if(n<65536)this.writeU8(222),this.writeU16(n);else{if(!(n<4294967296))throw new Error("Too large map object: "+n);this.writeU8(223),this.writeU32(n)}for(var i=0;i<n;i++){var o=r[i];this.encodeString(o),this.encode(e[o],t+1)}},e.prototype.encodeExtension=function(e){var t=e.data.length;if(1===t)this.writeU8(212);else if(2===t)this.writeU8(213);else if(4===t)this.writeU8(214);else if(8===t)this.writeU8(215);else if(16===t)this.writeU8(216);else if(t<256)this.writeU8(199),this.writeU8(t);else if(t<65536)this.writeU8(200),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too large extension object: "+t);this.writeU8(201),this.writeU32(t)}this.writeI8(e.type),this.writeU8a(e.data)},e.prototype.writeU8=function(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++},e.prototype.writeU8a=function(e){var t=e.length;this.ensureBufferSizeToWrite(t),this.bytes.set(e,this.pos),this.pos+=t},e.prototype.writeI8=function(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++},e.prototype.writeU16=function(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2},e.prototype.writeI16=function(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2},e.prototype.writeU32=function(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4},e.prototype.writeI32=function(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4},e.prototype.writeF32=function(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4},e.prototype.writeF64=function(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8},e.prototype.writeU64=function(e){this.ensureBufferSizeToWrite(8),function(e,t,r){var n=r/4294967296,i=r;e.setUint32(t,n),e.setUint32(t+4,i)}(this.view,this.pos,e),this.pos+=8},e.prototype.writeI64=function(e){this.ensureBufferSizeToWrite(8),l(this.view,this.pos,e),this.pos+=8},e}(),z={};function C(e,t){void 0===t&&(t=z);var r=new P(t.extensionCodec,t.maxDepth,t.initialBufferSize,t.sortKeys,t.forceFloat32);return r.encode(e,1),r.getUint8Array()}function D(e){return(e<0?"-":"")+"0x"+Math.abs(e).toString(16).padStart(2,"0")}var _,j=function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function s(e){try{u(n.next(e))}catch(e){o(e)}}function a(e){try{u(n.throw(e))}catch(e){o(e)}}function u(e){e.done?i(e.value):new r(function(t){t(e.value)}).then(s,a)}u((n=n.apply(e,t||[])).next())})},O=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},F=function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},n("next"),n("throw"),n("return"),t[Symbol.asyncIterator]=function(){return this},t);function n(r){t[r]=e[r]&&function(t){return new Promise(function(n,i){(function(e,t,r,n){Promise.resolve(n).then(function(t){e({value:t,done:r})},t)})(n,i,(t=e[r](t)).done,t.value)})}}},V=function(e){return this instanceof V?(this.v=e,this):new V(e)},R=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise(function(r,n){o.push([e,t,r,n])>1||a(e,t)})})}function a(e,t){try{(r=i[e](t)).value instanceof V?Promise.resolve(r.value.v).then(u,h):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function u(e){a("next",e)}function h(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}};!function(e){e[e.ARRAY=0]="ARRAY",e[e.MAP_KEY=1]="MAP_KEY",e[e.MAP_VALUE=2]="MAP_VALUE"}(_||(_={}));var W=-1,N=new DataView(new ArrayBuffer(0)),Y=new Uint8Array(N.buffer),K=function(){try{N.getInt8(0)}catch(e){return e.constructor}throw new Error("never reached")}(),H=new K("Insufficient data"),G=4294967295,X=function(){function e(e,t,r,n,i,o){void 0===e&&(e=x.defaultCodec),void 0===t&&(t=G),void 0===r&&(r=G),void 0===n&&(n=G),void 0===i&&(i=G),void 0===o&&(o=G),this.extensionCodec=e,this.maxStrLength=t,this.maxBinLength=r,this.maxArrayLength=n,this.maxMapLength=i,this.maxExtLength=o,this.totalPos=0,this.pos=0,this.view=N,this.bytes=Y,this.headByte=W,this.stack=[]}return e.prototype.setBuffer=function(e){this.bytes=S(e),this.view=function(e){if(e instanceof ArrayBuffer)return new DataView(e);var t=S(e);return new DataView(t.buffer,t.byteOffset,t.byteLength)}(this.bytes),this.pos=0},e.prototype.appendBuffer=function(e){if(this.headByte!==W||this.hasRemaining()){var t=this.bytes.subarray(this.pos),r=S(e),n=new Uint8Array(t.length+r.length);n.set(t),n.set(r,t.length),this.setBuffer(n)}else this.setBuffer(e)},e.prototype.hasRemaining=function(e){return void 0===e&&(e=1),this.view.byteLength-this.pos>=e},e.prototype.createNoExtraBytesError=function(e){var t=this.view,r=this.pos;return new RangeError("Extra "+(t.byteLength-r)+" byte(s) found at buffer["+e+"]")},e.prototype.decodeOneSync=function(){var e=this.decodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return e},e.prototype.decodeOneAsync=function(e){var t,r,n,i;return j(this,void 0,void 0,function(){var o,s,a,u,h,c,f,l;return O(this,function(p){switch(p.label){case 0:o=!1,p.label=1;case 1:p.trys.push([1,6,7,12]),t=F(e),p.label=2;case 2:return[4,t.next()];case 3:if((r=p.sent()).done)return[3,5];if(a=r.value,o)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(a);try{s=this.decodeSync(),o=!0}catch(e){if(!(e instanceof K))throw e}this.totalPos+=this.pos,p.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return u=p.sent(),n={error:u},[3,12];case 7:return p.trys.push([7,,10,11]),r&&!r.done&&(i=t.return)?[4,i.call(t)]:[3,9];case 8:p.sent(),p.label=9;case 9:return[3,11];case 10:if(n)throw n.error;return[7];case 11:return[7];case 12:if(o){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return[2,s]}throw c=(h=this).headByte,f=h.pos,l=h.totalPos,new RangeError("Insufficient data in parcing "+D(c)+" at "+l+" ("+f+" in the current buffer)")}})})},e.prototype.decodeStream=function(e){return R(this,arguments,function(){var t,r,n,i,o,s,a,u;return O(this,function(h){switch(h.label){case 0:h.trys.push([0,11,12,17]),t=F(e),h.label=1;case 1:return[4,V(t.next())];case 2:if((r=h.sent()).done)return[3,10];n=r.value,this.appendBuffer(n),h.label=3;case 3:h.trys.push([3,8,,9]),h.label=4;case 4:return i=this.decodeSync(),[4,V(i)];case 5:return[4,h.sent()];case 6:return h.sent(),[3,4];case 7:return[3,9];case 8:if(!((o=h.sent())instanceof K))throw o;return[3,9];case 9:return[3,1];case 10:return[3,17];case 11:return s=h.sent(),a={error:s},[3,17];case 12:return h.trys.push([12,,15,16]),r&&!r.done&&(u=t.return)?[4,V(u.call(t))]:[3,14];case 13:h.sent(),h.label=14;case 14:return[3,16];case 15:if(a)throw a.error;return[7];case 16:return[7];case 17:return[2]}})})},e.prototype.decodeArrayStream=function(e){return R(this,arguments,function(){var t,r,n,i,o,s,a,u,h,c,f;return O(this,function(l){switch(l.label){case 0:t=!1,r=!1,n=0,l.label=1;case 1:l.trys.push([1,13,14,19]),i=F(e),l.label=2;case 2:return[4,V(i.next())];case 3:if((o=l.sent()).done)return[3,12];if(s=o.value,r)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(s),t||(n=this.readArraySize(),t=!0,this.complete()),l.label=4;case 4:l.trys.push([4,9,,10]),l.label=5;case 5:return a=this.decodeSync(),[4,V(a)];case 6:return[4,l.sent()];case 7:return l.sent(),0===--n?(r=!0,[3,8]):[3,5];case 8:return[3,10];case 9:if(!((u=l.sent())instanceof K))throw u;return[3,10];case 10:this.totalPos+=this.pos,l.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return h=l.sent(),c={error:h},[3,19];case 14:return l.trys.push([14,,17,18]),o&&!o.done&&(f=i.return)?[4,V(f.call(i))]:[3,16];case 15:l.sent(),l.label=16;case 16:return[3,18];case 17:if(c)throw c.error;return[7];case 18:return[7];case 19:return[2]}})})},e.prototype.decodeSync=function(){e:for(;;){var e=this.readHeadByte(),t=void 0;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){if(0!==(n=e-128)){this.pushMapState(n),this.complete();continue e}t={}}else if(e<160){if(0!==(n=e-144)){this.pushArrayState(n),this.complete();continue e}t=[]}else{var r=e-160;t=this.decodeUtf8String(r,0)}else if(192===e)t=null;else if(194===e)t=!1;else if(195===e)t=!0;else if(202===e)t=this.readF32();else if(203===e)t=this.readF64();else if(204===e)t=this.readU8();else if(205===e)t=this.readU16();else if(206===e)t=this.readU32();else if(207===e)t=this.readU64();else if(208===e)t=this.readI8();else if(209===e)t=this.readI16();else if(210===e)t=this.readI32();else if(211===e)t=this.readI64();else if(217===e){r=this.lookU8();t=this.decodeUtf8String(r,1)}else if(218===e){r=this.lookU16();t=this.decodeUtf8String(r,2)}else if(219===e){r=this.lookU32();t=this.decodeUtf8String(r,4)}else if(220===e){if(0!==(n=this.readU16())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(221===e){if(0!==(n=this.readU32())){this.pushArrayState(n),this.complete();continue e}t=[]}else if(222===e){if(0!==(n=this.readU16())){this.pushMapState(n),this.complete();continue e}t={}}else if(223===e){if(0!==(n=this.readU32())){this.pushMapState(n),this.complete();continue e}t={}}else if(196===e){var n=this.lookU8();t=this.decodeBinary(n,1)}else if(197===e){n=this.lookU16();t=this.decodeBinary(n,2)}else if(198===e){n=this.lookU32();t=this.decodeBinary(n,4)}else if(212===e)t=this.decodeExtension(1,0);else if(213===e)t=this.decodeExtension(2,0);else if(214===e)t=this.decodeExtension(4,0);else if(215===e)t=this.decodeExtension(8,0);else if(216===e)t=this.decodeExtension(16,0);else if(199===e){n=this.lookU8();t=this.decodeExtension(n,1)}else if(200===e){n=this.lookU16();t=this.decodeExtension(n,2)}else{if(201!==e)throw new Error("Unrecognized type byte: "+D(e));n=this.lookU32();t=this.decodeExtension(n,4)}this.complete();for(var i=this.stack;i.length>0;){var o=i[i.length-1];if(o.type===_.ARRAY){if(o.array[o.position]=t,o.position++,o.position!==o.size)continue e;i.pop(),t=o.array}else{if(o.type===_.MAP_KEY){if("string"!=typeof t)throw new Error("The type of key must be string but "+typeof t);o.key=t,o.type=_.MAP_VALUE;continue e}if(o.type===_.MAP_VALUE){if(o.map[o.key]=t,o.readCount++,o.readCount!==o.size){o.key=null,o.type=_.MAP_KEY;continue e}i.pop(),t=o.map}}}return t}},e.prototype.readHeadByte=function(){return this.headByte===W&&(this.headByte=this.readU8()),this.headByte},e.prototype.complete=function(){this.headByte=W},e.prototype.readArraySize=function(){var e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:if(e<160)return e-144;throw new Error("Unrecognized array type byte: "+D(e))}},e.prototype.pushMapState=function(e){if(e>this.maxMapLength)throw new Error("Max length exceeded: map length ("+e+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:_.MAP_KEY,size:e,key:null,readCount:0,map:{}})},e.prototype.pushArrayState=function(e){if(e>this.maxArrayLength)throw new Error("Max length exceeded: array length ("+e+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:_.ARRAY,size:e,array:new Array(e),position:0})},e.prototype.decodeUtf8String=function(e,t){if(e>this.maxStrLength)throw new Error("Max length exceeded: UTF-8 byte length ("+e+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+t+e)throw H;var r,n=this.pos+t;return r=o&&e>200?function(e,t,r){var n=e.subarray(t,t+r);return c.decode(n)}(this.bytes,n,e):E&&e>1024?T(this.bytes,n,e):function(e,t,r){for(var n=t,o=n+r,s=[],a="";n<o;){var u=e[n++];if(0==(128&u))s.push(u);else if(192==(224&u)){var c=63&e[n++];s.push((31&u)<<6|c)}else if(224==(240&u)){c=63&e[n++];var f=63&e[n++];s.push((31&u)<<12|c<<6|f)}else if(240==(248&u)){var l=(7&u)<<18|(c=63&e[n++])<<12|(f=63&e[n++])<<6|63&e[n++];l>65535&&(l-=65536,s.push(l>>>10&1023|55296),l=56320|1023&l),s.push(l)}else s.push(u);s.length-4>=h&&(a+=String.fromCharCode.apply(String,i(s)),s.length=0)}return s.length>0&&(a+=String.fromCharCode.apply(String,i(s))),a}(this.bytes,n,e),this.pos+=t+e,r},e.prototype.decodeBinary=function(e,t){if(e>this.maxBinLength)throw new Error("Max length exceeded: bin length ("+e+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(e+t))throw H;var r=this.pos+t,n=this.bytes.subarray(r,r+e);return this.pos+=t+e,n},e.prototype.decodeExtension=function(e,t){if(e>this.maxExtLength)throw new Error("Max length exceeded: ext length ("+e+") > maxExtLength ("+this.maxExtLength+")");var r=this.view.getInt8(this.pos+t),n=this.decodeBinary(e,t+1);return this.extensionCodec.decode(n,r)},e.prototype.lookU8=function(){return this.view.getUint8(this.pos)},e.prototype.lookU16=function(){return this.view.getUint16(this.pos)},e.prototype.lookU32=function(){return this.view.getUint32(this.pos)},e.prototype.readU8=function(){var e=this.view.getUint8(this.pos);return this.pos++,e},e.prototype.readI8=function(){var e=this.view.getInt8(this.pos);return this.pos++,e},e.prototype.readU16=function(){var e=this.view.getUint16(this.pos);return this.pos+=2,e},e.prototype.readI16=function(){var e=this.view.getInt16(this.pos);return this.pos+=2,e},e.prototype.readU32=function(){var e=this.view.getUint32(this.pos);return this.pos+=4,e},e.prototype.readI32=function(){var e=this.view.getInt32(this.pos);return this.pos+=4,e},e.prototype.readU64=function(){var e,t,r=(e=this.view,t=this.pos,4294967296*e.getUint32(t)+e.getUint32(t+4));return this.pos+=8,r},e.prototype.readI64=function(){var e=p(this.view,this.pos);return this.pos+=8,e},e.prototype.readF32=function(){var e=this.view.getFloat32(this.pos);return this.pos+=4,e},e.prototype.readF64=function(){var e=this.view.getFloat64(this.pos);return this.pos+=8,e},e}(),q={};function J(e,t){void 0===t&&(t=q);var r=new X(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength);return r.setBuffer(e),r.decodeOneSync()}var Q=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}},Z=function(e){return this instanceof Z?(this.v=e,this):new Z(e)},$=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n,i=r.apply(e,t||[]),o=[];return n={},s("next"),s("throw"),s("return"),n[Symbol.asyncIterator]=function(){return this},n;function s(e){i[e]&&(n[e]=function(t){return new Promise(function(r,n){o.push([e,t,r,n])>1||a(e,t)})})}function a(e,t){try{(r=i[e](t)).value instanceof Z?Promise.resolve(r.value.v).then(u,h):c(o[0][2],r)}catch(e){c(o[0][3],e)}var r}function u(e){a("next",e)}function h(e){a("throw",e)}function c(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}};function ee(e){return null!=e[Symbol.asyncIterator]?e:function(e){return $(this,arguments,function(){var t,r,n,i;return Q(this,function(o){switch(o.label){case 0:t=e.getReader(),o.label=1;case 1:o.trys.push([1,,9,10]),o.label=2;case 2:return[4,Z(t.read())];case 3:return r=o.sent(),n=r.done,i=r.value,n?[4,Z(void 0)]:[3,5];case 4:return[2,o.sent()];case 5:return[4,Z(i)];case 6:return[4,o.sent()];case 7:return o.sent(),[3,2];case 8:return[3,10];case 9:return t.releaseLock(),[7];case 10:return[2]}})})}(e)}var te=function(e,t,r,n){return new(r||(r=Promise))(function(i,o){function s(e){try{u(n.next(e))}catch(e){o(e)}}function a(e){try{u(n.throw(e))}catch(e){o(e)}}function u(e){e.done?i(e.value):new r(function(t){t(e.value)}).then(s,a)}u((n=n.apply(e,t||[])).next())})},re=function(e,t){var r,n,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,n=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=t.call(e,s)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}};function ne(e,t){return void 0===t&&(t=q),te(this,void 0,void 0,function(){var r;return re(this,function(n){return r=ee(e),[2,new X(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeOneAsync(r)]})})}function ie(e,t){void 0===t&&(t=q);var r=ee(e);return new X(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeArrayStream(r)}function oe(e,t){void 0===t&&(t=q);var r=ee(e);return new X(t.extensionCodec,t.maxStrLength,t.maxBinLength,t.maxArrayLength,t.maxMapLength,t.maxExtLength).decodeStream(r)}r.d(t,"encode",function(){return C}),r.d(t,"decode",function(){return J}),r.d(t,"decodeAsync",function(){return ne}),r.d(t,"decodeArrayStream",function(){return ie}),r.d(t,"decodeStream",function(){return oe}),r.d(t,"Decoder",function(){return X}),r.d(t,"Encoder",function(){return P}),r.d(t,"ExtensionCodec",function(){return x}),r.d(t,"ExtData",function(){return f}),r.d(t,"EXT_TIMESTAMP",function(){return-1}),r.d(t,"encodeDateToTimeSpec",function(){return v}),r.d(t,"encodeTimeSpecToTimestamp",function(){return w}),r.d(t,"decodeTimestampToTimeSpec",function(){return g}),r.d(t,"encodeTimestampExtension",function(){return b}),r.d(t,"decodeTimestampExtension",function(){return U}),r.d(t,"__WASM_AVAILABLE",function(){return E})}])});

},{}],"callflow":[function(require,module,exports){

//var path = require("path");
function defaultErrorHandlingImplementation(err, res){
	//console.log(err.stack);
	if(err) throw err;
	return res;
}

require("./lib/overwriteRequire");
/*
const PSKBuffer = require('pskbuffer');
$$.PSKBuffer = PSKBuffer; */


$$.obsolete("Please remove $$.errorHandler  asap");
$$.errorHandler = {
        error:function(err, args, msg){
            console.log(err, "Unknown error from function call with arguments:", args, "Message:", msg);
        },
        throwError:function(err, args, msg){
            console.log(err, "Unknown error from function call with arguments:", args, "Message:", msg);
            throw err;
        },
        ignorePossibleError: function(name){
            console.log(name);
        },
        syntaxError:function(property, swarm, text){
            //throw new Error("Misspelled member name or other internal error!");
            var swarmName;
            try{
                if(typeof swarm == "string"){
                    swarmName = swarm;
                } else
                if(swarm && swarm.meta){
                    swarmName  = swarm.meta.swarmTypeName;
                } else {
                    swarmName = swarm.getInnerValue().meta.swarmTypeName;
                }
            } catch(err){
                swarmName = err.toString();
            }
            if(property){
                console.log("Wrong member name ", property,  " in swarm ", swarmName);
                if(text) {
                    console.log(text);
                }
            } else {
                console.log("Unknown swarm", swarmName);
            }

        },
        warning:function(msg){
            console.log(msg);
        }
    };


$$.obsolete("Please remove $$.safeErrorHandling asap");
$$.safeErrorHandling = function(callback){
        if(callback){
            return callback;
        } else{
            return defaultErrorHandlingImplementation;
        }
    };



$$.obsolete("Please remove $$.__intern asap");
$$.__intern = {
        mkArgs:function(args,pos){
            var argsArray = [];
            for(var i = pos; i < args.length; i++){
                argsArray.push(args[i]);
            }
            return argsArray;
        }
    };



var swarmUtils = require("./lib/choreographies/swarm");
var assetUtils = require("./lib/utilityFunctions/asset");

var transactionUtils = require("./lib/utilityFunctions/transaction");
$$.defaultErrorHandlingImplementation = defaultErrorHandlingImplementation;

var callflowModule = require("./lib/swarmDescription");
$$.callflows        = callflowModule.createSwarmEngine("callflow");
$$.callflow         = $$.callflows;
$$.flow             = $$.callflows;
$$.flows            = $$.callflows;

$$.swarms           = callflowModule.createSwarmEngine("swarm", swarmUtils);
$$.swarm            = $$.swarms;
$$.contracts        = callflowModule.createSwarmEngine("contract", swarmUtils);
$$.contract         = $$.contracts;
$$.assets           = callflowModule.createSwarmEngine("asset", assetUtils);
$$.asset            = $$.assets;
$$.transactions     = callflowModule.createSwarmEngine("transaction", transactionUtils);
$$.transaction      = $$.transactions;


$$.PSK_PubSub = require("soundpubsub").soundPubSub;

$$.securityContext = "system";
$$.libraryPrefix = "global";
$$.libraries = {
    global:{

    }
};

$$.interceptor = require("./lib/InterceptorRegistry").createInterceptorRegistry();

$$.loadLibrary = require("./lib/loadLibrary").loadLibrary;

requireLibrary = function(name){
    //var absolutePath = path.resolve(  $$.__global.__loadLibraryRoot + name);
    return $$.loadLibrary(name,name);
};

require("./constants");

/*//TODO: SHOULD be moved in $$.__globals
$$.ensureFolderExists = function (folder, callback) {
    const flow = $$.flow.start("utils.mkDirRec");
    flow.make(folder, callback);
};

$$.ensureLinkExists = function (existingPath, newPath, callback) {
    const flow = $$.flow.start("utils.mkDirRec");
    flow.makeLink(existingPath, newPath, callback);
};*/

$$.pathNormalize = function (pathToNormalize) {
    const path = require("path");
    pathToNormalize = path.normalize(pathToNormalize);

    return pathToNormalize.replace(/[\/\\]/g, path.sep);
};

// add interceptors

const crypto = require('crypto');

$$.interceptor.register('*', '*', 'before', function () {
    const swarmTypeName = this.getMetadata('swarmTypeName');
    const phaseName = this.getMetadata('phaseName');
    const swarmId = this.getMetadata('swarmId');
    const executionId = crypto.randomBytes(16).toString('hex');

    this.setMetadata('executionId', executionId);

    $$.event('swarm.call.before', {swarmTypeName, phaseName, executionId});
});

$$.interceptor.register('*', '*', 'after', function () {
    const swarmTypeName = this.getMetadata('swarmTypeName');
    const phaseName = this.getMetadata('phaseName');
    const executionId = this.getMetadata('executionId');

    this.setMetadata('executionId', undefined);

    $$.event('swarm.call.time', {swarmTypeName, phaseName, executionId});
});

module.exports = {
    				createSwarmEngine: require("./lib/swarmDescription").createSwarmEngine,
                    createJoinPoint: require("./lib/parallelJoinPoint").createJoinPoint,
                    createSerialJoinPoint: require("./lib/serialJoinPoint").createSerialJoinPoint,
                    swarmInstanceManager: require("./lib/choreographies/swarmInstancesManager"),
                    enableInternalSwarmRouting: function(){
                        function dummyVM(name){
                            function solveSwarm(swarm){
                                $$.swarmsInstancesManager.revive_swarm(swarm);
                            }

                            $$.PSK_PubSub.subscribe(name, solveSwarm);
                            console.log("Creating a fake execution context...");
                        }
                        dummyVM($$.CONSTANTS.SWARM_FOR_EXECUTION);
                    }
				};

},{"./constants":"/opt/privatesky/modules/callflow/constants.js","./lib/InterceptorRegistry":"/opt/privatesky/modules/callflow/lib/InterceptorRegistry.js","./lib/choreographies/swarm":"/opt/privatesky/modules/callflow/lib/choreographies/swarm.js","./lib/choreographies/swarmInstancesManager":"/opt/privatesky/modules/callflow/lib/choreographies/swarmInstancesManager.js","./lib/loadLibrary":"/opt/privatesky/modules/callflow/lib/loadLibrary.js","./lib/overwriteRequire":"/opt/privatesky/modules/callflow/lib/overwriteRequire.js","./lib/parallelJoinPoint":"/opt/privatesky/modules/callflow/lib/parallelJoinPoint.js","./lib/serialJoinPoint":"/opt/privatesky/modules/callflow/lib/serialJoinPoint.js","./lib/swarmDescription":"/opt/privatesky/modules/callflow/lib/swarmDescription.js","./lib/utilityFunctions/asset":"/opt/privatesky/modules/callflow/lib/utilityFunctions/asset.js","./lib/utilityFunctions/transaction":"/opt/privatesky/modules/callflow/lib/utilityFunctions/transaction.js","crypto":"crypto","path":"path","soundpubsub":"soundpubsub"}],"dicontainer":[function(require,module,exports){
if(typeof singleton_container_module_workaround_for_wired_node_js_caching == 'undefined') {
    singleton_container_module_workaround_for_wired_node_js_caching   = module;
} else {
    module.exports = singleton_container_module_workaround_for_wired_node_js_caching .exports;
    return module;
}

/**
 * Created by salboaie on 4/27/15.
 */
function Container(errorHandler){
    var things = {};        //the actual values for our services, things
    var immediate = {};     //how dependencies were declared
    var callbacks = {};     //callback that should be called for each dependency declaration
    var depsCounter = {};   //count dependencies
    var reversedTree = {};  //reversed dependencies, opposite of immediate object

     this.dump = function(){
         console.log("Conatiner dump\n Things:", things, "\nDeps counter: ", depsCounter, "\nStright:", immediate, "\nReversed:", reversedTree);
     };

    function incCounter(name){
        if(!depsCounter[name]){
            depsCounter[name] = 1;
        } else {
            depsCounter[name]++;
        }
    }

    function insertDependencyinRT(nodeName, dependencies){
        dependencies.forEach(function(itemName){
            var l = reversedTree[itemName];
            if(!l){
                l = reversedTree[itemName] = {};
            }
            l[nodeName] = nodeName;
        });
    }


    function discoverUpNodes(nodeName){
        var res = {};

        function DFS(nn){
            var l = reversedTree[nn];
            for(var i in l){
                if(!res[i]){
                    res[i] = true;
                    DFS(i);
                }
            }
        }

        DFS(nodeName);
        return Object.keys(res);
    }

    function resetCounter(name){
        var dependencyArray = immediate[name];
        var counter = 0;
        if(dependencyArray){
            dependencyArray.forEach(function(dep){
                if(things[dep] == null){
                    incCounter(name);
                    counter++;
                }
            });
        }
        depsCounter[name] = counter;
        //console.log("Counter for ", name, ' is ', counter);
        return counter;
    }

    /* returns those that are ready to be resolved*/
    function resetUpCounters(name){
        var ret = [];
        //console.log('Reseting up counters for ', name, "Reverse:", reversedTree[name]);
        var ups = reversedTree[name];
        for(var v in ups){
            if(resetCounter(v) === 0){
                ret.push(v);
            }
        }
        return ret;
    }

    /*
         The first argument is a name for a service, variable,a  thing that should be initialised, recreated, etc
         The second argument is an array with dependencies
         the last argument is a function(err,...) that is called when dependencies are ready or recalled when are not ready (stop was called)
         If err is not undefined it means that one or any undefined variables are not ready and the callback will be called again later
         All the other arguments are the corresponding arguments of the callback will be the actual values of the corresponding dependency
         The callback functions should return the current value (or null)
     */
    this.declareDependency = function(name, dependencyArray, callback){
        if(callbacks[name]){
            errorHandler.ignorePossibleError("Duplicate dependency:" + name);
        } else {
            callbacks[name] = callback;
            immediate[name]   = dependencyArray;
            insertDependencyinRT(name, dependencyArray);
            things[name] = null;
        }

        var unsatisfiedCounter = resetCounter(name);
        if(unsatisfiedCounter === 0 ){
            callForThing(name, false);
        } else {
            callForThing(name, true);
        }
    };


    /*
        create a service
     */
    this.service = function(name, dependencyArray, constructor){
        this.declareDependency(name, dependencyArray, constructor);
    };


    var subsystemCounter = 0;
    /*
     create a anonymous subsystem
     */
    this.subsystem = function(dependencyArray, constructor){
        subsystemCounter++;
        this.declareDependency("dicontainer_subsystem_placeholder" + subsystemCounter, dependencyArray, constructor);
    };

    /* not documented.. limbo state*/
    this.factory = function(name, dependencyArray, constructor){
        this.declareDependency(name, dependencyArray, function(){
            return new constructor();
        });
    };

    function callForThing(name, outOfService){
        var args = immediate[name].map(function(item){
            return things[item];
        });
        args.unshift(outOfService);
        try{
            var value = callbacks[name].apply({},args);
        } catch(err){
            errorHandler.throwError(err);
        }


        if(outOfService || value===null){   //enable returning a temporary dependency resolution!
            if(things[name]){
                things[name] = null;
                resetUpCounters(name);
            }
        } else {
            //console.log("Success resolving ", name, ":", value, "Other ready:", otherReady);
            if(!value){
                value =  {"placeholder": name};
            }
            things[name] = value;
            var otherReady = resetUpCounters(name);
            otherReady.forEach(function(item){
                callForThing(item, false);
            });
        }
    }

    /*
        Declare that a name is ready, resolved and should try to resolve all other waiting for it
     */
    this.resolve    = function(name, value){
        things[name] = value;
        var otherReady = resetUpCounters(name);

        otherReady.forEach(function(item){
            callForThing(item, false);
        });
    };



    this.instanceFactory = function(name, dependencyArray, constructor){
        errorHandler.notImplemented("instanceFactory is planned but not implemented");
    };

    /*
        Declare that a service or feature is not working properly. All services depending on this will get notified
     */
    this.outOfService    = function(name){
        things[name] = null;
        var upNodes = discoverUpNodes(name);
        upNodes.forEach(function(node){
            things[name] = null;
            callForThing(node, true);
        });
    };
}


exports.newContainer    = function(checksLibrary){
    return new Container(checksLibrary);
};

//exports.container = new Container($$.errorHandler);
},{}],"domainBase":[function(require,module,exports){
exports.domainPubSub = require("./domainPubSub");
},{"./domainPubSub":"/opt/privatesky/libraries/domainBase/domainPubSub.js"}],"double-check":[function(require,module,exports){

/**
 * Generic function used to registers methods such as asserts, logging, etc. on the current context.
 * @param name {String)} - name of the method (use case) to be registered.
 * @param func {Function} - handler to be invoked.
 * @param paramsDescription {Object} - parameters descriptions
 * @param after {Function} - callback function to be called after the function has been executed.
 */
function addUseCase(name, func, paramsDescription, after){
    var newFunc = func;
    if(typeof after === "function") {
        newFunc = function(){
            const args = Array.from(arguments);
            func.apply(this, args);
            after();
        };
    }

    // some properties should not be overridden
    const protectedProperties = [ 'addCheck', 'addCase', 'register' ];
    if(protectedProperties.indexOf(name) === -1){
        this[name] = newFunc;
    } else {
        throw new Error('Cant overwrite ' + name);
    }

    if(paramsDescription){
        this.params[name] = paramsDescription;
    }
}

/**
 * Creates an alias to an existing function.
 * @param name1 {String} - New function name.
 * @param name2 {String} - Existing function name.
 */
function alias(name1, name2){
    this[name1] = this[name2];
}

/**
 * Singleton for adding various functions for use cases regarding logging.
 * @constructor
 */
function LogsCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for asserts.
 * @constructor
 */
function AssertCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for checks.
 * @constructor
 */
function CheckCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for generating exceptions.
 * @constructor
 */
function ExceptionsCore(){
    this.params = {};
}

/**
 * Singleton for adding your various functions for running tests.
 * @constructor
 */
function TestRunnerCore(){
}

LogsCore.prototype.addCase           = addUseCase;
AssertCore.prototype.addCheck        = addUseCase;
CheckCore.prototype.addCheck         = addUseCase;
ExceptionsCore.prototype.register    = addUseCase;

LogsCore.prototype.alias             = alias;
AssertCore.prototype.alias           = alias;
CheckCore.prototype.alias            = alias;
ExceptionsCore.prototype.alias       = alias;

// Create modules
var assertObj       = new AssertCore();
var checkObj        = new CheckCore();
var exceptionsObj   = new ExceptionsCore();
var loggerObj       = new LogsCore();
var testRunnerObj   = new TestRunnerCore();

// Export modules
exports.assert      = assertObj;
exports.check       = checkObj;
exports.exceptions  = exceptionsObj;
exports.logger      = loggerObj;
exports.testRunner  = testRunnerObj;

// Initialise modules
require("./standardAsserts.js").init(exports, loggerObj);
require("./standardLogs.js").init(exports);
require("./standardExceptions.js").init(exports);
require("./standardChecks.js").init(exports);
require("./testRunner.js").init(exports);

// Global Uncaught Exception handler.
if(process.on)
{
    process.on('uncaughtException', function (err) {
		const tag = "uncaughtException";
		console.log(tag, err);
		console.log(tag, err.stack);
	});
}
},{"./standardAsserts.js":"/opt/privatesky/modules/double-check/lib/standardAsserts.js","./standardChecks.js":"/opt/privatesky/modules/double-check/lib/standardChecks.js","./standardExceptions.js":"/opt/privatesky/modules/double-check/lib/standardExceptions.js","./standardLogs.js":"/opt/privatesky/modules/double-check/lib/standardLogs.js","./testRunner.js":"/opt/privatesky/modules/double-check/lib/testRunner.js"}],"foldermq":[function(require,module,exports){
module.exports = {
					createQue: require("./lib/folderMQ").getFolderQueue
					//folderMQ: require("./lib/folderMQ")
};
},{"./lib/folderMQ":"/opt/privatesky/modules/foldermq/lib/folderMQ.js"}],"launcher":[function(require,module,exports){
//console.log(require.resolve("./components.js"));
module.exports = $$.library(function(){
	require("./components.js");
	/*require("./mkDirRec.js");*/
})
},{"./components.js":"/opt/privatesky/libraries/launcher/components.js"}],"pskbuffer":[function(require,module,exports){
const PSKBuffer = require('./lib/PSKBuffer');

module.exports = PSKBuffer;

},{"./lib/PSKBuffer":"/opt/privatesky/modules/pskbuffer/lib/PSKBuffer.js"}],"pskcrypto":[function(require,module,exports){
const PskCrypto = require("./lib/PskCrypto");
const ssutil = require("./signsensusDS/ssutil");

module.exports = PskCrypto;

module.exports.hashValues = ssutil.hashValues;

if(typeof(___DISABLE_OBSOLETE_ZIP_ARCHIVER_WAIT_FOR_BARS) === 'undefined'){
    module.exports.PskArchiver = require("./lib/psk-archiver");
}

module.exports.DuplexStream = require("./lib/utils/DuplexStream");

module.exports.isStream = require("./lib/utils/isStream");
},{"./lib/PskCrypto":"/opt/privatesky/modules/pskcrypto/lib/PskCrypto.js","./lib/psk-archiver":"/opt/privatesky/modules/pskcrypto/lib/psk-archiver.js","./lib/utils/DuplexStream":"/opt/privatesky/modules/pskcrypto/lib/utils/DuplexStream.js","./lib/utils/isStream":"/opt/privatesky/modules/pskcrypto/lib/utils/isStream.js","./signsensusDS/ssutil":"/opt/privatesky/modules/pskcrypto/signsensusDS/ssutil.js"}],"psklogger":[function(require,module,exports){
(function (global){
const PSKLogger = require('./src/PSKLoggerClient/index');
const EnvironmentDataProvider = require('./src/utils').EnvironmentDataProvider;


if(!global.hasOwnProperty('$$')) {
    global.$$ = {};
}


/**
 * @deprecated
 * PSKLogger should be used as is without overwriting console.
 * The functionality should be added to PSKLogger to log to console the message and useful metadata
 */
function overwriteConsole() {
    if(process.env.context === 'sandbox') {
        console.log("Execution detected in sandbox, console won't be overwritten");
        return;
    }

    const logger = PSKLogger.getLogger();

    const originalConsole = {};
    Object.keys(console).forEach(key => originalConsole[key] = console[key]);

    Object.keys(logger).forEach(key => {
       console[key] = function() {
           const log = logger[key].apply(logger, arguments);

           const context = getContextForMeta(log.meta);

           if(originalConsole.hasOwnProperty(key)) {
               originalConsole[key].apply(originalConsole, [`[${context}]`, ...log.messages]);
           }
       }
    });


    /**
     * @return {string|*}
     */
    function getContextForMeta(meta) {
        const contexts = {
            node: (meta) => `node:${meta.context}`,
            domain: (meta) =>`domain:${meta.domain}`,
            agent: (meta) => `domain:${meta.domain}:agent:${meta.agent}`,
            sandbox: () => `sandbox`
        };

        if (contexts.hasOwnProperty(meta.origin)) {
            return contexts[meta.origin](meta);
        } else {
            return '';
        }
    }
}

if (process.env.context !== 'sandbox') {

    const MessagePublisher = require('./src/MessagePublisher');
    const MessageSubscriber = require('./src/MessageSubscriber');
    const PubSubProxy = require('./src/PubSubProxy');

    function enableEnvironmentDataDefault() {
        global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentData;
    }

    function enableEnvironmentDataForAgent() {
        global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentDataForAgent;
    }

    function enableEnvironmentDataForDomain() {
        global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentDataForDomain;
    }


    /**
     * Overwrite this to provide relevant information for other environments (ex: for domains, browser etc.)
     */
    if(process.env.hasOwnProperty('PRIVATESKY_AGENT_NAME')) {
        enableEnvironmentDataForAgent();
    } else if(process.env.hasOwnProperty('PRIVATESKY_DOMAIN_NAME')) {
        enableEnvironmentDataForDomain()
    } else if(!global.$$.hasOwnProperty('getEnvironmentData')) {
        enableEnvironmentDataDefault();
    }

    module.exports.MessagePublisherModule  = MessagePublisher;
    module.exports.MessageSubscriberModule = MessageSubscriber;
    module.exports.PubSubProxyModule       = PubSubProxy;
} else {
    global.$$.getEnvironmentData = EnvironmentDataProvider.getEnvironmentDataForSandbox;
}


module.exports.overwriteConsole = overwriteConsole;
module.exports.PSKLogger = PSKLogger;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./src/MessagePublisher":"/opt/privatesky/modules/psklogger/src/MessagePublisher/index.js","./src/MessageSubscriber":"/opt/privatesky/modules/psklogger/src/MessageSubscriber/index.js","./src/PSKLoggerClient/index":"/opt/privatesky/modules/psklogger/src/PSKLoggerClient/index.js","./src/PubSubProxy":"/opt/privatesky/modules/psklogger/src/PubSubProxy/index.js","./src/utils":"/opt/privatesky/modules/psklogger/src/utils/index.js"}],"soundpubsub":[function(require,module,exports){
module.exports = {
					soundPubSub: require("./lib/soundPubSub").soundPubSub
};
},{"./lib/soundPubSub":"/opt/privatesky/modules/soundpubsub/lib/soundPubSub.js"}],"swarmutils":[function(require,module,exports){
(function (global){
module.exports.OwM = require("./lib/OwM");
module.exports.beesHealer = require("./lib/beesHealer");

const uidGenerator = require("./lib/uidGenerator").createUidGenerator(200, 32);

module.exports.safe_uuid = require("./lib/safe-uuid").init(uidGenerator);

module.exports.Queue = require("./lib/Queue");
module.exports.combos = require("./lib/Combos");

module.exports.uidGenerator = uidGenerator;
module.exports.generateUid = uidGenerator.generateUid;

module.exports.createPskConsole = function () {
  return require('./lib/pskconsole');
};


if(typeof global.$$ == "undefined"){
  global.$$ = {};
}

if(typeof global.$$.uidGenerator == "undefined"){
    $$.uidGenerator = module.exports.safe_uuid;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/Combos":"/opt/privatesky/modules/swarmutils/lib/Combos.js","./lib/OwM":"/opt/privatesky/modules/swarmutils/lib/OwM.js","./lib/Queue":"/opt/privatesky/modules/swarmutils/lib/Queue.js","./lib/beesHealer":"/opt/privatesky/modules/swarmutils/lib/beesHealer.js","./lib/pskconsole":"/opt/privatesky/modules/swarmutils/lib/pskconsole.js","./lib/safe-uuid":"/opt/privatesky/modules/swarmutils/lib/safe-uuid.js","./lib/uidGenerator":"/opt/privatesky/modules/swarmutils/lib/uidGenerator.js"}],"utils":[function(require,module,exports){
exports.fsExt = require("./FSExtension").fsExt;
},{"./FSExtension":"/opt/privatesky/libraries/utils/FSExtension.js"}]},{},["/opt/privatesky/builds/tmp/pskruntime.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZHMvdG1wL3Bza3J1bnRpbWUuanMiLCJidWlsZHMvdG1wL3Bza3J1bnRpbWVfaW50ZXJtZWRpYXIuanMiLCJsaWJyYXJpZXMvZG9tYWluQmFzZS9kb21haW5QdWJTdWIuanMiLCJsaWJyYXJpZXMvbGF1bmNoZXIvY29tcG9uZW50cy5qcyIsImxpYnJhcmllcy91dGlscy9GU0V4dGVuc2lvbi5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvY29uc3RhbnRzLmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvSW50ZXJjZXB0b3JSZWdpc3RyeS5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL2Nob3Jlb2dyYXBoaWVzL1N3YXJtRGVidWcuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi9jaG9yZW9ncmFwaGllcy9zd2FybS5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL2Nob3Jlb2dyYXBoaWVzL3N3YXJtSW5zdGFuY2VzTWFuYWdlci5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL2xvYWRMaWJyYXJ5LmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvb3ZlcndyaXRlUmVxdWlyZS5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL3BhcmFsbGVsSm9pblBvaW50LmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvc2VyaWFsSm9pblBvaW50LmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvc3dhcm1EZXNjcmlwdGlvbi5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvbGliL3V0aWxpdHlGdW5jdGlvbnMvYXNzZXQuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi91dGlsaXR5RnVuY3Rpb25zL2Jhc2UuanMiLCJtb2R1bGVzL2NhbGxmbG93L2xpYi91dGlsaXR5RnVuY3Rpb25zL2NhbGxmbG93LmpzIiwibW9kdWxlcy9jYWxsZmxvdy9saWIvdXRpbGl0eUZ1bmN0aW9ucy90cmFuc2FjdGlvbi5qcyIsIm1vZHVsZXMvY2FsbGZsb3cvc3RhbmRhcmRHbG9iYWxTeW1ib2xzLmpzIiwibW9kdWxlcy9kb3VibGUtY2hlY2svbGliL3N0YW5kYXJkQXNzZXJ0cy5qcyIsIm1vZHVsZXMvZG91YmxlLWNoZWNrL2xpYi9zdGFuZGFyZENoZWNrcy5qcyIsIm1vZHVsZXMvZG91YmxlLWNoZWNrL2xpYi9zdGFuZGFyZEV4Y2VwdGlvbnMuanMiLCJtb2R1bGVzL2RvdWJsZS1jaGVjay9saWIvc3RhbmRhcmRMb2dzLmpzIiwibW9kdWxlcy9kb3VibGUtY2hlY2svbGliL3Rlc3RSdW5uZXIuanMiLCJtb2R1bGVzL2RvdWJsZS1jaGVjay9saWIvdXRpbHMvZ2xvYi10by1yZWdleHAuanMiLCJtb2R1bGVzL2ZvbGRlcm1xL2xpYi9mb2xkZXJNUS5qcyIsIm1vZHVsZXMvcHNrYnVmZmVyL2xpYi9QU0tCdWZmZXIuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvRUNEU0EuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvUHNrQ3J5cHRvLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvYXBpLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvYXNuMS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2Jhc2UvYnVmZmVyLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvYmFzZS9pbmRleC5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2Jhc2Uvbm9kZS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2Jhc2UvcmVwb3J0ZXIuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9iaWdudW0vYm4uanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvZGVjb2RlcnMvZGVyLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL2FzbjEvZGVjb2RlcnMvaW5kZXguanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9kZWNvZGVycy9wZW0uanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9lbmNvZGVycy9kZXIuanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9hc24xL2VuY29kZXJzL3BlbS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi9rZXlFbmNvZGVyLmpzIiwibW9kdWxlcy9wc2tjcnlwdG8vbGliL3Bzay1hcmNoaXZlci5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi91dGlscy9EdXBsZXhTdHJlYW0uanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvdXRpbHMvUGFzc1Rocm91Z2hTdHJlYW0uanMiLCJtb2R1bGVzL3Bza2NyeXB0by9saWIvdXRpbHMvY291bnRGaWxlcy5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi91dGlscy9jcnlwdG9VdGlscy5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2xpYi91dGlscy9pc1N0cmVhbS5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL3NpZ25zZW5zdXNEUy9zc3V0aWwuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvTG9nZ2VyQ2xpZW50L0dlbmVyaWNMb2dnZXJDbGllbnQuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvTG9nZ2VyQ2xpZW50L0xvZ0ZhY3RvcnkuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvTG9nZ2VyQ2xpZW50L0xvZ2dlckNsaWVudC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9Mb2dnZXJDbGllbnQvTG9nZ2VySW50ZXJmYWNlLmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL0xvZ2dlckNsaWVudC9pbmRleC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9NZXNzYWdlUHVibGlzaGVyL01lc3NhZ2VQdWJsaXNoZXIuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvTWVzc2FnZVB1Ymxpc2hlci9NZXNzYWdlUHVibGlzaGVyRm9yU2FuZGJveC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9NZXNzYWdlUHVibGlzaGVyL1RyYW5zcG9ydEludGVyZmFjZS5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9NZXNzYWdlUHVibGlzaGVyL2luZGV4LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL01lc3NhZ2VTdWJzY3JpYmVyL01lc3NhZ2VTdWJzY3JpYmVyLmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL01lc3NhZ2VTdWJzY3JpYmVyL2luZGV4LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL1BTS0xvZ2dlckNsaWVudC9HZW5lcmljUFNLTG9nZ2VyLmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvc3JjL1BTS0xvZ2dlckNsaWVudC9pbmRleC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9QdWJTdWJQcm94eS9QdWJTdWJQcm94eS5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy9QdWJTdWJQcm94eS9pbmRleC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy91dGlscy9CdWZmZXJlZFNvY2tldC5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy91dGlscy9Db25maWd1cmF0b3IuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvdXRpbHMvRW52aXJvbm1lbnREYXRhUHJvdmlkZXIuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvdXRpbHMvTG9nTGV2ZWwuanMiLCJtb2R1bGVzL3Bza2xvZ2dlci9zcmMvdXRpbHMvU29ja2V0VHlwZS5qcyIsIm1vZHVsZXMvcHNrbG9nZ2VyL3NyYy91dGlscy9pbmRleC5qcyIsIm1vZHVsZXMvc291bmRwdWJzdWIvbGliL3NvdW5kUHViU3ViLmpzIiwibW9kdWxlcy9zd2FybXV0aWxzL2xpYi9Db21ib3MuanMiLCJtb2R1bGVzL3N3YXJtdXRpbHMvbGliL093TS5qcyIsIm1vZHVsZXMvc3dhcm11dGlscy9saWIvUXVldWUuanMiLCJtb2R1bGVzL3N3YXJtdXRpbHMvbGliL2JlZXNIZWFsZXIuanMiLCJtb2R1bGVzL3N3YXJtdXRpbHMvbGliL3Bza2NvbnNvbGUuanMiLCJtb2R1bGVzL3N3YXJtdXRpbHMvbGliL3NhZmUtdXVpZC5qcyIsIm1vZHVsZXMvc3dhcm11dGlscy9saWIvdWlkR2VuZXJhdG9yLmpzIiwicHNrbm9kZS9jb3JlL3NhbmRib3hlcy91dGlsL1NhbmRCb3hNYW5hZ2VyLmpzIiwicHNrbm9kZS9jb3JlL3V0aWxzL2V4aXRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svZGlzdC5lczUvbXNncGFjay5taW4uanMiLCJtb2R1bGVzL2NhbGxmbG93L2luZGV4LmpzIiwibW9kdWxlcy9kaWNvbnRhaW5lci9saWIvY29udGFpbmVyLmpzIiwibGlicmFyaWVzL2RvbWFpbkJhc2UvaW5kZXguanMiLCJtb2R1bGVzL2RvdWJsZS1jaGVjay9saWIvY2hlY2tzQ29yZS5qcyIsIm1vZHVsZXMvZm9sZGVybXEvaW5kZXguanMiLCJsaWJyYXJpZXMvbGF1bmNoZXIvaW5kZXguanMiLCJtb2R1bGVzL3Bza2J1ZmZlci9pbmRleC5qcyIsIm1vZHVsZXMvcHNrY3J5cHRvL2luZGV4LmpzIiwibW9kdWxlcy9wc2tsb2dnZXIvaW5kZXguanMiLCJtb2R1bGVzL3NvdW5kcHVic3ViL2luZGV4LmpzIiwibW9kdWxlcy9zd2FybXV0aWxzL2luZGV4LmpzIiwibGlicmFyaWVzL3V0aWxzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakdBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pCQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsInJlcXVpcmUoXCIuLi8uLi9tb2R1bGVzL2NhbGxmbG93L2xpYi9vdmVyd3JpdGVSZXF1aXJlXCIpXG5cbnJlcXVpcmUoXCIuL3Bza3J1bnRpbWVfaW50ZXJtZWRpYXJcIik7XG5cbnJlcXVpcmUoXCJjYWxsZmxvd1wiKTtcblxuY29uc29sZS5sb2coXCJMb2FkaW5nIHJ1bnRpbWU6IGNhbGxmbG93IG1vZHVsZSByZWFkeVwiKTsiLCJnbG9iYWwucHNrcnVudGltZUxvYWRNb2R1bGVzID0gZnVuY3Rpb24oKXsgXG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJjYWxsZmxvd1wiXSA9IHJlcXVpcmUoXCJjYWxsZmxvd1wiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcImxhdW5jaGVyXCJdID0gcmVxdWlyZShcImxhdW5jaGVyXCIpO1xuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1wiZG91YmxlLWNoZWNrXCJdID0gcmVxdWlyZShcImRvdWJsZS1jaGVja1wiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcInBza2NyeXB0b1wiXSA9IHJlcXVpcmUoXCJwc2tjcnlwdG9cIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJkaWNvbnRhaW5lclwiXSA9IHJlcXVpcmUoXCJkaWNvbnRhaW5lclwiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcInN3YXJtdXRpbHNcIl0gPSByZXF1aXJlKFwic3dhcm11dGlsc1wiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcInNvdW5kcHVic3ViXCJdID0gcmVxdWlyZShcInNvdW5kcHVic3ViXCIpO1xuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1wicHNrYnVmZmVyXCJdID0gcmVxdWlyZShcInBza2J1ZmZlclwiKTtcblx0JCQuX19ydW50aW1lTW9kdWxlc1tcImZvbGRlcm1xXCJdID0gcmVxdWlyZShcImZvbGRlcm1xXCIpO1xuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1wiZG9tYWluQmFzZVwiXSA9IHJlcXVpcmUoXCJkb21haW5CYXNlXCIpO1xuXHQkJC5fX3J1bnRpbWVNb2R1bGVzW1widXRpbHNcIl0gPSByZXF1aXJlKFwidXRpbHNcIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJAbXNncGFjay9tc2dwYWNrXCJdID0gcmVxdWlyZShcIkBtc2dwYWNrL21zZ3BhY2tcIik7XG5cdCQkLl9fcnVudGltZU1vZHVsZXNbXCJwc2tsb2dnZXJcIl0gPSByZXF1aXJlKFwicHNrbG9nZ2VyXCIpO1xufVxuaWYgKGZhbHNlKSB7XG5cdHBza3J1bnRpbWVMb2FkTW9kdWxlcygpO1xufTsgXG5nbG9iYWwucHNrcnVudGltZVJlcXVpcmUgPSByZXF1aXJlO1xuaWYgKHR5cGVvZiAkJCAhPT0gXCJ1bmRlZmluZWRcIikgeyAgICAgICAgICAgIFxuICAgICQkLnJlcXVpcmVCdW5kbGUoXCJwc2tydW50aW1lXCIpO1xufTsiLCJ2YXIgcHViU3ViID0gJCQucmVxdWlyZShcInNvdW5kcHVic3ViXCIpLnNvdW5kUHViU3ViO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oZm9sZGVyLCBjb2RlRm9sZGVyICl7XG5cbiAgICAkJC5QU0tfUHViU3ViID0gcHViU3ViO1xuICAgIHZhciBzYW5kQm94ZXNSb290ID0gcGF0aC5qb2luKGZvbGRlciwgXCJzYW5kYm94ZXNcIik7XG5cbiAgICB0cnl7XG4gICAgICAgIGZzLm1rZGlyU3luYyhzYW5kQm94ZXNSb290LCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gICAgfWNhdGNoKGVycil7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGNyZWF0ZSBzYW5kYm94ZXMgZGlyIHN0cnVjdHVyZSFcIiwgZXJyKTtcbiAgICAgICAgLy9UT0RPOiBtYXliZSBpdCBpcyBvayB0byBjYWxsIHByb2Nlc3MuZXhpdCA/Pz9cbiAgICB9XG5cbiAgICAkJC5TYW5kQm94TWFuYWdlciA9IHJlcXVpcmUoXCIuLi8uLi9wc2tub2RlL2NvcmUvc2FuZGJveGVzL3V0aWwvU2FuZEJveE1hbmFnZXJcIikuY3JlYXRlKHNhbmRCb3hlc1Jvb3QsIGNvZGVGb2xkZXIsIGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgICAgICAgY29uc29sZS5sb2coJCQuRElfY29tcG9uZW50cy5zYW5kQm94UmVhZHksIGVyciwgcmVzKTtcbiAgICAgICAgJCQuY29udGFpbmVyLnJlc29sdmUoJCQuRElfY29tcG9uZW50cy5zYW5kQm94UmVhZHksIHRydWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHB1YlN1Yjtcbn07XG4iLCIkJC5ESV9jb21wb25lbnRzID0ge1xuICAgc3dhcm1Jc1JlYWR5OlwiU3dhcm1Jc1JlYWR5XCIsXG4gICBjb25maWdMb2FkZWQ6XCJjb25maWdMb2FkZWRcIixcbiAgIHNhbmRCb3hSZWFkeTpcIlNhbmRCb3hSZWFkeVwiLFxuICAgbG9jYWxOb2RlQVBJczpcImxvY2FsTm9kZUFQSXNcIlxufVxuIiwiY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gaWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGxvZ3Mgd2lsbCBiZSBhdmFpbGFibGUuIERlZmF1bHQgKGZhbHNlKVxuY29uc3QgREVCVUcgPSAgcHJvY2Vzcy5lbnYuREVQTE9ZRVJfREVCVUcgfHwgZmFsc2U7XG5cbmZ1bmN0aW9uIEZTRXh0ZW50aW9uKCl7XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIHBhdGggdXNlZCB0byByZXNvbHZlIGFsbCByZWxhdGl2ZSBwYXRocyBpbiB0aGUgYWN0aW9ucyBiZWxsb3cuXG4gICAgICogRGVmYXVsdCBpcyBzZXQgdG8gdHdvIGxldmVscyB1cCBmcm9tIHRoZSBjdXJyZW50IGRpcmVjdG9yeS4gVGhpcyBjYW4gYmUgY2hhbmdlZCB1c2luZyBfX3NldEJhc2VQYXRoLlxuICAgICAqIEB0eXBlIHsqfHN0cmluZ31cbiAgICAgKi9cbiAgICB2YXIgYmFzZVBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uLy4uL1wiKTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYmFzZSBwYXRoIHRvIGEgZGlmZmVyZW50IGFic29sdXRlIGRpcmVjdG9yeSBwYXRoLlxuICAgICAqIEBwYXJhbSB3ZCB7U3RyaW5nfSBhYnNvbHV0ZSBkaXJlY3RvcnkgcGF0aC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhciBfX3NldEJhc2VQYXRoID0gZnVuY3Rpb24od2QpIHtcbiAgICAgICAgYmFzZVBhdGggPSBwYXRoLnJlc29sdmUod2QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgcGF0aCBpbnRvIGFuIGFic29sdXRlIHBhdGguIElmIGZpbGVQYXRoIGlzIHJlbGF0aXZlLCB0aGUgcGF0aCBpcyByZXNvbHZlZCB1c2luZyB0aGUgYmFzZVBhdGggYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHtTdHJpbmd9IHJlbGF0aXZlIG9yIGFic29sdXRlIGZpbGUgcGF0aC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBhYnNvbHV0ZSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19yZXNvbHZlUGF0aCA9IGZ1bmN0aW9uKGZpbGVQYXRoKSB7XG4gICAgICAgIGlmKHBhdGguaXNBYnNvbHV0ZShmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoLnJlc29sdmUoYmFzZVBhdGgsIGZpbGVQYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZGlyZWN0b3J5IHN0cnVjdHVyZSBkb2VzIG5vdCBleGlzdCwgaXQgaXMgY3JlYXRlZC4gTGlrZSBta2RpciAtcFxuICAgICAqIEBwYXJhbSBkaXIge1N0cmluZ30gZGlyIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhciBfX2NyZWF0ZURpciA9IGZ1bmN0aW9uKGRpcikge1xuICAgICAgICBkaXIgPSBfX3Jlc29sdmVQYXRoKGRpcik7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICAgICAgICAgIGxvZyhkaXIgKyBcIiBhbHJlYWR5IGV4aXN0ISBDb250aW51aW5nIC4uLlwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzV2luID0gKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicpO1xuICAgICAgICB2YXIgY21kID0gaXNXaW4gPyBcIm1rZGlyIFwiIDogXCJta2RpciAtcCBcIjtcblxuICAgICAgICBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKGNtZCArIFwiXFxcIlwiK2RpcitcIlxcXCJcIiwge3N0ZGlvOlswLDEsMl19KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgZmlsZSBvciBkaXJlY3RvcnkuIFRoZSBkaXJlY3RvcnkgY2FuIGhhdmUgcmVjdXJzaXZlIGNvbnRlbnRzLiBMaWtlIGNvcHkgLXIuXG4gICAgICogTk9URTogSWYgc3JjIGlzIGEgZGlyZWN0b3J5IGl0IHdpbGwgY29weSBldmVyeXRoaW5nIGluc2lkZSBvZiB0aGUgZGlyZWN0b3J5LCBub3QgdGhlIGVudGlyZSBkaXJlY3RvcnkgaXRzZWxmLlxuICAgICAqIE5PVEU6IElmIHNyYyBpcyBhIGZpbGUsIHRhcmdldCBjYW5ub3QgYmUgYSBkaXJlY3RvcnkuXG4gICAgICogTk9URTogSWYgdGhlIGRlc3RpbmF0aW9uIHBhdGggc3RydWN0dXJlIGRvZXMgbm90IGV4aXN0cywgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSBzcmMge1N0cmluZ30gU291cmNlIGZpbGV8ZGlyZWN0b3J5IHBhdGguXG4gICAgICogQHBhcmFtIGRlc3Qge1N0cmluZ30gRGVzdGluYXRpb24gZmlsZXxkaXJlY3RvcnkgcGF0aC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBjb3B5IGFjdGlvbi4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAgICogIC0gb3ZlcndyaXRlIDxCb29sZWFuPjogb3ZlcndyaXRlIGV4aXN0aW5nIGZpbGUgb3IgZGlyZWN0b3J5LCBkZWZhdWx0IGlzIHRydWUuXG4gICAgICogIE5vdGUgdGhhdCB0aGUgY29weSBvcGVyYXRpb24gd2lsbCBzaWxlbnRseSBmYWlsIGlmIHRoaXMgaXMgc2V0IHRvIGZhbHNlIGFuZCB0aGUgZGVzdGluYXRpb24gZXhpc3RzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19jb3B5ID0gZnVuY3Rpb24gKHNyYywgZGVzdCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgc3JjID0gX19yZXNvbHZlUGF0aChzcmMpO1xuICAgICAgICBkZXN0ID0gX19yZXNvbHZlUGF0aChkZXN0KTtcblxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgbGV0IHJldGhyb3cgPSBmYWxzZTtcblxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc3JjKSkge1xuICAgICAgICAgICAgICAgIHJldGhyb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGBTb3VyY2UgZGlyZWN0b3J5IG9yIGZpbGUgXCIke3NyY31cIiBkb2VzIG5vdCBleGlzdHMhYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNyY1N0YXQgPSBmcy5sc3RhdFN5bmMoc3JjKTtcbiAgICAgICAgICAgIGlmKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIF9fY29weURpcihzcmMsIGRlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHNyY1N0YXQuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBkZXN0aW5hdGlvbiBtdXN0IGJlIGEgZmlsZSB0b29cbiAgICAgICAgICAgICAgICBfX2NvcHlGaWxlKHNyYywgZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYocmV0aHJvdyl7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nKGVyciwgdHJ1ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgZGlyZWN0b3J5LiBUaGUgZGlyZWN0b3J5IGNhbiBoYXZlIHJlY3Vyc2l2ZSBjb250ZW50cy4gTGlrZSBjb3B5IC1yLlxuICAgICAqIE5PVEU6IEl0dCB3aWxsIGNvcHkgZXZlcnl0aGluZyBpbnNpZGUgb2YgdGhlIGRpcmVjdG9yeSwgbm90IHRoZSBlbnRpcmUgZGlyZWN0b3J5IGl0c2VsZi5cbiAgICAgKiBOT1RFOiBJZiB0aGUgZGVzdGluYXRpb24gcGF0aCBzdHJ1Y3R1cmUgZG9lcyBub3QgZXhpc3RzLCBpdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHNyYyB7U3RyaW5nfSBTb3VyY2UgZGlyZWN0b3J5IHBhdGguXG4gICAgICogQHBhcmFtIGRlc3Qge1N0cmluZ30gRGVzdGluYXRpb24gZGlyZWN0b3J5IHBhdGguXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgY29weSBhY3Rpb24uIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgICAqICAtIG92ZXJ3cml0ZSA8Qm9vbGVhbj46IG92ZXJ3cml0ZSBleGlzdGluZyBkaXJlY3RvcnksIGRlZmF1bHQgaXMgdHJ1ZS5cbiAgICAgKiAgTm90ZSB0aGF0IHRoZSBjb3B5IG9wZXJhdGlvbiB3aWxsIHNpbGVudGx5IGZhaWwgaWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UgYW5kIHRoZSBkZXN0aW5hdGlvbiBleGlzdHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19jb3B5RGlyID0gZnVuY3Rpb24oc3JjLCBkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHNyYyA9IF9fcmVzb2x2ZVBhdGgoc3JjKTtcbiAgICAgICAgZGVzdCA9IF9fcmVzb2x2ZVBhdGgoZGVzdCk7XG5cbiAgICAgICAgX19jcmVhdGVEaXIoZGVzdCk7XG5cbiAgICAgICAgdmFyIGZpbGVzID0gZnMucmVhZGRpclN5bmMoc3JjKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGZzLmxzdGF0U3luYyhwYXRoLmpvaW4oc3JjLCBmaWxlc1tpXSkpO1xuICAgICAgICAgICAgbGV0IG5ld1NyYyA9IHBhdGguam9pbihzcmMsIGZpbGVzW2ldKTtcbiAgICAgICAgICAgIGxldCBuZXdEZXN0ID0gcGF0aC5qb2luKGRlc3QsIGZpbGVzW2ldKTtcblxuICAgICAgICAgICAgaWYoY3VycmVudC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgX19jb3B5RGlyKG5ld1NyYywgbmV3RGVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoY3VycmVudC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWxpbmsgPSBmcy5yZWFkbGlua1N5bmMobmV3U3JjKTtcbiAgICAgICAgICAgICAgICBmcy5zeW1saW5rU3luYyhzeW1saW5rLCBuZXdEZXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX19jb3B5RmlsZShuZXdTcmMsIG5ld0Rlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvcHkgYSBmaWxlLlxuICAgICAqIE5PVEU6IElmIHNyYyBpcyBhIGZpbGUsIHRhcmdldCBjYW5ub3QgYmUgYSBkaXJlY3RvcnkuXG4gICAgICogTk9URTogSWYgdGhlIGRlc3RpbmF0aW9uIHBhdGggc3RydWN0dXJlIGRvZXMgbm90IGV4aXN0cywgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSBzcmMge1N0cmluZ30gU291cmNlIGZpbGUgcGF0aC5cbiAgICAgKiBAcGFyYW0gZGVzdCB7U3RyaW5nfSBEZXN0aW5hdGlvbiBmaWxlIHBhdGguXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgY29weSBhY3Rpb24uIEF2YWlsYWJsZSBvcHRpb25zOlxuICAgICAqICAtIG92ZXJ3cml0ZSA8Qm9vbGVhbj46IG92ZXJ3cml0ZSBleGlzdGluZyBmaWxlIG9yIGRpcmVjdG9yeSwgZGVmYXVsdCBpcyB0cnVlLlxuICAgICAqICBOb3RlIHRoYXQgdGhlIGNvcHkgb3BlcmF0aW9uIHdpbGwgc2lsZW50bHkgZmFpbCBpZiB0aGlzIGlzIHNldCB0byBmYWxzZSBhbmQgdGhlIGRlc3RpbmF0aW9uIGV4aXN0cy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIF9fY29weUZpbGUgPSBmdW5jdGlvbihzcmMsIGRlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgc3JjID0gX19yZXNvbHZlUGF0aChzcmMpO1xuICAgICAgICBkZXN0ID0gX19yZXNvbHZlUGF0aChkZXN0KTtcblxuICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMub3ZlcndyaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWxlbnRseSBmYWlsIGlmIG92ZXJ3cml0ZSBpcyBzZXQgdG8gZmFsc2UgYW5kIHRoZSBkZXN0aW5hdGlvbiBleGlzdHMuXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gYFNpbGVudCBmYWlsIC0gY2Fubm90IGNvcHkuIERlc3RpbmF0aW9uIGZpbGUgJHtkZXN0fSBhbHJlYWR5IGV4aXN0cyBhbmQgb3ZlcndyaXRlIG9wdGlvbiBpcyBzZXQgdG8gZmFsc2UhIENvbnRpbnVpbmcuLi5gO1xuICAgICAgICAgICAgICAgIGxvZyhlcnJvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9fY3JlYXRlRGlyKHBhdGguZGlybmFtZShkZXN0KSk7XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoc3JjLCBcInV0ZjhcIik7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZGVzdCwgY29udGVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGZpbGUgb3IgZGlyZWN0b3J5LiBUaGUgZGlyZWN0b3J5IGNhbiBoYXZlIHJlY3Vyc2l2ZSBjb250ZW50cy4gTGlrZSBybSAtcmZcbiAgICAgKiBAcGFyYW0gc3JjIHtTdHJpbmd9IFBhdGhcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIF9fcmVtb3ZlID0gZnVuY3Rpb24oc3JjLCBjYWxsYmFjaykge1xuICAgICAgICBzcmMgPSBfX3Jlc29sdmVQYXRoKHNyYyk7XG5cbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpe307XG5cbiAgICAgICAgbG9nKGBSZW1vdmluZyAke3NyY31gKTtcblxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGZzLmxzdGF0U3luYyhzcmMpO1xuICAgICAgICAgICAgaWYoY3VycmVudC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgX19ybURpcihzcmMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGN1cnJlbnQuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICBfX3JtRmlsZShzcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmKGVyci5jb2RlICYmIGVyci5jb2RlID09PSBcIkVOT0VOVFwiKXtcbiAgICAgICAgICAgICAgICAvL2lnbm9yaW5nIGVycm9ycyBsaWtlIFwiZmlsZS9kaXJlY3RvcnkgZG9lcyBub3QgZXhpc3RcIlxuICAgICAgICAgICAgICAgIGVyciA9IG51bGw7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBsb2coZXJyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkaXJlY3RvcnkuIFRoZSBkaXJlY3RvcnkgY2FuIGhhdmUgcmVjdXJzaXZlIGNvbnRlbnRzLiBMaWtlIHJtIC1yZlxuICAgICAqIEBwYXJhbSBkaXIge1N0cmluZ30gUGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIF9fcm1EaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIGRpciA9IF9fcmVzb2x2ZVBhdGgoZGlyKTtcblxuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgICAgICAgICAgbG9nKGBEaXJlY3RvcnkgJHtkaXJ9IGRvZXMgbm90IGV4aXN0IWAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3QgPSBmcy5yZWFkZGlyU3luYyhkaXIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGguam9pbihkaXIsIGxpc3RbaV0pO1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBmcy5sc3RhdFN5bmMoZmlsZW5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgX19ybURpcihmaWxlbmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJtIGZpbGVuYW1lXG4gICAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhmaWxlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmcy5ybWRpclN5bmMoZGlyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gZmlsZSB7U3RyaW5nfSBQYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19ybUZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICAgIGZpbGUgPSBfX3Jlc29sdmVQYXRoKGZpbGUpO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZSkpIHtcbiAgICAgICAgICAgIGxvZyhgRmlsZSAke2ZpbGV9IGRvZXMgbm90IGV4aXN0IWAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnMudW5saW5rU3luYyhmaWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZGF0YSB0byBhIGZpbGUsIHJlcGxhY2luZyB0aGUgZmlsZSBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKiBAcGFyYW0gZmlsZSB7U3RyaW5nfSBQYXRoLlxuICAgICAqIEBwYXJhbSBkYXRhIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19jcmVhdGVGaWxlID0gZnVuY3Rpb24oZmlsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBmaWxlID0gX19yZXNvbHZlUGF0aChmaWxlKVxuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAgICogQHBhcmFtIHNyYyB7U3RyaW5nfSBTb3VyY2UgcGF0aC5cbiAgICAgKiBAcGFyYW0gZGVzdCB7U3RyaW5nfSBEZXN0aW5hdGlvbiBwYXRoLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9LiBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBjb3B5IGFjdGlvbi4gQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAgICogIC0gb3ZlcndyaXRlIDxib29sZWFuPjogb3ZlcndyaXRlIGV4aXN0aW5nIGZpbGUgb3IgZGlyZWN0b3J5LCBkZWZhdWx0IGlzIGZhbHNlLiBOb3RlIHRoYXQgdGhlIG1vdmUgb3BlcmF0aW9uIHdpbGwgc2lsZW50bHkgZmFpbCBpZiB5b3Ugc2V0IHRoaXMgdG8gdHJ1ZSBhbmQgdGhlIGRlc3RpbmF0aW9uIGV4aXN0cy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIF9fbW92ZSA9IGZ1bmN0aW9uKHNyYywgZGVzdCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgc3JjID0gX19yZXNvbHZlUGF0aChzcmMpO1xuICAgICAgICBkZXN0ID0gX19yZXNvbHZlUGF0aChkZXN0KTtcblxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJ3cml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhkZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaWxlbnRseSBmYWlsIGlmIG92ZXJ3cml0ZSBpcyBzZXQgdG8gZmFsc2UgYW5kIHRoZSBkZXN0aW5hdGlvbiBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IGBTaWxlbnQgZmFpbCAtIGNhbm5vdCBtb3ZlLiBEZXN0aW5hdGlvbiBmaWxlICR7ZGVzdH0gYWxyZWFkeSBleGlzdHMgYW5kIG92ZXJ3cml0ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlISBDb250aW51aW5nLi4uYDtcbiAgICAgICAgICAgICAgICAgICAgbG9nKGVycm9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19jb3B5KHNyYywgZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBfX3JlbW92ZShzcmMpO1xuICAgICAgICB9Y2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgY2hlY2tzdW0gdG8gYSBmaWxlIG9yIGEgZGlyZWN0b3J5IGJhc2VkIG9uIHRoZWlyIGNvbnRlbnRzIG9ubHkuXG4gICAgICogSWYgdGhlIHNvdXJjZSBpcyBkaXJlY3RvcnksIHRoZSBjaGVja3N1bSBpcyBhIGhhc2ggb2YgYWxsIGNvbmNhdGVuYXRlZCBmaWxlIGhhc2hlcy5cbiAgICAgKiBAcGFyYW0gc3JjIHtTdHJpbmd9IFBhdGggb2YgYSBmaWxlIG9yIGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0gYWxnb3JpdGhtIHtTdHJpbmd9IEhhc2hpbmcgYWxnb3JpdGhtKGRlZmF1bHQ6IG1kNSkuIFRoZSBhbGdvcml0aG0gaXMgZGVwZW5kZW50IG9uIHRoZSBhdmFpbGFibGUgYWxnb3JpdGhtc1xuICAgICAqIHN1cHBvcnRlZCBieSB0aGUgdmVyc2lvbiBvZiBPcGVuU1NMIG9uIHRoZSBwbGF0Zm9ybS4gRS5nLiAnbWQ1JywgJ3NoYTI1NicsICdzaGE1MTInLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7U3RyaW5nfSBIYXNoaW5nIGVuY29kaW5nIChkZWZhdWx0OiAnaGV4JykuIFRoZSBlbmNvZGluZyBpcyBkZXBlbmRlbnQgb24gdGhlXG4gICAgICogYXZhaWxhYmxlIGRpZ2VzdCBhbGdvcml0aG1zLiBFLmcuICdoZXgnLCAnbGF0aW4xJyBvciAnYmFzZTY0Jy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDaGVja3N1bSBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19jaGVja3N1bSA9IGZ1bmN0aW9uKHNyYywgYWxnb3JpdGhtLCBlbmNvZGluZykge1xuICAgICAgICBzcmMgPSBfX3Jlc29sdmVQYXRoKHNyYyk7XG5cbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHNyYykpIHtcbiAgICAgICAgICAgIHRocm93IGBQYXRoICR7c3JjfSBkb2VzIG5vdCBleGlzdHMhYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGVja3N1bSA9IFwiXCI7XG4gICAgICAgIGxldCBjdXJyZW50ID0gZnMubHN0YXRTeW5jKHNyYyk7XG4gICAgICAgIGlmKGN1cnJlbnQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgbGV0IGhhc2hEaXIgPSBfX2hhc2hEaXIoc3JjLCBhbGdvcml0aG0sIGVuY29kaW5nKTtcbiAgICAgICAgICAgIGNoZWNrc3VtID0gaGFzaERpcltcImhhc2hcIl07XG4gICAgICAgIH0gZWxzZSBpZihjdXJyZW50LmlzRmlsZSgpKSB7XG4gICAgICAgICAgICBjaGVja3N1bSA9IF9faGFzaEZpbGUoc3JjLCBhbGdvcml0aG0sIGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGVja3N1bTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoYXNoIG9mIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzdHIge1N0cmluZ31cbiAgICAgKiBAcGFyYW0gYWxnb3JpdGhtIHtTdHJpbmd9IEhhc2hpbmcgYWxnb3JpdGhtKGRlZmF1bHQ6IG1kNSkuIFRoZSBhbGdvcml0aG0gaXMgZGVwZW5kZW50IG9uIHRoZSBhdmFpbGFibGUgYWxnb3JpdGhtc1xuICAgICAqIHN1cHBvcnRlZCBieSB0aGUgdmVyc2lvbiBvZiBPcGVuU1NMIG9uIHRoZSBwbGF0Zm9ybS4gRS5nLiAnbWQ1JywgJ3NoYTI1NicsICdzaGE1MTInLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7U3RyaW5nfSBIYXNoaW5nIGVuY29kaW5nIChkZWZhdWx0OiAnaGV4JykuIFRoZSBlbmNvZGluZyBpcyBkZXBlbmRlbnQgb24gdGhlXG4gICAgICogYXZhaWxhYmxlIGRpZ2VzdCBhbGdvcml0aG1zLiBFLmcuICdoZXgnLCAnbGF0aW4xJyBvciAnYmFzZTY0Jy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBIYXNoIG9mIHRoZSBzdHJpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19oYXNoID0gIGZ1bmN0aW9uKHN0ciwgYWxnb3JpdGhtLCBlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXG4gICAgICAgICAgICAuY3JlYXRlSGFzaChhbGdvcml0aG0gfHwgJ21kNScpXG4gICAgICAgICAgICAudXBkYXRlKHN0ciwgJ3V0ZjgnKVxuICAgICAgICAgICAgLmRpZ2VzdChlbmNvZGluZyB8fCAnaGV4JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoYXNoIG9mIGEgZmlsZSBiYXNlZCBvbiBpdHMgY29udGVudCBvbmx5LlxuICAgICAqIEBwYXJhbSBzcmMge1N0cmluZ30gUGF0aCBvZiBhIGZpbGUuXG4gICAgICogQHBhcmFtIGFsZ29yaXRobSB7U3RyaW5nfSBIYXNoaW5nIGFsZ29yaXRobShkZWZhdWx0OiBtZDUpLiBUaGUgYWxnb3JpdGhtIGlzIGRlcGVuZGVudCBvbiB0aGUgYXZhaWxhYmxlIGFsZ29yaXRobXNcbiAgICAgKiBzdXBwb3J0ZWQgYnkgdGhlIHZlcnNpb24gb2YgT3BlblNTTCBvbiB0aGUgcGxhdGZvcm0uIEUuZy4gJ21kNScsICdzaGEyNTYnLCAnc2hhNTEyJy5cbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcge1N0cmluZ30gSGFzaGluZyBlbmNvZGluZyAoZGVmYXVsdDogJ2hleCcpLiBUaGUgZW5jb2RpbmcgaXMgZGVwZW5kZW50IG9uIHRoZVxuICAgICAqIGF2YWlsYWJsZSBkaWdlc3QgYWxnb3JpdGhtcy4gRS5nLiAnaGV4JywgJ2xhdGluMScgb3IgJ2Jhc2U2NCcuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gSGFzaCBvZiB0aGUgZmlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhciBfX2hhc2hGaWxlID0gZnVuY3Rpb24oc3JjLCBhbGdvcml0aG0sIGVuY29kaW5nKSB7XG4gICAgICAgIHNyYyA9IF9fcmVzb2x2ZVBhdGgoc3JjKTtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHNyYykpIHtcbiAgICAgICAgICAgIHRocm93IGAke3NyY30gZG9lcyBub3QgZXhpc3QhYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHNyYywgXCJ1dGY4XCIpO1xuICAgICAgICByZXR1cm4gX19oYXNoKGNvbnRlbnQsIGFsZ29yaXRobSwgZW5jb2RpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGhhc2ggb2YgYSBkaXJlY3RvcnkgYmFzZWQgb24gaXRzIGNvbnRlbnQgb25seS5cbiAgICAgKiBJZiBkaXJlY3RvcnkgaGFzIG11bHRpcGxlIGZpbGVzLCB0aGUgcmVzdWx0IGlzIGEgaGFzaCBvZiBhbGwgY29uY2F0ZW5hdGVkIGZpbGUgaGFzaGVzLlxuICAgICAqIEBwYXJhbSBzcmMge1N0cmluZ30gUGF0aCBvZiBhIGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0gYWxnb3JpdGhtIHtTdHJpbmd9IEhhc2hpbmcgYWxnb3JpdGhtKGRlZmF1bHQ6IG1kNSkuIFRoZSBhbGdvcml0aG0gaXMgZGVwZW5kZW50IG9uIHRoZSBhdmFpbGFibGUgYWxnb3JpdGhtc1xuICAgICAqIHN1cHBvcnRlZCBieSB0aGUgdmVyc2lvbiBvZiBPcGVuU1NMIG9uIHRoZSBwbGF0Zm9ybS4gRS5nLiAnbWQ1JywgJ3NoYTI1NicsICdzaGE1MTInLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7U3RyaW5nfSBIYXNoaW5nIGVuY29kaW5nIChkZWZhdWx0OiAnaGV4JykuIFRoZSBlbmNvZGluZyBpcyBkZXBlbmRlbnQgb24gdGhlXG4gICAgICogYXZhaWxhYmxlIGRpZ2VzdCBhbGdvcml0aG1zLiBFLmcuICdoZXgnLCAnbGF0aW4xJyBvciAnYmFzZTY0Jy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBIYXNoIG9mIHRoZSBkaXJlY3RvcnkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX19oYXNoRGlyID0gZnVuY3Rpb24oZGlyLCBhbGdvcml0aG0sIGVuY29kaW5nKSB7XG4gICAgICAgIGRpciA9IF9fcmVzb2x2ZVBhdGgoZGlyKTtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICAgICAgICAgIHRocm93IGBEaXJlY3RvcnkgJHtkaXJ9IGRvZXMgbm90IGV4aXN0IWA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2hlcyA9IHt9O1xuICAgICAgICB2YXIgbGlzdCA9IGZzLnJlYWRkaXJTeW5jKGRpcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aC5qb2luKGRpciwgbGlzdFtpXSk7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IGZzLmxzdGF0U3luYyhmaWxlbmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcEhhc2hlcyA9IF9faGFzaERpcihmaWxlbmFtZSwgYWxnb3JpdGhtLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgaGFzaGVzID0gT2JqZWN0LmFzc2lnbihoYXNoZXMsIHRlbXBIYXNoZXNbXCJzdWItaGFzaGVzXCJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBIYXNoID0gX19oYXNoRmlsZShmaWxlbmFtZSwgYWxnb3JpdGhtLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgaGFzaGVzW2ZpbGVuYW1lXSA9IHRlbXBIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tcHV0ZSBkaXIgaGFzaFxuICAgICAgICBsZXQgZGlyQ29udGVudCA9IE9iamVjdC5rZXlzKGhhc2hlcykucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKz0gaGFzaGVzW2tleV07XG4gICAgICAgIH0sIFwiXCIpO1xuXG4gICAgICAgIGxldCBkaXJIYXNoID0gX19oYXNoKGRpckNvbnRlbnQsIGFsZ29yaXRobSwgZW5jb2RpbmcpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImhhc2hcIjogZGlySGFzaCxcbiAgICAgICAgICAgIFwic3ViLWhhc2hlc1wiOiBoYXNoZXNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGd1aWQgKGdsb2JhbCB1bmlxdWUgaWRlbnRpZmllcikuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gR3VpZCBpbiB0aGUgZm9ybWF0IHh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFyIF9fZ3VpZCA9IGZ1bmN0aW9uIGd1aWQoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9tYWtlX2dyb3VwKHMpIHtcbiAgICAgICAgICAgIHZhciBwID0gKE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpK1wiMDAwMDAwMDAwXCIpLnN1YnN0cigyLDgpO1xuICAgICAgICAgICAgcmV0dXJuIHMgPyBcIi1cIiArIHAuc3Vic3RyKDAsNCkgKyBcIi1cIiArIHAuc3Vic3RyKDQsNCkgOiBwIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX21ha2VfZ3JvdXAoKSArIF9tYWtlX2dyb3VwKHRydWUpICsgX21ha2VfZ3JvdXAodHJ1ZSkgKyBfbWFrZV9ncm91cCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZ3Mgd3JhcHBlci5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSB7U3RyaW5nfVxuICAgICAqIEBwYXJhbSBpc0Vycm9yIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZyhtZXNzYWdlLCBpc0Vycm9yKSB7XG4gICAgICAgIGxldCBsb2dnZXIgPSBpc0Vycm9yID8gY29uc29sZS5lcnJvciA6IGNvbnNvbGUubG9nO1xuXG4gICAgICAgIGlmKERFQlVHKSB7XG4gICAgICAgICAgICBsb2dnZXIobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRCYXNlUGF0aDogX19zZXRCYXNlUGF0aCxcbiAgICAgICAgcmVzb2x2ZVBhdGg6IF9fcmVzb2x2ZVBhdGgsXG4gICAgICAgIGNyZWF0ZURpcjogX19jcmVhdGVEaXIsXG4gICAgICAgIGNvcHlEaXI6IF9fY29weURpcixcbiAgICAgICAgcm1EaXI6IF9fcm1EaXIsXG4gICAgICAgIHJtRmlsZTogX19ybUZpbGUsXG4gICAgICAgIGNyZWF0ZUZpbGU6IF9fY3JlYXRlRmlsZSxcbiAgICAgICAgY29weTogX19jb3B5LFxuICAgICAgICBtb3ZlOiBfX21vdmUsXG4gICAgICAgIHJlbW92ZTogX19yZW1vdmUsXG4gICAgICAgIGNoZWNrc3VtOiBfX2NoZWNrc3VtLFxuICAgICAgICBndWlkOiBfX2d1aWRcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLmZzRXh0ID0gbmV3IEZTRXh0ZW50aW9uKCk7IiwiJCQuQ09OU1RBTlRTID0ge1xuICAgIFNXQVJNX0ZPUl9FWEVDVVRJT046XCJzd2FybV9mb3JfZXhlY3V0aW9uXCIsXG4gICAgSU5CT1VORDpcImluYm91bmRcIixcbiAgICBPVVRCT1VORDpcIm91dGJvdW5kXCIsXG4gICAgUERTOlwiUHJpdmF0ZURhdGFTeXN0ZW1cIixcbiAgICBDUkw6XCJDb21tdW5pY2F0aW9uUmVwbGljYXRpb25MYXllclwiLFxuICAgIFNXQVJNX1JFVFVSTjogJ3N3YXJtX3JldHVybicsXG4gICAgQkVGT1JFX0lOVEVSQ0VQVE9SOiAnYmVmb3JlJyxcbiAgICBBRlRFUl9JTlRFUkNFUFRPUjogJ2FmdGVyJyxcbn07XG5cbiIsIi8vIHJlbGF0ZWQgdG86IFN3YXJtU3BhY2UuU3dhcm1EZXNjcmlwdGlvbi5jcmVhdGVQaGFzZSgpXG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yUmVnaXN0cnkoKSB7XG4gICAgY29uc3QgcnVsZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyA/Pz8gJCQuZXJyb3JIYW5kbGVyIExpYnJhcnkgPz8/XG4gICAgY29uc3QgX0NMQVNTX05BTUUgPSAnSW50ZXJjZXB0b3JSZWdpc3RyeSc7XG5cbiAgICAvKioqKioqKioqKioqKiBQUklWQVRFIE1FVEhPRFMgKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIF90aHJvd0Vycm9yKGVyciwgbXNnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UsIGAke19DTEFTU19OQU1FfSBlcnJvciBtZXNzYWdlOmAsIG1zZyk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfd2FybmluZyhtc2cpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGAke19DTEFTU19OQU1FfSB3YXJuaW5nIG1lc3NhZ2U6YCwgbXNnKTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRXaGVuT3B0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBXSEVOX09QVElPTlM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoV0hFTl9PUFRJT05TID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBXSEVOX09QVElPTlMgPSBPYmplY3QuZnJlZXplKFtcbiAgICAgICAgICAgICAgICAgICAgJCQuQ09OU1RBTlRTLkJFRk9SRV9JTlRFUkNFUFRPUixcbiAgICAgICAgICAgICAgICAgICAgJCQuQ09OU1RBTlRTLkFGVEVSX0lOVEVSQ0VQVE9SXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV0hFTl9PUFRJT05TO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBmdW5jdGlvbiB2ZXJpZnlXaGVuT3B0aW9uKHdoZW4pIHtcbiAgICAgICAgaWYgKCFnZXRXaGVuT3B0aW9ucygpLmluY2x1ZGVzKHdoZW4pKSB7XG4gICAgICAgICAgICBfdGhyb3dFcnJvcihuZXcgUmFuZ2VFcnJvcihgT3B0aW9uICcke3doZW59JyBpcyB3cm9uZyFgKSxcbiAgICAgICAgICAgICAgICBgaXQgc2hvdWxkIGJlIG9uZSBvZjogJHtnZXRXaGVuT3B0aW9ucygpfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmVyaWZ5SXNGdW5jdGlvblR5cGUoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX3Rocm93RXJyb3IobmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke2ZufScgaXMgd3JvbmchYCksXG4gICAgICAgICAgICAgICAgYGl0IHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBub3QgJHt0eXBlb2YgZm59IWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZU5hbWVzcGFjZVJlc29sdXRpb24oc3dhcm1UeXBlTmFtZSkge1xuICAgICAgICBpZiAoc3dhcm1UeXBlTmFtZSA9PT0gJyonKSB7XG4gICAgICAgICAgICByZXR1cm4gc3dhcm1UeXBlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoc3dhcm1UeXBlTmFtZS5pbmNsdWRlcyhcIi5cIikgPyBzd2FybVR5cGVOYW1lIDogKCQkLmxpYnJhcnlQcmVmaXggKyBcIi5cIiArIHN3YXJtVHlwZU5hbWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIGFycmF5IGludG8gYSBnZW5lcmF0b3Igd2l0aCB0aGUgcGFydGljdWxhcml0eSB0aGF0IGRvbmUgaXMgc2V0IHRvIHRydWUgb24gdGhlIGxhc3QgZWxlbWVudCxcbiAgICAgKiBub3QgYWZ0ZXIgaXQgZmluaXNoZWQgaXRlcmF0aW5nLCB0aGlzIGlzIGhlbHBmdWwgaW4gb3B0aW1pemluZyBzb21lIG90aGVyIGZ1bmN0aW9uc1xuICAgICAqIEl0IGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCBjYWxsIGEgcmVjdXJzaXZlIGZ1bmN0aW9uIG92ZXIgdGhlIGFycmF5IGVsZW1lbnRzIGJ1dCB3aXRob3V0IHBvcHBpbmcgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBvZiB0aGUgQXJyYXkgb3Igc2VuZGluZyB0aGUgaW5kZXggYXMgYW4gZXh0cmEgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gYXJyXG4gICAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjwqPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiogY3JlYXRlQXJyYXlHZW5lcmF0b3IoYXJyKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHlpZWxkIGFycltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJbbGVuIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgdHJlZSBsaWtlIHN0cnVjdHVyZSBvdmVyIHRpbWUgKGlmIGNhbGxlZCBvbiB0aGUgc2FtZSByb290IG5vZGUpIHdoZXJlIGludGVybmFsIG5vZGVzIGFyZSBpbnN0YW5jZXMgb2ZcbiAgICAgKiBNYXAgY29udGFpbmluZyB0aGUgbmFtZSBvZiB0aGUgY2hpbGRyZW4gbm9kZXMgKGVhY2ggY2hpbGQgbmFtZSBpcyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgbmV4dCBvbiBga2V5c0dlbmVyYXRvcilcbiAgICAgKiBhbmQgYSByZWZlcmVuY2UgdG8gdGhlbSBhbmQgb24gbGVhZnMgaXQgY29udGFpbnMgYW4gaW5zdGFuY2Ugb2YgU2V0IHdoZXJlIGl0IGFkZHMgdGhlIGZ1bmN0aW9uIGdpdmVuIGFzIHBhcmFtZXRlclxuICAgICAqIChleDogZm9yIGEga2V5R2VuZXJhdG9yIHRoYXQgcmV0dXJucyBpbiB0aGlzIG9yZGVyIChcImtleTFcIiwgXCJrZXkyXCIpIHRoZSByZXN1bHRpbmcgc3RydWN0dXJlIHdpbGwgYmU6XG4gICAgICoge1wia2V5MVwiOiB7XCJrZXkxXCI6IFNldChbZm5dKX19IC0gdXNpbmcgSlNPTiBqdXN0IGZvciBpbGx1c3RyYXRpb24gcHVycG9zZXMgYmVjYXVzZSBpdCdzIGVhc2llciB0byByZXByZXNlbnQpXG4gICAgICogQHBhcmFtIHtNYXB9IHJ1bGVzTWFwXG4gICAgICogQHBhcmFtIHtJdGVyYWJsZUl0ZXJhdG9yfSBrZXlzR2VuZXJhdG9yIC0gaXQgaGFzIHRoZSBwYXJ0aWN1bGFyaXR5IHRoYXQgZG9uZSBpcyBzZXQgb24gbGFzdCBlbGVtZW50LCBub3QgYWZ0ZXIgaXRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyUmVjdXJzaXZlUnVsZShydWxlc01hcCwga2V5c0dlbmVyYXRvciwgZm4pIHtcbiAgICAgICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IGtleXNHZW5lcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIGlmICghZG9uZSkgeyAvLyBpbnRlcm5hbCBub2RlXG4gICAgICAgICAgICBjb25zdCBuZXh0S2V5ID0gcnVsZXNNYXAuZ2V0KHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0S2V5ID09PSAndW5kZWZpbmVkJykgeyAvLyBpZiB2YWx1ZSBub3QgZm91bmQgaW4gcnVsZXNNYXBcbiAgICAgICAgICAgICAgICBydWxlc01hcC5zZXQodmFsdWUsIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZ2lzdGVyUmVjdXJzaXZlUnVsZShydWxlc01hcC5nZXQodmFsdWUpLCBrZXlzR2VuZXJhdG9yLCBmbik7XG4gICAgICAgIH0gZWxzZSB7IC8vIHJlYWNoZWQgbGVhZiBub2RlXG4gICAgICAgICAgICBpZiAoIXJ1bGVzTWFwLmhhcyh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIHJ1bGVzTWFwLnNldCh2YWx1ZSwgbmV3IFNldChbZm5dKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldCA9IHJ1bGVzTWFwLmdldCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0LmhhcyhmbikpIHtcbiAgICAgICAgICAgICAgICAgICAgX3dhcm5pbmcoYER1cGxpY2F0ZWQgaW50ZXJjZXB0b3IgZm9yICcke2tleX0nYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0LmFkZChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHNldCBvZiBmdW5jdGlvbnMgZm9yIHRoZSBnaXZlbiBrZXkgaWYgZm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gZm9ybWF0dGVkIGFzIGEgcGF0aCB3aXRob3V0IHRoZSBmaXJzdCAnLycgKGV4OiBzd2FybVR5cGUvc3dhcm1QaGFzZS9iZWZvcmUpXG4gICAgICogQHJldHVybiB7QXJyYXk8U2V0PGZ1bmN0aW9uPj59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW50ZXJjZXB0b3JzRm9yS2V5KGtleSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgX3dhcm5pbmcoYEludGVyY2VwdG9yIGNhbGxlZCBvbiBrZXkgJHtrZXl9IHN0YXJ0aW5nIHdpdGggJy8nLCBhdXRvbWF0aWNhbGx5IHJlbW92aW5nIGl0YCk7XG4gICAgICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5RWxlbWVudHMgPSBrZXkuc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3Qga2V5c0dlbmVyYXRvciA9IGNyZWF0ZUFycmF5R2VuZXJhdG9yKGtleUVsZW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gZ2V0VmFsdWVSZWN1cnNpdmVseShbcnVsZXNdLCBrZXlzR2VuZXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdCB3b3JrcyBsaWtlIGEgQkZTIHNlYXJjaCByZXR1cm5pbmcgdGhlIGxlYWZzIHJlc3VsdGluZyBmcm9tIHRyYXZlcnNpbmcgdGhlIGludGVybmFsIG5vZGVzIHdpdGggY29ycmVzcG9uZGluZ1xuICAgICAqIG5hbWVzIGdpdmVuIGZvciBlYWNoIGxldmVsIChkZXB0aCkgYnkgYGtleXNHZW5lcmF0b3JgXG4gICAgICogQHBhcmFtIHtBcnJheTxNYXA+fSBzZWFyY2hhYmxlTm9kZXNcbiAgICAgKiBAcGFyYW0ge0l0ZXJhYmxlSXRlcmF0b3J9IGtleXNHZW5lcmF0b3IgLSBpdCBoYXMgdGhlIHBhcnRpY3VsYXJpdHkgdGhhdCBkb25lIGlzIHNldCBvbiBsYXN0IGVsZW1lbnQsIG5vdCBhZnRlciBpdFxuICAgICAqIEByZXR1cm4ge0FycmF5PFNldDxmdW5jdGlvbj4+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZhbHVlUmVjdXJzaXZlbHkoc2VhcmNoYWJsZU5vZGVzLCBrZXlzR2VuZXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IHt2YWx1ZTogbm9kZU5hbWUsIGRvbmV9ID0ga2V5c0dlbmVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgY29uc3QgbmV4dE5vZGVzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlSW5SdWxlcyBvZiBzZWFyY2hhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlRm9yQWxsID0gbm9kZUluUnVsZXMuZ2V0KCcqJyk7XG4gICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVJblJ1bGVzLmdldChub2RlTmFtZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV4dE5vZGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZXMucHVzaChuZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV4dE5vZGVGb3JBbGwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZXMucHVzaChuZXh0Tm9kZUZvckFsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFZhbHVlUmVjdXJzaXZlbHkobmV4dE5vZGVzLCBrZXlzR2VuZXJhdG9yKTtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqIFBVQkxJQyBNRVRIT0RTICoqKioqKioqKioqKiovXG5cbiAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN3YXJtVHlwZU5hbWUsIHBoYXNlTmFtZSwgd2hlbiwgZm4pIHtcbiAgICAgICAgdmVyaWZ5V2hlbk9wdGlvbih3aGVuKTtcbiAgICAgICAgdmVyaWZ5SXNGdW5jdGlvblR5cGUoZm4pO1xuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkU3dhcm1UeXBlTmFtZSA9IHJlc29sdmVOYW1lc3BhY2VSZXNvbHV0aW9uKHN3YXJtVHlwZU5hbWUpO1xuICAgICAgICBjb25zdCBrZXlzID0gY3JlYXRlQXJyYXlHZW5lcmF0b3IoW3Jlc29sdmVkU3dhcm1UeXBlTmFtZSwgcGhhc2VOYW1lLCB3aGVuXSk7XG5cbiAgICAgICAgcmVnaXN0ZXJSZWN1cnNpdmVSdWxlKHJ1bGVzLCBrZXlzLCBmbik7XG4gICAgfTtcblxuICAgIC8vIHRoaXMudW5yZWdpc3RlciA9IGZ1bmN0aW9uICgpIHsgfVxuXG4gICAgdGhpcy5jYWxsSW50ZXJjZXB0b3JzID0gZnVuY3Rpb24gKGtleSwgdGFyZ2V0T2JqZWN0LCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IGdldEludGVyY2VwdG9yc0ZvcktleShrZXkpO1xuXG4gICAgICAgIGlmIChpbnRlcmNlcHRvcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJjZXB0b3JTZXQgb2YgaW50ZXJjZXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiBpbnRlcmNlcHRvclNldCkgeyAvLyBpbnRlcmNlcHRvcnMgb24ga2V5ICcqJyBhcmUgY2FsbGVkIGJlZm9yZSB0aG9zZSBzcGVjaWZpZWQgYnkgbmFtZVxuICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0YXJnZXRPYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuZXhwb3J0cy5jcmVhdGVJbnRlcmNlcHRvclJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJjZXB0b3JSZWdpc3RyeSgpO1xufTtcbiIsIi8qXG4gSW5pdGlhbCBMaWNlbnNlOiAoYykgQXhpb2xvZ2ljIFJlc2VhcmNoICYgQWxib2FpZSBTw65uaWPEgy5cbiBDb250cmlidXRvcnM6IEF4aW9sb2dpYyBSZXNlYXJjaCAsIFByaXZhdGVTa3kgcHJvamVjdFxuIENvZGUgTGljZW5zZTogTEdQTCBvciBNSVQuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNwcmludCA9IGNvbnNvbGUubG9nO1xud3ByaW50ID0gY29uc29sZS53YXJuO1xuZHByaW50ID0gY29uc29sZS5kZWJ1ZztcbmVwcmludCA9IGNvbnNvbGUuZXJyb3I7XG5cblxuLyoqXG4gKiBTaG9ydGN1dCB0byBKU09OLnN0cmluZ2lmeVxuICogQHBhcmFtIG9ialxuICovXG5KID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xufVxuXG5cbi8qKlxuICogUHJpbnQgc3dhcm0gY29udGV4dHMgKE1lc3NhZ2VzKSBhbmQgZWFzaWVyIHRvIHJlYWQgY29tcGFyZWQgd2l0aCBKXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuY2xlYW5EdW1wID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBvID0gb2JqLnZhbHVlT2YoKTtcbiAgICB2YXIgbWV0YSA9IHtcbiAgICAgICAgc3dhcm1UeXBlTmFtZTpvLm1ldGEuc3dhcm1UeXBlTmFtZVxuICAgIH07XG4gICAgcmV0dXJuIFwiXFx0IHN3YXJtSWQ6IFwiICsgby5tZXRhLnN3YXJtSWQgKyBcIntcXG5cXHRcXHRtZXRhOiBcIiAgICArIEoobWV0YSkgK1xuICAgICAgICBcIlxcblxcdFxcdHB1YmxpYzogXCIgICAgICAgICsgSihvLnB1YmxpY1ZhcnMpICtcbiAgICAgICAgXCJcXG5cXHRcXHRwcm90ZWN0ZWQ6IFwiICAgICArIEooby5wcm90ZWN0ZWRWYXJzKSArXG4gICAgICAgIFwiXFxuXFx0XFx0cHJpdmF0ZTogXCIgICAgICAgKyBKKG8ucHJpdmF0ZVZhcnMpICsgXCJcXG5cXHR9XFxuXCI7XG59XG5cbi8vTSA9IGV4cG9ydHMuY2xlYW5EdW1wO1xuLyoqXG4gKiBFeHBlcmltZW50YWwgZnVuY3Rpb25zXG4gKi9cblxuXG4vKlxuXG4gbG9nZ2VyICAgICAgPSBtb25pdG9yLmxvZ2dlcjtcbiBhc3NlcnQgICAgICA9IG1vbml0b3IuYXNzZXJ0O1xuIHRocm93aW5nICAgID0gbW9uaXRvci5leGNlcHRpb25zO1xuXG5cbiB2YXIgdGVtcG9yYXJ5TG9nQnVmZmVyID0gW107XG5cbiB2YXIgY3VycmVudFN3YXJtQ29tSW1wbCA9IG51bGw7XG5cbiBsb2dnZXIucmVjb3JkID0gZnVuY3Rpb24ocmVjb3JkKXtcbiBpZihjdXJyZW50U3dhcm1Db21JbXBsPT09bnVsbCl7XG4gdGVtcG9yYXJ5TG9nQnVmZmVyLnB1c2gocmVjb3JkKTtcbiB9IGVsc2Uge1xuIGN1cnJlbnRTd2FybUNvbUltcGwucmVjb3JkTG9nKHJlY29yZCk7XG4gfVxuIH1cblxuIHZhciBjb250YWluZXIgPSByZXF1aXJlKFwiZGljb250YWluZXJcIikuY29udGFpbmVyO1xuXG4gY29udGFpbmVyLnNlcnZpY2UoXCJzd2FybUxvZ2dpbmdNb25pdG9yXCIsIFtcInN3YXJtaW5nSXNXb3JraW5nXCIsIFwic3dhcm1Db21JbXBsXCJdLCBmdW5jdGlvbihvdXRPZlNlcnZpY2Usc3dhcm1pbmcsIHN3YXJtQ29tSW1wbCl7XG5cbiBpZihvdXRPZlNlcnZpY2Upe1xuIGlmKCF0ZW1wb3JhcnlMb2dCdWZmZXIpe1xuIHRlbXBvcmFyeUxvZ0J1ZmZlciA9IFtdO1xuIH1cbiB9IGVsc2Uge1xuIHZhciB0bXAgPSB0ZW1wb3JhcnlMb2dCdWZmZXI7XG4gdGVtcG9yYXJ5TG9nQnVmZmVyID0gW107XG4gY3VycmVudFN3YXJtQ29tSW1wbCA9IHN3YXJtQ29tSW1wbDtcbiBsb2dnZXIucmVjb3JkID0gZnVuY3Rpb24ocmVjb3JkKXtcbiBjdXJyZW50U3dhcm1Db21JbXBsLnJlY29yZExvZyhyZWNvcmQpO1xuIH1cblxuIHRtcC5mb3JFYWNoKGZ1bmN0aW9uKHJlY29yZCl7XG4gbG9nZ2VyLnJlY29yZChyZWNvcmQpO1xuIH0pO1xuIH1cbiB9KVxuXG4gKi9cbnVuY2F1Z2h0RXhjZXB0aW9uU3RyaW5nID0gXCJcIjtcbnVuY2F1Z2h0RXhjZXB0aW9uRXhpc3RzID0gZmFsc2U7XG5pZih0eXBlb2YgZ2xvYmFsVmVyYm9zaXR5ID09ICd1bmRlZmluZWQnKXtcbiAgICBnbG9iYWxWZXJib3NpdHkgPSBmYWxzZTtcbn1cblxudmFyIERFQlVHX1NUQVJUX1RJTUUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuZnVuY3Rpb24gZ2V0RGVidWdEZWx0YSgpe1xuICAgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHJldHVybiBjdXJyZW50VGltZSAtIERFQlVHX1NUQVJUX1RJTUU7XG59XG5cbi8qKlxuICogRGVidWcgZnVuY3Rpb25zLCBpbmZsdWVuY2VkIGJ5IGdsb2JhbFZlcmJvc2l0eSBnbG9iYWwgdmFyaWFibGVcbiAqIEBwYXJhbSB0eHRcbiAqL1xuZHByaW50ID0gZnVuY3Rpb24gKHR4dCkge1xuICAgIGlmIChnbG9iYWxWZXJib3NpdHkgPT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpc0FkYXB0ZXIuaW5pdGlsaXNlZCApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IFtcIiArIHRoaXNBZGFwdGVyLm5vZGVOYW1lICsgXCJdKFwiICsgZ2V0RGVidWdEZWx0YSgpKyBcIik6XCIrdHh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6IChcIiArIGdldERlYnVnRGVsdGEoKSsgXCIpOlwiK3R4dCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRFQlVHOiBcIiArIHR4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogb2Jzb2xldGUhP1xuICogQHBhcmFtIHR4dFxuICovXG5hcHJpbnQgPSBmdW5jdGlvbiAodHh0KSB7XG4gICAgY29uc29sZS5sb2coXCJERUJVRzogW1wiICsgdGhpc0FkYXB0ZXIubm9kZU5hbWUgKyBcIl06IFwiICsgdHh0KTtcbn1cblxuXG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB1c3VhbGx5IHVzZWQgaW4gdGVzdHMsIGV4aXQgY3VycmVudCBwcm9jZXNzIGFmdGVyIGEgd2hpbGVcbiAqIEBwYXJhbSBtc2dcbiAqIEBwYXJhbSB0aW1lb3V0XG4gKi9cbmRlbGF5RXhpdCA9IGZ1bmN0aW9uIChtc2csIHJldENvZGUsdGltZW91dCkge1xuICAgIGlmKHJldENvZGUgPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgcmV0Q29kZSA9IEV4aXRDb2Rlcy5Vbmtub3duRXJyb3I7XG4gICAgfVxuXG4gICAgaWYodGltZW91dCA9PSB1bmRlZmluZWQpe1xuICAgICAgICB0aW1lb3V0ID0gMTAwO1xuICAgIH1cblxuICAgIGlmKG1zZyA9PSB1bmRlZmluZWQpe1xuICAgICAgICBtc2cgPSBcIkRlbGF5aW5nIGV4aXQgd2l0aCBcIisgdGltZW91dCArIFwibXNcIjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9jZXNzLmV4aXQocmV0Q29kZSk7XG4gICAgfSwgdGltZW91dCk7XG59XG5cblxuZnVuY3Rpb24gbG9jYWxMb2cgKGxvZ1R5cGUsIG1lc3NhZ2UsIGVycikge1xuICAgIHZhciB0aW1lID0gbmV3IERhdGUoKTtcbiAgICB2YXIgbm93ID0gdGltZS5nZXREYXRlKCkgKyBcIi1cIiArICh0aW1lLmdldE1vbnRoKCkgKyAxKSArIFwiLFwiICsgdGltZS5nZXRIb3VycygpICsgXCI6XCIgKyB0aW1lLmdldE1pbnV0ZXMoKTtcbiAgICB2YXIgbXNnO1xuXG4gICAgbXNnID0gJ1snICsgbm93ICsgJ11bJyArIHRoaXNBZGFwdGVyLm5vZGVOYW1lICsgJ10gJyArIG1lc3NhZ2U7XG5cbiAgICBpZiAoZXJyICE9IG51bGwgJiYgZXJyICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBtc2cgKz0gJ1xcbiAgICAgRXJyOiAnICsgZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChlcnIuc3RhY2sgJiYgZXJyLnN0YWNrICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG1zZyArPSAnXFxuICAgICBTdGFjazogJyArIGVyci5zdGFjayArICdcXG4nO1xuICAgIH1cblxuICAgIGNwcmludChtc2cpO1xuICAgIGlmKHRoaXNBZGFwdGVyLmluaXRpbGlzZWQpe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBmcy5hcHBlbmRGaWxlU3luYyhnZXRTd2FybUZpbGVQYXRoKHRoaXNBZGFwdGVyLmNvbmZpZy5sb2dzUGF0aCArIFwiL1wiICsgbG9nVHlwZSksIG1zZyk7XG4gICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGluZyB0byB3cml0ZSBsb2dzIGluIFwiLCB0aGlzQWRhcHRlci5jb25maWcubG9nc1BhdGggKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuXG5cbi8vIHByaW50ZiA9IGZ1bmN0aW9uICguLi5wYXJhbXMpIHtcbi8vICAgICB2YXIgYXJncyA9IFtdOyAvLyBlbXB0eSBhcnJheVxuLy8gICAgIC8vIGNvcHkgYWxsIG90aGVyIGFyZ3VtZW50cyB3ZSB3YW50IHRvIFwicGFzcyB0aHJvdWdoXCJcbi8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICBhcmdzLnB1c2gocGFyYW1zW2ldKTtcbi8vICAgICB9XG4vLyAgICAgdmFyIG91dCA9IHV0aWwuZm9ybWF0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuLy8gICAgIGNvbnNvbGUubG9nKG91dCk7XG4vLyB9XG4vL1xuLy8gc3ByaW50ZiA9IGZ1bmN0aW9uICguLi5wYXJhbXMpIHtcbi8vICAgICB2YXIgYXJncyA9IFtdOyAvLyBlbXB0eSBhcnJheVxuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIGFyZ3MucHVzaChwYXJhbXNbaV0pO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gdXRpbC5mb3JtYXQuYXBwbHkodGhpcywgYXJncyk7XG4vLyB9XG5cbiIsImV4cG9ydHMuY3JlYXRlRm9yT2JqZWN0ID0gZnVuY3Rpb24odmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpe1xuXHRyZXR1cm4gcmVxdWlyZShcIi4uL3V0aWxpdHlGdW5jdGlvbnMvYmFzZVwiKS5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xufTsiLCJcblxuZnVuY3Rpb24gU3dhcm1zSW5zdGFuY2VzTWFuYWdlcigpe1xuICAgIHZhciBzd2FybUFsaXZlSW5zdGFuY2VzID0ge1xuXG4gICAgfVxuXG4gICAgdGhpcy53YWl0Rm9yU3dhcm0gPSBmdW5jdGlvbihjYWxsYmFjaywgc3dhcm0sIGtlZXBBbGl2ZUNoZWNrKXtcblxuICAgICAgICBmdW5jdGlvbiBkb0xvZ2ljKCl7XG4gICAgICAgICAgICB2YXIgc3dhcm1JZCA9IHN3YXJtLmdldElubmVyVmFsdWUoKS5tZXRhLnN3YXJtSWQ7XG4gICAgICAgICAgICB2YXIgd2F0Y2hlciA9IHN3YXJtQWxpdmVJbnN0YW5jZXNbc3dhcm1JZF07XG4gICAgICAgICAgICBpZighd2F0Y2hlcil7XG4gICAgICAgICAgICAgICAgd2F0Y2hlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3dhcm06c3dhcm0sXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOmNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICBrZWVwQWxpdmVDaGVjazprZWVwQWxpdmVDaGVja1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2FybUFsaXZlSW5zdGFuY2VzW3N3YXJtSWRdID0gd2F0Y2hlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbHRlcigpe1xuICAgICAgICAgICAgcmV0dXJuIHN3YXJtLmdldElubmVyVmFsdWUoKS5tZXRhLnN3YXJtSWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyQkLnVpZEdlbmVyYXRvci53YWl0X2Zvcl9jb25kaXRpb24oY29uZGl0aW9uLGRvTG9naWMpO1xuICAgICAgICBzd2FybS5vYnNlcnZlKGRvTG9naWMsIG51bGwsIGZpbHRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW5Td2FybVdhaXRlcihzd2FybVNlcmlhbGlzYXRpb24peyAvLyBUT0RPOiBhZGQgYmV0dGVyIG1lY2hhbmlzbXMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgdmFyIHN3YXJtSWQgPSBzd2FybVNlcmlhbGlzYXRpb24ubWV0YS5zd2FybUlkO1xuICAgICAgICB2YXIgd2F0Y2hlciA9IHN3YXJtQWxpdmVJbnN0YW5jZXNbc3dhcm1JZF07XG5cbiAgICAgICAgaWYoIXdhdGNoZXIpe1xuICAgICAgICAgICAgJCQuZXJyb3JIYW5kbGVyLndhcm5pbmcoXCJJbnZhbGlkIHN3YXJtIHJlY2VpdmVkOiBcIiArIHN3YXJtSWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBzd2FybVNlcmlhbGlzYXRpb24ubWV0YS5hcmdzO1xuICAgICAgICBhcmdzLnB1c2goc3dhcm1TZXJpYWxpc2F0aW9uKTtcblxuICAgICAgICB3YXRjaGVyLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZighd2F0Y2hlci5rZWVwQWxpdmVDaGVjaygpKXtcbiAgICAgICAgICAgIGRlbGV0ZSBzd2FybUFsaXZlSW5zdGFuY2VzW3N3YXJtSWRdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZXZpdmVfc3dhcm0gPSBmdW5jdGlvbihzd2FybVNlcmlhbGlzYXRpb24pe1xuXG5cbiAgICAgICAgdmFyIHN3YXJtSWQgICAgID0gc3dhcm1TZXJpYWxpc2F0aW9uLm1ldGEuc3dhcm1JZDtcbiAgICAgICAgdmFyIHN3YXJtVHlwZSAgID0gc3dhcm1TZXJpYWxpc2F0aW9uLm1ldGEuc3dhcm1UeXBlTmFtZTtcbiAgICAgICAgdmFyIGluc3RhbmNlICAgID0gc3dhcm1BbGl2ZUluc3RhbmNlc1tzd2FybUlkXTtcblxuICAgICAgICB2YXIgc3dhcm07XG5cbiAgICAgICAgaWYoaW5zdGFuY2Upe1xuICAgICAgICAgICAgc3dhcm0gPSBpbnN0YW5jZS5zd2FybTtcbiAgICAgICAgICAgIHN3YXJtLnVwZGF0ZShzd2FybVNlcmlhbGlzYXRpb24pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2FybSA9ICQkLnN3YXJtLnN0YXJ0KHN3YXJtVHlwZSk7XG4gICAgICAgICAgICBpZighc3dhcm0pe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzd2FybSB0eXBlIDwke3N3YXJtVHlwZX0+LiBDaGVjayBpZiBzd2FybSB0eXBlIGlzIHByZXNlbnQgaW4gZG9tYWluIGNvbnN0aXR1aW9uIWApO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgc3dhcm0udXBkYXRlKHN3YXJtU2VyaWFsaXNhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qc3dhcm0gPSAkJC5zd2FybS5zdGFydChzd2FybVR5cGUsIHN3YXJtU2VyaWFsaXNhdGlvbik7Ki9cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzd2FybVNlcmlhbGlzYXRpb24ubWV0YS5jb21tYW5kID09IFwiYXN5bmNSZXR1cm5cIikge1xuICAgICAgICAgICAgdmFyIGNvID0gJCQuUFNLX1B1YlN1Yi5wdWJsaXNoKCQkLkNPTlNUQU5UUy5TV0FSTV9SRVRVUk4sIHN3YXJtU2VyaWFsaXNhdGlvbik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1YnNjcmliZXJzIGxpc3RlbmluZyBvblwiLCAkJC5DT05TVEFOVFMuU1dBUk1fUkVUVVJOLCBjbyk7XG4gICAgICAgICAgICAvLyBjbGVhblN3YXJtV2FpdGVyKHN3YXJtU2VyaWFsaXNhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3dhcm1TZXJpYWxpc2F0aW9uLm1ldGEuY29tbWFuZCA9PSBcImV4ZWN1dGVTd2FybVBoYXNlXCIpIHtcbiAgICAgICAgICAgIHN3YXJtLnJ1blBoYXNlKHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLnBoYXNlTmFtZSwgc3dhcm1TZXJpYWxpc2F0aW9uLm1ldGEuYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gY29tbWFuZFwiLCBzd2FybVNlcmlhbGlzYXRpb24ubWV0YS5jb21tYW5kLCBcImluIHN3YXJtU2VyaWFsaXNhdGlvbi5tZXRhLmNvbW1hbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3dhcm07XG4gICAgfVxufVxuXG5cbiQkLnN3YXJtc0luc3RhbmNlc01hbmFnZXIgPSBuZXcgU3dhcm1zSW5zdGFuY2VzTWFuYWdlcigpO1xuXG5cbiIsIi8qXG5Jbml0aWFsIExpY2Vuc2U6IChjKSBBeGlvbG9naWMgUmVzZWFyY2ggJiBBbGJvYWllIFPDrm5pY8SDLlxuQ29udHJpYnV0b3JzOiBBeGlvbG9naWMgUmVzZWFyY2ggLCBQcml2YXRlU2t5IHByb2plY3RcbkNvZGUgTGljZW5zZTogTEdQTCBvciBNSVQuXG4qL1xuXG4vL3ZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbi8vdmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcblxuXG5mdW5jdGlvbiBTd2FybUxpYnJhcnkocHJlZml4TmFtZSwgZm9sZGVyKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gd3JhcENhbGwob3JpZ2luYWwsIHByZWZpeE5hbWUpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicHJlZml4TmFtZVwiLCBwcmVmaXhOYW1lKVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzUHJlZml4ID0gJCQubGlicmFyeVByZWZpeDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0xpYnJhcnkgPSAkJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeTtcblxuICAgICAgICAgICAgJCQubGlicmFyeVByZWZpeCA9IHByZWZpeE5hbWU7XG4gICAgICAgICAgICAkJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeSA9IHNlbGY7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICQkLmxpYnJhcnlQcmVmaXggPSBwcmV2aW91c1ByZWZpeCA7XG4gICAgICAgICAgICAgICAgJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnkgPSBwcmV2aW91c0xpYnJhcnk7XG4gICAgICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICAgICAgICAkJC5saWJyYXJ5UHJlZml4ID0gcHJldmlvdXNQcmVmaXggO1xuICAgICAgICAgICAgICAgICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5ID0gcHJldmlvdXNMaWJyYXJ5O1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkJC5saWJyYXJpZXNbcHJlZml4TmFtZV0gPSB0aGlzO1xuICAgIHZhciBwcmVmaXhlZFJlcXVpcmUgPSB3cmFwQ2FsbChmdW5jdGlvbihwYXRoKXtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUocGF0aCk7XG4gICAgfSwgcHJlZml4TmFtZSk7XG5cbiAgICBmdW5jdGlvbiBpbmNsdWRlQWxsSW5Sb290KGZvbGRlcikge1xuICAgICAgICBpZih0eXBlb2YgZm9sZGVyICE9IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgLy93ZSBhc3N1bWUgdGhhdCBpdCBpcyBhIGxpYnJhcnkgbW9kdWxlIHByb3Blcmx5IHJlcXVpcmVkIHdpdGggcmVxdWlyZSBhbmQgY29udGFpbmluZyAkJC5saWJyYXJ5XG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gZm9sZGVyKXtcbiAgICAgICAgICAgICAgICAkJC5yZWdpc3RlclN3YXJtRGVzY3JpcHRpb24ocHJlZml4TmFtZSx2LCBwcmVmaXhOYW1lICsgXCIuXCIgKyB2LCAgZm9sZGVyW3ZdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld05hbWVzID0gJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzW3ByZWZpeE5hbWVdO1xuICAgICAgICAgICAgZm9yKHZhciB2IGluIG5ld05hbWVzKXtcbiAgICAgICAgICAgICAgICBzZWxmW3ZdID0gIG5ld05hbWVzW3ZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIHJlcyA9IHByZWZpeGVkUmVxdWlyZShmb2xkZXIpOyAvLyBhIGxpYnJhcnkgaXMganVzdCBhIG1vZHVsZVxuICAgICAgICBpZih0eXBlb2YgcmVzLl9fYXV0b2dlbmVyYXRlZF9wcml2YXRlc2t5X2xpYnJhcnlOYW1lICE9IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgdmFyIHN3YXJtcyA9ICQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lc1tyZXMuX19hdXRvZ2VuZXJhdGVkX3ByaXZhdGVza3lfbGlicmFyeU5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN3YXJtcyA9ICQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lc1tmb2xkZXJdO1xuICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdOYW1lO1xuICAgICAgICAgICAgZm9yKHZhciB2IGluIHN3YXJtcyl7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdOYW1lID0gc3dhcm1zW3ZdO1xuICAgICAgICAgICAgICAgIHNlbGZbdl0gPSBleGlzdGluZ05hbWU7XG4gICAgICAgICAgICAgICAgJCQucmVnaXN0ZXJTd2FybURlc2NyaXB0aW9uKHByZWZpeE5hbWUsdiwgcHJlZml4TmFtZSArIFwiLlwiICsgdiwgIGV4aXN0aW5nTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcFN3YXJtUmVsYXRlZEZ1bmN0aW9ucyhzcGFjZSwgcHJlZml4TmFtZSl7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgdmFyIG5hbWVzID0gW1wiY3JlYXRlXCIsIFwiZGVzY3JpYmVcIiwgXCJzdGFydFwiLCBcInJlc3RhcnRcIl07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8bmFtZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHJldFtuYW1lc1tpXV0gPSB3cmFwQ2FsbChzcGFjZVtuYW1lc1tpXV0sIHByZWZpeE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsZmxvd3MgICAgICAgID0gdGhpcy5jYWxsZmxvdyAgID0gd3JhcFN3YXJtUmVsYXRlZEZ1bmN0aW9ucygkJC5jYWxsZmxvd3MsIHByZWZpeE5hbWUpO1xuICAgIHRoaXMuc3dhcm1zICAgICAgICAgICA9IHRoaXMuc3dhcm0gICAgICA9IHdyYXBTd2FybVJlbGF0ZWRGdW5jdGlvbnMoJCQuc3dhcm1zLCBwcmVmaXhOYW1lKTtcbiAgICB0aGlzLmNvbnRyYWN0cyAgICAgICAgPSB0aGlzLmNvbnRyYWN0ICAgPSB3cmFwU3dhcm1SZWxhdGVkRnVuY3Rpb25zKCQkLmNvbnRyYWN0cywgcHJlZml4TmFtZSk7XG4gICAgaW5jbHVkZUFsbEluUm9vdChmb2xkZXIsIHByZWZpeE5hbWUpO1xufVxuXG5leHBvcnRzLmxvYWRMaWJyYXJ5ID0gZnVuY3Rpb24ocHJlZml4TmFtZSwgZm9sZGVyKXtcbiAgICB2YXIgZXhpc3RpbmcgPSAkJC5saWJyYXJpZXNbcHJlZml4TmFtZV07XG4gICAgaWYoZXhpc3RpbmcgKXtcbiAgICAgICAgaWYoIShleGlzdGluZyBpbnN0YW5jZW9mIFN3YXJtTGlicmFyeSkpe1xuICAgICAgICAgICAgdmFyIHNMID0gbmV3IFN3YXJtTGlicmFyeShwcmVmaXhOYW1lLCBmb2xkZXIpO1xuICAgICAgICAgICAgZm9yKHZhciBwcm9wIGluIGV4aXN0aW5nKXtcbiAgICAgICAgICAgICAgICBzTFtwcm9wXSA9IGV4aXN0aW5nW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNMO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZvbGRlcikge1xuICAgICAgICAgICAgJCQuZXJyb3JIYW5kbGVyLndhcm5pbmcoXCJSZXVzaW5nIGFscmVhZHkgbG9hZGVkIGxpYnJhcnkgXCIgKyBwcmVmaXhOYW1lICsgXCJjb3VsZCBiZSBhbiBlcnJvciFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvL3ZhciBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUoZm9sZGVyKTtcbiAgICByZXR1cm4gbmV3IFN3YXJtTGlicmFyeShwcmVmaXhOYW1lLCBmb2xkZXIpO1xufVxuXG4iLCIvKlxuIHJlcXVpcmUgYW5kICQkLnJlcXVpcmUgYXJlIG92ZXJ3cml0aW5nIHRoZSBub2RlLmpzIGRlZmF1bHRzIGluIGxvYWRpbmcgbW9kdWxlcyBmb3IgaW5jcmVhc2luZyBzZWN1cml0eSxzcGVlZCBhbmQgbWFraW5nIGl0IHdvcmsgdG8gdGhlIHByaXZhdGVza3kgcnVudGltZSBidWlsZCB3aXRoIGJyb3dzZXJpZnkuXG4gVGhlIHByaXZhdGVza3kgY29kZSBmb3IgZG9tYWlucyBzaG91bGQgd29yayBpbiBub2RlIGFuZCBicm93c2Vycy5cbiAqL1xuXG5cbmlmICh0eXBlb2Yod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGdsb2JhbCA9IHdpbmRvdztcbn1cblxuXG5pZiAodHlwZW9mKGdsb2JhbC4kJCkgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGdsb2JhbC4kJCA9IHt9O1xuICAgICQkLl9fZ2xvYmFsID0ge307XG59XG5cbmlmICh0eXBlb2YoJCQuX19nbG9iYWwpID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAkJC5fX2dsb2JhbCA9IHt9O1xufVxuXG5pZiAodHlwZW9mKCQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lcykgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZSA9IG51bGw7XG4gICAgJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzID0ge307XG59XG5cblxuaWYgKHR5cGVvZigkJC5fX3J1bnRpbWVNb2R1bGVzKSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgJCQuX19ydW50aW1lTW9kdWxlcyA9IHt9O1xufVxuXG5yZXF1aXJlKFwiLi8uLi9zdGFuZGFyZEdsb2JhbFN5bWJvbHNcIik7XG5cbmlmICh0eXBlb2YoZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkKSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNhbGxlZCBvZiBhbiB1bmRlZmluZWQgZnVuY3Rpb24hISEhXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgb2YgYW4gdW5kZWZpbmVkIGZ1bmN0aW9uXCIpO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZihnbG9iYWwud2Vic2hpbXNSZXF1aXJlKSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGdsb2JhbC53ZWJzaGltc1JlcXVpcmUgPSBnbG9iYWwuZnVuY3Rpb25VbmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihnbG9iYWwuZG9tYWluUmVxdWlyZSkgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBnbG9iYWwuZG9tYWluUmVxdWlyZSA9IGdsb2JhbC5mdW5jdGlvblVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKGdsb2JhbC5wc2tydW50aW1lUmVxdWlyZSkgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBnbG9iYWwucHNrcnVudGltZVJlcXVpcmUgPSBnbG9iYWwuZnVuY3Rpb25VbmRlZmluZWQ7XG4gICAgfVxufVxuXG5jb25zdCB3ZUFyZUluYnJvd3NlciA9ICh0eXBlb2YgKCQkLmJyb3dzZXJSdW50aW1lKSAhPSBcInVuZGVmaW5lZFwiKTtcbmNvbnN0IHdlQXJlSW5TYW5kYm94ID0gKHR5cGVvZiBnbG9iYWwucmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5cbmNvbnN0IHBhc3RSZXF1ZXN0cyA9IHt9O1xuXG5mdW5jdGlvbiBwcmV2ZW50UmVjdXJzaXZlUmVxdWlyZShyZXF1ZXN0KSB7XG4gICAgaWYgKHBhc3RSZXF1ZXN0c1tyZXF1ZXN0XSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJQcmV2ZW50aW5nIHJlY3Vyc2l2ZSByZXF1aXJlIGZvciBcIiArIHJlcXVlc3QpO1xuICAgICAgICBlcnIudHlwZSA9IFwiUFNLSWdub3JhYmxlRXJyb3JcIjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBkaXNhYmxlUmVxdWlyZShyZXF1ZXN0KSB7XG4gICAgcGFzdFJlcXVlc3RzW3JlcXVlc3RdID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlUmVxdWlyZShyZXF1ZXN0KSB7XG4gICAgcGFzdFJlcXVlc3RzW3JlcXVlc3RdID0gZmFsc2U7XG59XG5cblxuZnVuY3Rpb24gcmVxdWlyZUZyb21DYWNoZShyZXF1ZXN0KSB7XG4gICAgY29uc3QgZXhpc3RpbmdNb2R1bGUgPSAkJC5fX3J1bnRpbWVNb2R1bGVzW3JlcXVlc3RdO1xuICAgIHJldHVybiBleGlzdGluZ01vZHVsZTtcbn1cblxuZnVuY3Rpb24gd3JhcFN0ZXAoY2FsbGJhY2tOYW1lKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBnbG9iYWxbY2FsbGJhY2tOYW1lXTtcblxuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjayA9PT0gZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayhyZXF1ZXN0KTtcbiAgICAgICAgJCQuX19ydW50aW1lTW9kdWxlc1tyZXF1ZXN0XSA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyeVJlcXVpcmVTZXF1ZW5jZShvcmlnaW5hbFJlcXVpcmUsIHJlcXVlc3QpIHtcbiAgICBsZXQgYXJyO1xuICAgIGlmIChvcmlnaW5hbFJlcXVpcmUpIHtcbiAgICAgICAgYXJyID0gJCQuX19yZXF1aXJlRnVuY3Rpb25zQ2hhaW4uc2xpY2UoKTtcbiAgICAgICAgYXJyLnB1c2gob3JpZ2luYWxSZXF1aXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnIgPSAkJC5fX3JlcXVpcmVGdW5jdGlvbnNDaGFpbjtcbiAgICB9XG5cbiAgICBwcmV2ZW50UmVjdXJzaXZlUmVxdWlyZShyZXF1ZXN0KTtcbiAgICBkaXNhYmxlUmVxdWlyZShyZXF1ZXN0KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHByZXZpb3VzUmVxdWlyZSA9ICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZTtcbiAgICBsZXQgcHJldmlvdXNSZXF1aXJlQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFwcmV2aW91c1JlcXVpcmUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJMb2FkaW5nIGxpYnJhcnkgZm9yIHJlcXVpcmVcIiwgcmVxdWVzdCk7XG4gICAgICAgICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZSA9IHJlcXVlc3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiAkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbcmVxdWVzdF0gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzW3JlcXVlc3RdID0ge307XG4gICAgICAgICAgICAvLyQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNEZXNjcmlwdGlvbnNbcmVxdWVzdF0gICA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzUmVxdWlyZUNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmdW5jID0gYXJyW2ldO1xuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBpZiAoZnVuYyA9PT0gZ2xvYmFsLmZ1bmN0aW9uVW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMocmVxdWVzdCk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIudHlwZSAhPT0gXCJQU0tJZ25vcmFibGVFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgJCQubG9nKFwiUmVxdWlyZSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBsb2FkaW5nIFwiLCByZXF1ZXN0LCBcIlxcbkNhdXNlOlxcblwiLCBlcnIuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgJCQubG9nKFwiRmFpbGVkIHRvIGxvYWQgbW9kdWxlIFwiLCByZXF1ZXN0LCByZXN1bHQpO1xuICAgIH1cblxuICAgIGVuYWJsZVJlcXVpcmUocmVxdWVzdCk7XG4gICAgaWYgKHByZXZpb3VzUmVxdWlyZUNoYW5nZWQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkVuZCBsb2FkaW5nIGxpYnJhcnkgZm9yIHJlcXVpcmVcIiwgcmVxdWVzdCwgJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzW3JlcXVlc3RdKTtcbiAgICAgICAgJCQuX19nbG9iYWwuY3VycmVudExpYnJhcnlOYW1lID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuaWYgKHR5cGVvZigkJC5yZXF1aXJlKSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICAkJC5fX3JlcXVpcmVMaXN0ID0gW1wid2Vic2hpbXNSZXF1aXJlXCIsIFwicHNrcnVudGltZVJlcXVpcmVcIl07XG4gICAgJCQuX19yZXF1aXJlRnVuY3Rpb25zQ2hhaW4gPSBbXTtcblxuICAgICQkLnJlcXVpcmVCdW5kbGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBuYW1lICs9IFwiUmVxdWlyZVwiO1xuICAgICAgICAkJC5fX3JlcXVpcmVMaXN0LnB1c2gobmFtZSk7XG4gICAgICAgIGNvbnN0IGFyciA9IFtyZXF1aXJlRnJvbUNhY2hlXTtcbiAgICAgICAgJCQuX19yZXF1aXJlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHdyYXBTdGVwKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAkJC5fX3JlcXVpcmVGdW5jdGlvbnNDaGFpbiA9IGFycjtcbiAgICB9O1xuXG4gICAgJCQucmVxdWlyZUJ1bmRsZShcImluaXRcIik7XG5cbiAgICBpZiAod2VBcmVJbmJyb3dzZXIpIHtcbiAgICAgICAgJCQubG9nKFwiRGVmaW5pbmcgZ2xvYmFsIHJlcXVpcmUgaW4gYnJvd3NlclwiKTtcblxuXG4gICAgICAgIGdsb2JhbC5yZXF1aXJlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgICAgICAgICAgLy8vKltyZXF1aXJlRnJvbUNhY2hlLCB3cmFwU3RlcCh3ZWJzaGltc1JlcXVpcmUpLCAsIHdyYXBTdGVwKHBza3J1bnRpbWVSZXF1aXJlKSwgd3JhcFN0ZXAoZG9tYWluUmVxdWlyZSkqXVxuICAgICAgICAgICAgcmV0dXJuIHRyeVJlcXVpcmVTZXF1ZW5jZShudWxsLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgICBpZiAod2VBcmVJblNhbmRib3gpIHtcbiAgICAgICAgLy8gcmVxdWlyZSBzaG91bGQgYmUgcHJvdmlkZWQgd2hlbiBjb2RlIGlzIGxvYWRlZCBpbiBicm93c2VyaWZ5XG4gICAgICAgIGNvbnN0IGJ1bmRsZVJlcXVpcmUgPSByZXF1aXJlO1xuXG4gICAgICAgICQkLnJlcXVpcmVCdW5kbGUoJ3NhbmRib3hCYXNlJyk7XG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHNldCB1cCBieSBzYW5kYm94IHByaW9yIHRvXG4gICAgICAgIGNvbnN0IHNhbmRib3hSZXF1aXJlID0gZ2xvYmFsLnJlcXVpcmU7XG4gICAgICAgIGdsb2JhbC5jcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuICAgICAgICBmdW5jdGlvbiBuZXdMb2FkZXIocmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJuZXdMb2FkZXI6XCIsIHJlcXVlc3QpO1xuICAgICAgICAgICAgLy9wcmV2ZW50UmVjdXJzaXZlUmVxdWlyZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndHJ5aW5nIHRvIGxvYWQgJywgcmVxdWVzdCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyeUJ1bmRsZVJlcXVpcmUoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuICQkLl9fb3JpZ2luYWxSZXF1aXJlLmFwcGx5KHNlbGYsYXJncyk7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gTW9kdWxlLl9sb2FkLmFwcGx5KHNlbGYsYXJncylcbiAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHNhbmRib3hSZXF1aXJlLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiTU9EVUxFX05PVF9GT1VORFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gc2FuZGJveFJlcXVpcmUuYXBwbHkoc2VsZiwgW3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXM7XG5cblxuICAgICAgICAgICAgcmVzID0gdHJ5UmVxdWlyZVNlcXVlbmNlKHRyeUJ1bmRsZVJlcXVpcmUsIHJlcXVlc3QpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBnbG9iYWwucmVxdWlyZSA9IG5ld0xvYWRlcjtcblxuICAgIH0gZWxzZSB7ICAvL3dlIGFyZSBpbiBub2RlXG4gICAgICAgIGNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICAgICAgJCQuX19ydW50aW1lTW9kdWxlc1tcImNyeXB0b1wiXSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4gICAgICAgICQkLl9fcnVudGltZU1vZHVsZXNbXCJ1dGlsXCJdID0gcmVxdWlyZShcInV0aWxcIik7XG5cbiAgICAgICAgY29uc3QgTW9kdWxlID0gcmVxdWlyZSgnbW9kdWxlJyk7XG4gICAgICAgICQkLl9fcnVudGltZU1vZHVsZXNbXCJtb2R1bGVcIl0gPSBNb2R1bGU7XG5cbiAgICAgICAgJCQubG9nKFwiUmVkZWZpbmluZyByZXF1aXJlIGZvciBub2RlXCIpO1xuXG4gICAgICAgICQkLl9fb3JpZ2luYWxSZXF1aXJlID0gTW9kdWxlLl9sb2FkO1xuICAgICAgICBjb25zdCBtb2R1bGVPcmlnaW5hbFJlcXVpcmUgPSBNb2R1bGUucHJvdG90eXBlLnJlcXVpcmU7XG5cbiAgICAgICAgZnVuY3Rpb24gbmV3TG9hZGVyKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibmV3TG9hZGVyOlwiLCByZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vcHJldmVudFJlY3Vyc2l2ZVJlcXVpcmUocmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgZnVuY3Rpb24gb3JpZ2luYWxSZXF1aXJlKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvL3JldHVybiAkJC5fX29yaWdpbmFsUmVxdWlyZS5hcHBseShzZWxmLGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vcmV0dXJuIE1vZHVsZS5fbG9hZC5hcHBseShzZWxmLGFyZ3MpXG4gICAgICAgICAgICAgICAgbGV0IHJlcztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBtb2R1bGVPcmlnaW5hbFJlcXVpcmUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBtb2R1bGVPcmlnaW5hbFJlcXVpcmUuYXBwbHkoc2VsZiwgW3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGN1cnJlbnRGb2xkZXJSZXF1aXJlKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9bcmVxdWlyZUZyb21DYWNoZSwgd3JhcFN0ZXAocHNrcnVudGltZVJlcXVpcmUpLCB3cmFwU3RlcChkb21haW5SZXF1aXJlKSwgb3JpZ2luYWxSZXF1aXJlXVxuICAgICAgICAgICAgcmV0dXJuIHRyeVJlcXVpcmVTZXF1ZW5jZShvcmlnaW5hbFJlcXVpcmUsIHJlcXVlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlID0gbmV3TG9hZGVyO1xuICAgIH1cblxuICAgICQkLnJlcXVpcmUgPSByZXF1aXJlO1xufVxuIiwiXG52YXIgam9pbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBQYXJhbGxlbEpvaW5Qb2ludChzd2FybSwgY2FsbGJhY2ssIGFyZ3Mpe1xuICAgIGpvaW5Db3VudGVyKys7XG4gICAgdmFyIGNoYW5uZWxJZCA9IFwiUGFyYWxsZWxKb2luUG9pbnRcIiArIGpvaW5Db3VudGVyO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIHN0b3BPdGhlckV4ZWN1dGlvbiAgICAgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGV4ZWN1dGlvblN0ZXAoc3RlcEZ1bmMsIGxvY2FsQXJncywgc3RvcCl7XG5cbiAgICAgICAgdGhpcy5kb0V4ZWN1dGUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoc3RvcE90aGVyRXhlY3V0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgc3RlcEZ1bmMuYXBwbHkoc3dhcm0sIGxvY2FsQXJncyk7XG4gICAgICAgICAgICAgICAgaWYoc3RvcCl7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BPdGhlckV4ZWN1dGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vZXZlcnl0aW5nIGlzIGZpbmVcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoZXJyKTtcbiAgICAgICAgICAgICAgICBzZW5kRm9yU291bmRFeGVjdXRpb24oY2FsbGJhY2ssIGFyZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9zdG9wIGl0LCBkbyBub3QgY2FsbCBhZ2FpbiBhbnl0aGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICAkJC5lcnJvckhhbmRsZXIuc3ludGF4RXJyb3IoXCJpbnZhbGlkIGpvaW5cIixzd2FybSwgXCJpbnZhbGlkIGZ1bmN0aW9uIGF0IGpvaW4gaW4gc3dhcm1cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAkJC5QU0tfUHViU3ViLnN1YnNjcmliZShjaGFubmVsSWQsZnVuY3Rpb24oZm9yRXhlY3V0aW9uKXtcbiAgICAgICAgaWYoc3RvcE90aGVyRXhlY3V0aW9uKXtcbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cblxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpZihmb3JFeGVjdXRpb24uZG9FeGVjdXRlKCkpe1xuICAgICAgICAgICAgICAgIGRlY0NvdW50ZXIoKTtcbiAgICAgICAgICAgIH0gLy8gaGFkIGFuIGVycm9yLi4uXG4gICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgIC8vJCQuZXJyb3JIYW5kbGVyLnN5bnRheEVycm9yKFwiX19pbnRlcm5hbF9fXCIsc3dhcm0sIFwiZXhjZXB0aW9uIGluIHRoZSBleGVjdXRpb24gb2YgdGhlIGpvaW4gZnVuY3Rpb24gb2YgYSBwYXJhbGxlbCB0YXNrXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpbmNDb3VudGVyKCl7XG4gICAgICAgIGlmKHRlc3RJZlVuZGVySW5zcGVjdGlvbigpKXtcbiAgICAgICAgICAgIC8vcHJldmVudGluZyBpbnNwZWN0b3IgZnJvbSBpbmNyZWFzaW5nIGNvdW50ZXIgd2hlbiByZWFkaW5nIHRoZSB2YWx1ZXMgZm9yIGRlYnVnIHJlYXNvblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInByZXZlbnRpbmcgaW5zcGVjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVyKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdElmVW5kZXJJbnNwZWN0aW9uKCl7XG4gICAgICAgIHZhciByZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvbnN0QXJndiA9IHByb2Nlc3MuZXhlY0FyZ3Yuam9pbigpO1xuICAgICAgICBpZihjb25zdEFyZ3YuaW5kZXhPZihcImluc3BlY3RcIikhPT0tMSB8fCBjb25zdEFyZ3YuaW5kZXhPZihcImRlYnVnXCIpIT09LTEpe1xuICAgICAgICAgICAgLy9vbmx5IHdoZW4gcnVubmluZyBpbiBkZWJ1Z1xuICAgICAgICAgICAgdmFyIGNhbGxzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgICAgaWYoY2FsbHN0YWNrLmluZGV4T2YoXCJEZWJ1Z0NvbW1hbmRQcm9jZXNzb3JcIikhPT0tMSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJEZWJ1Z0NvbW1hbmRQcm9jZXNzb3IgZGV0ZWN0ZWQhXCIpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW5kRm9yU291bmRFeGVjdXRpb24oZnVuY3QsIGFyZ3MsIHN0b3Ape1xuICAgICAgICB2YXIgb2JqID0gbmV3IGV4ZWN1dGlvblN0ZXAoZnVuY3QsIGFyZ3MsIHN0b3ApO1xuICAgICAgICAkJC5QU0tfUHViU3ViLnB1Ymxpc2goY2hhbm5lbElkLCBvYmopOyAvLyBmb3JjZSBleGVjdXRpb24gdG8gYmUgXCJzb3VuZFwiXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjQ291bnRlcigpe1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmKGNvdW50ZXIgPT0gMCkge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgc2VuZEZvclNvdW5kRXhlY3V0aW9uKGNhbGxiYWNrLCBhcmdzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW5uZXIgPSBzd2FybS5nZXRJbm5lclZhbHVlKCk7XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UHJvZ3Jlc3NSZXBvcnQoZXJyLCByZXMpe1xuICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDpcIlBhcmFsbGVsIGV4ZWN1dGlvbiBwcm9ncmVzcyBldmVudFwiLFxuICAgICAgICAgICAgc3dhcm06c3dhcm0sXG4gICAgICAgICAgICBhcmdzOmFyZ3MsXG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0OnJlc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1rRnVuY3Rpb24obmFtZSl7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgICAgIHZhciBmID0gZGVmYXVsdFByb2dyZXNzUmVwb3J0O1xuICAgICAgICAgICAgaWYobmFtZSAhPSBcInByb2dyZXNzXCIpe1xuICAgICAgICAgICAgICAgIGYgPSBpbm5lci5teUZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gJCQuX19pbnRlcm4ubWtBcmdzKGFyZ3MsIDApO1xuICAgICAgICAgICAgc2VuZEZvclNvdW5kRXhlY3V0aW9uKGYsIGFyZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBfX3Byb3h5T2JqZWN0O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpe1xuICAgICAgICBpZihpbm5lci5teUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBwcm9wID09IFwicHJvZ3Jlc3NcIil7XG4gICAgICAgICAgICBpbmNDb3VudGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gbWtGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3dhcm1bcHJvcF07XG4gICAgfTtcblxuICAgIHZhciBfX3Byb3h5T2JqZWN0O1xuXG4gICAgdGhpcy5fX3NldFByb3h5T2JqZWN0ID0gZnVuY3Rpb24ocCl7XG4gICAgICAgIF9fcHJveHlPYmplY3QgPSBwO1xuICAgIH1cbn1cblxuZXhwb3J0cy5jcmVhdGVKb2luUG9pbnQgPSBmdW5jdGlvbihzd2FybSwgY2FsbGJhY2ssIGFyZ3Mpe1xuICAgIHZhciBqcCA9IG5ldyBQYXJhbGxlbEpvaW5Qb2ludChzd2FybSwgY2FsbGJhY2ssIGFyZ3MpO1xuICAgIHZhciBpbm5lciA9IHN3YXJtLmdldElubmVyVmFsdWUoKTtcbiAgICB2YXIgcCA9IG5ldyBQcm94eShpbm5lciwganApO1xuICAgIGpwLl9fc2V0UHJveHlPYmplY3QocCk7XG4gICAgcmV0dXJuIHA7XG59OyIsIlxudmFyIGpvaW5Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gU2VyaWFsSm9pblBvaW50KHN3YXJtLCBjYWxsYmFjaywgYXJncyl7XG5cbiAgICBqb2luQ291bnRlcisrO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFubmVsSWQgPSBcIlNlcmlhbEpvaW5Qb2ludFwiICsgam9pbkNvdW50ZXI7XG5cbiAgICBpZih0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIil7XG4gICAgICAgICQkLmVycm9ySGFuZGxlci5zeW50YXhFcnJvcihcInVua25vd25cIiwgc3dhcm0sIFwiaW52YWxpZCBmdW5jdGlvbiBnaXZlbiB0byBzZXJpYWwgaW4gc3dhcm1cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5uZXIgPSBzd2FybS5nZXRJbm5lclZhbHVlKCk7XG5cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQcm9ncmVzc1JlcG9ydChlcnIsIHJlcyl7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICB2YXIgZnVuY3Rpb25Db3VudGVyICAgICA9IDA7XG4gICAgdmFyIGV4ZWN1dGlvbkNvdW50ZXIgICAgPSAwO1xuXG4gICAgdmFyIHBsYW5uZWRFeGVjdXRpb25zICAgPSBbXTtcbiAgICB2YXIgcGxhbm5lZEFyZ3VtZW50cyAgICA9IHt9O1xuXG4gICAgZnVuY3Rpb24gbWtGdW5jdGlvbihuYW1lLCBwb3Mpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ3JlYXRpbmcgZnVuY3Rpb24gXCIsIG5hbWUsIHBvcyk7XG4gICAgICAgIHBsYW5uZWRBcmd1bWVudHNbcG9zXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2V0TmV4dFN0ZXAoKXtcbiAgICAgICAgICAgIGlmKHBsYW5uZWRFeGVjdXRpb25zLmxlbmd0aCA9PSBleGVjdXRpb25Db3VudGVyIHx8IHBsYW5uZWRBcmd1bWVudHNbZXhlY3V0aW9uQ291bnRlcl0gKSAge1xuICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIucHVibGlzaChjaGFubmVsSWQsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoLi4uYXJncyl7XG4gICAgICAgICAgICBpZihleGVjdXRpb25Db3VudGVyICE9IHBvcykge1xuICAgICAgICAgICAgICAgIHBsYW5uZWRBcmd1bWVudHNbcG9zXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkRlbGF5aW5nIGZ1bmN0aW9uOlwiLCBleGVjdXRpb25Db3VudGVyLCBwb3MsIHBsYW5uZWRBcmd1bWVudHMsIGFyZ3VtZW50cywgZnVuY3Rpb25Db3VudGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19wcm94eTtcbiAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgICBpZihwbGFubmVkQXJndW1lbnRzW3Bvc10pe1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRXhlY3V0aW5nICBmdW5jdGlvbjpcIiwgZXhlY3V0aW9uQ291bnRlciwgcG9zLCBwbGFubmVkQXJndW1lbnRzLCBhcmd1bWVudHMsIGZ1bmN0aW9uQ291bnRlcik7XG5cdFx0XHRcdFx0YXJncyA9IHBsYW5uZWRBcmd1bWVudHNbcG9zXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwbGFubmVkQXJndW1lbnRzW3Bvc10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2V0TmV4dFN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fcHJveHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZiA9IGRlZmF1bHRQcm9ncmVzc1JlcG9ydDtcbiAgICAgICAgICAgIGlmKG5hbWUgIT0gXCJwcm9ncmVzc1wiKXtcbiAgICAgICAgICAgICAgICBmID0gaW5uZXIubXlGdW5jdGlvbnNbbmFtZV07XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGYuYXBwbHkoc2VsZixhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHN3YXJtLGFyZ3MpOyAvL2Vycm9yXG4gICAgICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIudW5zdWJzY3JpYmUoY2hhbm5lbElkLHJ1bk5leHRGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvL3Rlcm1pbmF0ZSBleGVjdXRpb24gd2l0aCBhbiBlcnJvci4uLiFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvdW50ZXIrKztcblxuICAgICAgICAgICAgdHJpZ2dldE5leHRTdGVwKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBfX3Byb3h5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHBsYW5uZWRFeGVjdXRpb25zLnB1c2goZik7XG4gICAgICAgIGZ1bmN0aW9uQ291bnRlcisrO1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICAgdmFyIGZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBydW5OZXh0RnVuY3Rpb24oKXtcbiAgICAgICAgaWYoZXhlY3V0aW9uQ291bnRlciA9PSBwbGFubmVkRXhlY3V0aW9ucy5sZW5ndGggKXtcbiAgICAgICAgICAgIGlmKCFmaW5pc2hlZCl7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHN3YXJtLGFyZ3MpO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAkJC5QU0tfUHViU3ViLnVuc3Vic2NyaWJlKGNoYW5uZWxJZCxydW5OZXh0RnVuY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNlcmlhbCBjb25zdHJ1Y3QgaXMgdXNpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy4uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsYW5uZWRFeGVjdXRpb25zW2V4ZWN1dGlvbkNvdW50ZXJdKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkJC5QU0tfUHViU3ViLnN1YnNjcmliZShjaGFubmVsSWQscnVuTmV4dEZ1bmN0aW9uKTsgLy8gZm9yY2UgaXQgdG8gYmUgXCJzb3VuZFwiXG5cblxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCByZWNlaXZlcil7XG4gICAgICAgIGlmKHByb3AgPT0gXCJwcm9ncmVzc1wiIHx8IGlubmVyLm15RnVuY3Rpb25zLmhhc093blByb3BlcnR5KHByb3ApKXtcbiAgICAgICAgICAgIHJldHVybiBta0Z1bmN0aW9uKHByb3AsIGZ1bmN0aW9uQ291bnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN3YXJtW3Byb3BdO1xuICAgIH1cblxuICAgIHZhciBfX3Byb3h5O1xuICAgIHRoaXMuc2V0UHJveHlPYmplY3QgPSBmdW5jdGlvbihwKXtcbiAgICAgICAgX19wcm94eSA9IHA7XG4gICAgfVxufVxuXG5leHBvcnRzLmNyZWF0ZVNlcmlhbEpvaW5Qb2ludCA9IGZ1bmN0aW9uKHN3YXJtLCBjYWxsYmFjaywgYXJncyl7XG4gICAgdmFyIGpwID0gbmV3IFNlcmlhbEpvaW5Qb2ludChzd2FybSwgY2FsbGJhY2ssIGFyZ3MpO1xuICAgIHZhciBpbm5lciA9IHN3YXJtLmdldElubmVyVmFsdWUoKTtcbiAgICB2YXIgcCA9IG5ldyBQcm94eShpbm5lciwganApO1xuICAgIGpwLnNldFByb3h5T2JqZWN0KHApO1xuICAgIHJldHVybiBwO1xufSIsImNvbnN0IE93TSA9IHJlcXVpcmUoXCJzd2FybXV0aWxzXCIpLk93TTtcblxudmFyIHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnkgPSB7fTtcblxuXG4kJC5yZWdpc3RlclN3YXJtRGVzY3JpcHRpb24gPSAgZnVuY3Rpb24obGlicmFyeU5hbWUsIHNob3J0TmFtZSwgc3dhcm1UeXBlTmFtZSwgZGVzY3JpcHRpb24pe1xuICAgIGlmKCEkJC5saWJyYXJpZXNbbGlicmFyeU5hbWVdKXtcbiAgICAgICAgJCQubGlicmFyaWVzW2xpYnJhcnlOYW1lXSA9IHt9O1xuICAgIH1cblxuICAgIGlmKCEkJC5fX2dsb2JhbC5yZXF1aXJlTGlicmFyaWVzTmFtZXNbbGlicmFyeU5hbWVdKXtcbiAgICAgICAgJCQuX19nbG9iYWwucmVxdWlyZUxpYnJhcmllc05hbWVzW2xpYnJhcnlOYW1lXSA9IHt9O1xuICAgIH1cblxuICAgICQkLmxpYnJhcmllc1tsaWJyYXJ5TmFtZV1bc2hvcnROYW1lXSA9IGRlc2NyaXB0aW9uO1xuICAgIC8vY29uc29sZS5sb2coXCJSZWdpc3RlcmluZyBcIiwgbGlicmFyeU5hbWUsc2hvcnROYW1lLCAkJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeU5hbWUpO1xuICAgIGlmKCQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZSl7XG4gICAgICAgICQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lc1skJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeU5hbWVdW3Nob3J0TmFtZV0gPSBsaWJyYXJ5TmFtZSArIFwiLlwiICsgc2hvcnROYW1lO1xuICAgIH1cblxuICAgICQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lc1tsaWJyYXJ5TmFtZV1bc2hvcnROYW1lXSA9IHN3YXJtVHlwZU5hbWU7XG5cbiAgICBpZih0eXBlb2YgZGVzY3JpcHRpb24gPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIGRlc2NyaXB0aW9uID0gc3dhcm1EZXNjcmlwdGlvbnNSZWdpc3RyeVtkZXNjcmlwdGlvbl07XG4gICAgfVxuICAgIHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV0gPSBkZXNjcmlwdGlvbjtcbn1cblxuXG52YXIgY3VycmVudExpYnJhcnlDb3VudGVyID0gMDtcbiQkLmxpYnJhcnkgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgY3VycmVudExpYnJhcnlDb3VudGVyKys7XG4gICAgdmFyIHByZXZpb3VzQ3VycmVudExpYnJhcnkgPSAkJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeU5hbWU7XG4gICAgdmFyIGxpYnJhcnlOYW1lID0gXCJfX19wcml2YXRlc2t5X2xpYnJhcnlcIitjdXJyZW50TGlicmFyeUNvdW50ZXI7XG4gICAgdmFyIHJldCA9ICQkLl9fZ2xvYmFsLnJlcXVpcmVMaWJyYXJpZXNOYW1lc1tsaWJyYXJ5TmFtZV0gPSB7fTtcbiAgICAkJC5fX2dsb2JhbC5jdXJyZW50TGlicmFyeU5hbWUgPSBsaWJyYXJ5TmFtZTtcbiAgICBjYWxsYmFjaygpO1xuICAgICQkLl9fZ2xvYmFsLmN1cnJlbnRMaWJyYXJ5TmFtZSA9IHByZXZpb3VzQ3VycmVudExpYnJhcnk7XG4gICAgcmV0Ll9fYXV0b2dlbmVyYXRlZF9wcml2YXRlc2t5X2xpYnJhcnlOYW1lID0gbGlicmFyeU5hbWU7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gU3dhcm1TcGFjZShzd2FybVR5cGUsIHV0aWxzKSB7XG5cbiAgICB2YXIgYmVlc0hlYWxlciA9IHJlcXVpcmUoXCJzd2FybXV0aWxzXCIpLmJlZXNIZWFsZXI7XG5cbiAgICBmdW5jdGlvbiBnZXRGdWxsTmFtZShzaG9ydE5hbWUpe1xuICAgICAgICB2YXIgZnVsbE5hbWU7XG4gICAgICAgIGlmKHNob3J0TmFtZSAmJiBzaG9ydE5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICBmdWxsTmFtZSA9IHNob3J0TmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxOYW1lID0gJCQubGlicmFyeVByZWZpeCArIFwiLlwiICsgc2hvcnROYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdWxsTmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBWYXJEZXNjcmlwdGlvbihkZXNjKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluaXQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3RvcmU6ZnVuY3Rpb24oanNvblN0cmluZyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9Kc29uU3RyaW5nOmZ1bmN0aW9uKHgpe1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFN3YXJtRGVzY3JpcHRpb24oc3dhcm1UeXBlTmFtZSwgZGVzY3JpcHRpb24pe1xuXG4gICAgICAgIHN3YXJtVHlwZU5hbWUgPSBnZXRGdWxsTmFtZShzd2FybVR5cGVOYW1lKTtcblxuICAgICAgICB2YXIgbG9jYWxJZCA9IDA7ICAvLyB1bmlxdWUgZm9yIGVhY2ggc3dhcm1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVWYXJzKGRlc2NyKXtcbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge307XG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gZGVzY3Ipe1xuICAgICAgICAgICAgICAgIG1lbWJlcnNbdl0gPSBuZXcgVmFyRGVzY3JpcHRpb24oZGVzY3Jbdl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVNZW1iZXJzKGRlc2NyKXtcbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge307XG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gZGVzY3JpcHRpb24pe1xuXG4gICAgICAgICAgICAgICAgaWYodiAhPSBcInB1YmxpY1wiICYmIHYgIT0gXCJwcml2YXRlXCIpe1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJzW3ZdID0gZGVzY3JpcHRpb25bdl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHVibGljVmFycyA9IGNyZWF0ZVZhcnMoZGVzY3JpcHRpb24ucHVibGljKTtcbiAgICAgICAgdmFyIHByaXZhdGVWYXJzID0gY3JlYXRlVmFycyhkZXNjcmlwdGlvbi5wcml2YXRlKTtcbiAgICAgICAgdmFyIG15RnVuY3Rpb25zID0gY3JlYXRlTWVtYmVycyhkZXNjcmlwdGlvbik7XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUGhhc2UodGhpc0luc3RhbmNlLCBmdW5jLCBwaGFzZU5hbWUpe1xuICAgICAgICAgICAgdmFyIGtleUJlZm9yZSA9IGAke3N3YXJtVHlwZU5hbWV9LyR7cGhhc2VOYW1lfS8keyQkLkNPTlNUQU5UUy5CRUZPUkVfSU5URVJDRVBUT1J9YDtcbiAgICAgICAgICAgIHZhciBrZXlBZnRlciA9IGAke3N3YXJtVHlwZU5hbWV9LyR7cGhhc2VOYW1lfS8keyQkLkNPTlNUQU5UUy5BRlRFUl9JTlRFUkNFUFRPUn1gO1xuXG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAgICAgJCQuUFNLX1B1YlN1Yi5ibG9ja0NhbGxCYWNrcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzSW5zdGFuY2Uuc2V0TWV0YWRhdGEoJ3BoYXNlTmFtZScsIHBoYXNlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICQkLmludGVyY2VwdG9yLmNhbGxJbnRlcmNlcHRvcnMoa2V5QmVmb3JlLCB0aGlzSW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBmdW5jLmFwcGx5KHRoaXNJbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICQkLmludGVyY2VwdG9yLmNhbGxJbnRlcmNlcHRvcnMoa2V5QWZ0ZXIsIHRoaXNJbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIucmVsZWFzZUNhbGxCYWNrcygpO1xuICAgICAgICAgICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgICAgICAgICAkJC5QU0tfUHViU3ViLnJlbGVhc2VDYWxsQmFja3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9keW5hbWljIG5hbWVkIGZ1bmMgaW4gb3JkZXIgdG8gaW1wcm92ZSBjYWxsc3RhY2tcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwaGFzZSwgXCJuYW1lXCIsIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN3YXJtVHlwZU5hbWUrXCIuXCIrZnVuYy5uYW1lfX0pO1xuICAgICAgICAgICAgcmV0dXJuIHBoYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXNlID0gZnVuY3Rpb24oc2VyaWFsaXNlZFZhbHVlcyl7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT3dNKHtcbiAgICAgICAgICAgICAgICBwdWJsaWNWYXJzOntcblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpdmF0ZVZhcnM6e1xuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWRWYXJzOntcblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbXlGdW5jdGlvbnM6e1xuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1dGlsaXR5RnVuY3Rpb25zOntcblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWV0YTp7XG4gICAgICAgICAgICAgICAgICAgIHN3YXJtVHlwZU5hbWU6c3dhcm1UeXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3dhcm1EZXNjcmlwdGlvbjpkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIGZvcih2YXIgdiBpbiBwdWJsaWNWYXJzKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVibGljVmFyc1t2XSA9IHB1YmxpY1ZhcnNbdl0uaW5pdCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yKHZhciB2IGluIHByaXZhdGVWYXJzKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHJpdmF0ZVZhcnNbdl0gPSBwcml2YXRlVmFyc1t2XS5pbml0KCk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIGlmKHNlcmlhbGlzZWRWYWx1ZXMpe1xuICAgICAgICAgICAgICAgIGJlZXNIZWFsZXIuanNvblRvTmF0aXZlKHNlcmlhbGlzZWRWYWx1ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGlzZUZ1bmN0aW9ucyA9IGZ1bmN0aW9uKHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0KXtcblxuICAgICAgICAgICAgZm9yKHZhciB2IGluIG15RnVuY3Rpb25zKXtcbiAgICAgICAgICAgICAgICB2YWx1ZU9iamVjdC5teUZ1bmN0aW9uc1t2XSA9IGNyZWF0ZVBoYXNlKHRoaXNPYmplY3QsIG15RnVuY3Rpb25zW3ZdLCB2KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxvY2FsSWQrKztcbiAgICAgICAgICAgIHZhbHVlT2JqZWN0LnV0aWxpdHlGdW5jdGlvbnMgPSB1dGlscy5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKXtcblxuXG4gICAgICAgICAgICBpZihwdWJsaWNWYXJzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnB1YmxpY1ZhcnNbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihwcml2YXRlVmFycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5wcml2YXRlVmFyc1twcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRhcmdldC51dGlsaXR5RnVuY3Rpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQudXRpbGl0eUZ1bmN0aW9uc1twcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYobXlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQubXlGdW5jdGlvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0YXJnZXQucHJvdGVjdGVkVmFycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5wcm90ZWN0ZWRWYXJzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodHlwZW9mIHByb3BlcnR5ICE9IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgICAgICAkJC5lcnJvckhhbmRsZXIuc3ludGF4RXJyb3IocHJvcGVydHksIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpe1xuXG4gICAgICAgICAgICBpZih0YXJnZXQudXRpbGl0eUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgfHwgdGFyZ2V0Lm15RnVuY3Rpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICQkLmVycm9ySGFuZGxlci5zeW50YXhFcnJvcihwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIG92ZXJ3cml0ZSBpbW11dGFibGUgbWVtYmVyXCIgKyBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHByaXZhdGVWYXJzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHJpdmF0ZVZhcnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGlmKHB1YmxpY1ZhcnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdWJsaWNWYXJzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHJvdGVjdGVkVmFyc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByb3h5IGFwcGx5XCIpO1xuICAgICAgICAgICAgLy92YXIgZnVuYyA9IHRhcmdldFtdXG4gICAgICAgICAgICAvL3N3YXJtR2xvYmFscy5leGVjdXRpb25Qcm92aWRlci5leGVjdXRlKG51bGwsIHRoaXNBcmcsIGZ1bmMsIGFyZ3VtZW50c0xpc3QpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5pc0V4dGVuc2libGUgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmhhcyA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgaWYodGFyZ2V0LnB1YmxpY1ZhcnNbcHJvcF0gfHwgdGFyZ2V0LnByb3RlY3RlZFZhcnNbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm93bktleXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnB1YmxpY1ZhcnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpYWxpc2VkVmFsdWVzKXtcbiAgICAgICAgICAgIHZhciB2YWx1ZU9iamVjdCA9IHNlbGYuaW5pdGlhbGlzZShzZXJpYWxpc2VkVmFsdWVzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUHJveHkodmFsdWVPYmplY3Qsc2VsZik7XG4gICAgICAgICAgICBzZWxmLmluaXRpYWxpc2VGdW5jdGlvbnModmFsdWVPYmplY3QscmVzdWx0KTtcblx0XHRcdGlmKCFzZXJpYWxpc2VkVmFsdWVzKXtcblx0XHRcdFx0aWYoIXZhbHVlT2JqZWN0LmdldE1ldGEoXCJzd2FybUlkXCIpKXtcblx0XHRcdFx0XHR2YWx1ZU9iamVjdC5zZXRNZXRhKFwic3dhcm1JZFwiLCAkJC51aWRHZW5lcmF0b3Iuc2FmZV91dWlkKCkpOyAgLy9kbyBub3Qgb3ZlcndyaXRlISEhXG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWVPYmplY3QudXRpbGl0eUZ1bmN0aW9ucy5ub3RpZnkoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYocmVzdWx0LmF1dG9Jbml0KXtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXV0b0luaXQoKTtcbiAgICAgICAgICAgICAgICAkJC5vYnNvbGV0ZShcImZpeCB0aGUgYWJvdmUgY29tbWVudFwiKVxuICAgICAgICAgICAgICAgIC8vcmVzdWx0LmF1dG9Jbml0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICB0aGlzLmRlc2NyaWJlID0gZnVuY3Rpb24gZGVzY3JpYmVTd2FybShzd2FybVR5cGVOYW1lLCBkZXNjcmlwdGlvbil7XG4gICAgICAgIHN3YXJtVHlwZU5hbWUgPSBnZXRGdWxsTmFtZShzd2FybVR5cGVOYW1lKTtcblxuICAgICAgICB2YXIgcG9pbnRQb3MgPSBzd2FybVR5cGVOYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIHZhciBzaG9ydE5hbWUgPSBzd2FybVR5cGVOYW1lLnN1YnN0ciggcG9pbnRQb3MrIDEpO1xuICAgICAgICB2YXIgbGlicmFyeU5hbWUgPSBzd2FybVR5cGVOYW1lLnN1YnN0cigwLCBwb2ludFBvcyk7XG4gICAgICAgIGlmKCFsaWJyYXJ5TmFtZSl7XG4gICAgICAgICAgICBsaWJyYXJ5TmFtZSA9IFwiZ2xvYmFsXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBuZXcgU3dhcm1EZXNjcmlwdGlvbihzd2FybVR5cGVOYW1lLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmKHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV0gIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICQkLmVycm9ySGFuZGxlci53YXJuaW5nKFwiRHVwbGljYXRlIHN3YXJtIGRlc2NyaXB0aW9uIFwiKyBzd2FybVR5cGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc3dhcm1EZXNjcmlwdGlvbnNSZWdpc3RyeVtzd2FybVR5cGVOYW1lXSA9IGRlc2NyaXB0aW9uO1xuXHRcdCQkLnJlZ2lzdGVyU3dhcm1EZXNjcmlwdGlvbihsaWJyYXJ5TmFtZSwgc2hvcnROYW1lLCBzd2FybVR5cGVOYW1lLCBkZXNjcmlwdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuY3JlYXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgJCQuZXJyb3IoXCJjcmVhdGUgZnVuY3Rpb24gaXMgb2Jzb2xldGUuIHVzZSBkZXNjcmliZSFcIik7XG4gICAgfVxuICAgIC8qIC8vIGNvbmZ1c2luZyB2YXJpYW50XG4gICAgdGhpcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVTd2FybShzd2FybVR5cGVOYW1lLCBkZXNjcmlwdGlvbiwgaW5pdGlhbFZhbHVlcyl7XG4gICAgICAgIHN3YXJtVHlwZU5hbWUgPSBnZXRGdWxsTmFtZShzd2FybVR5cGVOYW1lKTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaWYodW5kZWZpbmVkID09IGRlc2NyaXB0aW9uKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3dhcm1EZXNjcmlwdGlvbnNSZWdpc3RyeVtzd2FybVR5cGVOYW1lXShpbml0aWFsVmFsdWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpYmUoc3dhcm1UeXBlTmFtZSwgZGVzY3JpcHRpb24pKGluaXRpYWxWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0ZVN3YXJtIGVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAkJC5lcnJvckhhbmRsZXIuZXJyb3IoZXJyLCBhcmd1bWVudHMsIFwiV3JvbmcgbmFtZSBvciBkZXNjcmlwdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICB9Ki9cblxuICAgIHRoaXMuY29udGludWUgPSBmdW5jdGlvbihzd2FybVR5cGVOYW1lLCBpbml0aWFsVmFsdWVzKXtcbiAgICAgICAgc3dhcm1UeXBlTmFtZSA9IGdldEZ1bGxOYW1lKHN3YXJtVHlwZU5hbWUpO1xuICAgICAgICB2YXIgZGVzYyA9IHN3YXJtRGVzY3JpcHRpb25zUmVnaXN0cnlbc3dhcm1UeXBlTmFtZV07XG5cbiAgICAgICAgaWYoZGVzYyl7XG4gICAgICAgICAgICByZXR1cm4gZGVzYyhpbml0aWFsVmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQkLmVycm9ySGFuZGxlci5zeW50YXhFcnJvcihzd2FybVR5cGVOYW1lLGluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAgICAgXCJGYWlsZWQgdG8gcmVzdGFydCBhIHN3YXJtIHdpdGggdHlwZSBcIiArIHN3YXJtVHlwZU5hbWUgKyBcIlxcbiBNYXliZSBkaWZmZXJlbnQgc3dhcm0gc3BhY2UgKHVzZWQgZmxvdyBpbnN0ZWFkIG9mIHN3YXJtIT8pXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKHN3YXJtVHlwZU5hbWUsIGN0b3IsIC4uLnBhcmFtcyl7XG4gICAgICAgIHN3YXJtVHlwZU5hbWUgPSBnZXRGdWxsTmFtZShzd2FybVR5cGVOYW1lKTtcbiAgICAgICAgdmFyIGRlc2MgPSBzd2FybURlc2NyaXB0aW9uc1JlZ2lzdHJ5W3N3YXJtVHlwZU5hbWVdO1xuICAgICAgICBpZighZGVzYyl7XG4gICAgICAgICAgICAkJC5lcnJvckhhbmRsZXIuc3ludGF4RXJyb3IobnVsbCwgc3dhcm1UeXBlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gZGVzYygpO1xuICAgICAgICByZXMuc2V0TWV0YWRhdGEoXCJob21lU2VjdXJpdHlDb250ZXh0XCIsICQkLnNlY3VyaXR5Q29udGV4dCk7XG5cbiAgICAgICAgaWYoY3Rvcil7XG4gICAgICAgICAgICByZXNbY3Rvcl0uYXBwbHkocmVzLCBwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbmV4cG9ydHMuY3JlYXRlU3dhcm1FbmdpbmUgPSBmdW5jdGlvbihzd2FybVR5cGUsIHV0aWxzKXtcbiAgICBpZih0eXBlb2YgdXRpbHMgPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbGl0eUZ1bmN0aW9ucy9jYWxsZmxvd1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTd2FybVNwYWNlKHN3YXJtVHlwZSwgdXRpbHMpO1xufTtcbiIsImV4cG9ydHMuY3JlYXRlRm9yT2JqZWN0ID0gZnVuY3Rpb24odmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpe1xuXHR2YXIgcmV0ID0gcmVxdWlyZShcIi4vYmFzZVwiKS5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xuXG5cdHJldC5zd2FybSAgICAgICAgICAgPSBudWxsO1xuXHRyZXQub25SZXR1cm4gICAgICAgID0gbnVsbDtcblx0cmV0Lm9uUmVzdWx0ICAgICAgICA9IG51bGw7XG5cdHJldC5hc3luY1JldHVybiAgICAgPSBudWxsO1xuXHRyZXQucmV0dXJuICAgICAgICAgID0gbnVsbDtcblx0cmV0LmhvbWUgICAgICAgICAgICA9IG51bGw7XG5cdHJldC5pc1BlcnNpc3RlZCAgXHQ9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpc09iamVjdC5nZXRNZXRhZGF0YSgncGVyc2lzdGVkJykgPT09IHRydWU7XG5cdH07XG5cblx0cmV0dXJuIHJldDtcbn07IiwidmFyIGJlZXNIZWFsZXIgPSByZXF1aXJlKFwic3dhcm11dGlsc1wiKS5iZWVzSGVhbGVyO1xudmFyIHN3YXJtRGVidWcgPSByZXF1aXJlKFwiLi4vY2hvcmVvZ3JhcGhpZXMvU3dhcm1EZWJ1Z1wiKTtcblxuZXhwb3J0cy5jcmVhdGVGb3JPYmplY3QgPSBmdW5jdGlvbih2YWx1ZU9iamVjdCwgdGhpc09iamVjdCwgbG9jYWxJZCl7XG5cdHZhciByZXQgPSB7fTtcblxuXHRmdW5jdGlvbiBmaWx0ZXJGb3JTZXJpYWxpc2FibGUgKHZhbHVlT2JqZWN0KXtcblx0XHRyZXR1cm4gdmFsdWVPYmplY3QubWV0YS5zd2FybUlkO1xuXHR9XG5cblx0dmFyIHN3YXJtRnVuY3Rpb24gPSBmdW5jdGlvbihjb250ZXh0LCBwaGFzZU5hbWUpe1xuXHRcdHZhciBhcmdzID1bXTtcblx0XHRmb3IodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuXHRcdH1cblxuXHRcdC8vbWFrZSB0aGUgZXhlY3V0aW9uIGF0IGxldmVsIDAgIChhZnRlciBhbGwgcGVuZGluZyBldmVudHMpIGFuZCB3YWl0IHRvIGhhdmUgYSBzd2FybUlkXG5cdFx0cmV0Lm9ic2VydmUoZnVuY3Rpb24oKXtcblx0XHRcdGJlZXNIZWFsZXIuYXNKU09OKHZhbHVlT2JqZWN0LCBwaGFzZU5hbWUsIGFyZ3MsIGZ1bmN0aW9uKGVycixqc01zZyl7XG5cdFx0XHRcdGpzTXNnLm1ldGEudGFyZ2V0ID0gY29udGV4dDtcblx0XHRcdFx0dmFyIHN1YnNjcmliZXJzQ291bnQgPSAkJC5QU0tfUHViU3ViLnB1Ymxpc2goJCQuQ09OU1RBTlRTLlNXQVJNX0ZPUl9FWEVDVVRJT04sIGpzTXNnKTtcblx0XHRcdFx0aWYoIXN1YnNjcmliZXJzQ291bnQpe1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBOb2JvZHkgbGlzdGVuaW5nIGZvciA8JHskJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTn0+IWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LG51bGwsZmlsdGVyRm9yU2VyaWFsaXNhYmxlKTtcblxuXHRcdHJldC5ub3RpZnkoKTtcblxuXG5cdFx0cmV0dXJuIHRoaXNPYmplY3Q7XG5cdH07XG5cblx0dmFyIGFzeW5jUmV0dXJuID0gZnVuY3Rpb24oZXJyLCByZXN1bHQpe1xuXHRcdHZhciBjb250ZXh0ID0gdmFsdWVPYmplY3QucHJvdGVjdGVkVmFycy5jb250ZXh0O1xuXG5cdFx0aWYoIWNvbnRleHQgJiYgdmFsdWVPYmplY3QubWV0YS53YWl0U3RhY2spe1xuXHRcdFx0Y29udGV4dCA9IHZhbHVlT2JqZWN0Lm1ldGEud2FpdFN0YWNrLnBvcCgpO1xuXHRcdFx0dmFsdWVPYmplY3QucHJvdGVjdGVkVmFycy5jb250ZXh0ID0gY29udGV4dDtcblx0XHR9XG5cblx0XHRiZWVzSGVhbGVyLmFzSlNPTih2YWx1ZU9iamVjdCwgXCJfX3JldHVybl9fXCIsIFtlcnIsIHJlc3VsdF0sIGZ1bmN0aW9uKGVycixqc01zZyl7XG5cdFx0XHRqc01zZy5tZXRhLmNvbW1hbmQgPSBcImFzeW5jUmV0dXJuXCI7XG5cdFx0XHRpZighY29udGV4dCl7XG5cdFx0XHRcdGNvbnRleHQgPSB2YWx1ZU9iamVjdC5tZXRhLmhvbWVTZWN1cml0eUNvbnRleHQ7Ly9UT0RPOiBDSEVDSyBUSElTXG5cblx0XHRcdH1cblx0XHRcdGpzTXNnLm1ldGEudGFyZ2V0ID0gY29udGV4dDtcblxuXHRcdFx0aWYoIWNvbnRleHQpe1xuXHRcdFx0XHQkJC5lcnJvckhhbmRsZXIuZXJyb3IobmV3IEVycm9yKFwiQXN5bmNocm9ub3VzIHJldHVybiBpbnNpZGUgb2YgYSBzd2FybSB0aGF0IGRvZXMgbm90IHdhaXQgZm9yIHJlc3VsdHNcIikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCQuUFNLX1B1YlN1Yi5wdWJsaXNoKCQkLkNPTlNUQU5UUy5TV0FSTV9GT1JfRVhFQ1VUSU9OLCBqc01zZyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gaG9tZShlcnIsIHJlc3VsdCl7XG5cdFx0YmVlc0hlYWxlci5hc0pTT04odmFsdWVPYmplY3QsIFwiaG9tZVwiLCBbZXJyLCByZXN1bHRdLCBmdW5jdGlvbihlcnIsanNNc2cpe1xuXHRcdFx0dmFyIGNvbnRleHQgPSB2YWx1ZU9iamVjdC5tZXRhLmhvbWVDb250ZXh0O1xuXHRcdFx0anNNc2cubWV0YS50YXJnZXQgPSBjb250ZXh0O1xuXHRcdFx0JCQuUFNLX1B1YlN1Yi5wdWJsaXNoKCQkLkNPTlNUQU5UUy5TV0FSTV9GT1JfRVhFQ1VUSU9OLCBqc01zZyk7XG5cdFx0fSk7XG5cdH1cblxuXG5cblx0ZnVuY3Rpb24gd2FpdFJlc3VsdHMoY2FsbGJhY2ssIGtlZXBBbGl2ZUNoZWNrLCBzd2FybSl7XG5cdFx0aWYoIXN3YXJtKXtcblx0XHRcdHN3YXJtID0gdGhpcztcblx0XHR9XG5cdFx0aWYoIWtlZXBBbGl2ZUNoZWNrKXtcblx0XHRcdGtlZXBBbGl2ZUNoZWNrID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgaW5uZXIgPSBzd2FybS5nZXRJbm5lclZhbHVlKCk7XG5cdFx0aWYoIWlubmVyLm1ldGEud2FpdFN0YWNrKXtcblx0XHRcdGlubmVyLm1ldGEud2FpdFN0YWNrID0gW107XG5cdFx0XHRpbm5lci5tZXRhLndhaXRTdGFjay5wdXNoKCQkLnNlY3VyaXR5Q29udGV4dClcblx0XHR9XG5cdFx0JCQuc3dhcm1zSW5zdGFuY2VzTWFuYWdlci53YWl0Rm9yU3dhcm0oY2FsbGJhY2ssIHN3YXJtLCBrZWVwQWxpdmVDaGVjayk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldElubmVyVmFsdWUoKXtcblx0XHRyZXR1cm4gdmFsdWVPYmplY3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBydW5QaGFzZShmdW5jdE5hbWUsIGFyZ3Mpe1xuXHRcdHZhciBmdW5jID0gdmFsdWVPYmplY3QubXlGdW5jdGlvbnNbZnVuY3ROYW1lXTtcblx0XHRpZihmdW5jKXtcblx0XHRcdGZ1bmMuYXBwbHkodGhpc09iamVjdCwgYXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQkLmVycm9ySGFuZGxlci5zeW50YXhFcnJvcihmdW5jdE5hbWUsIHZhbHVlT2JqZWN0LCBcIkZ1bmN0aW9uIFwiICsgZnVuY3ROYW1lICsgXCIgZG9lcyBub3QgZXhpc3QhXCIpO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlKHNlcmlhbGlzYXRpb24pe1xuXHRcdGJlZXNIZWFsZXIuanNvblRvTmF0aXZlKHNlcmlhbGlzYXRpb24sdmFsdWVPYmplY3QpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiB2YWx1ZU9mKCl7XG5cdFx0dmFyIHJldCA9IHt9O1xuXHRcdHJldC5tZXRhICAgICAgICAgICAgICAgID0gdmFsdWVPYmplY3QubWV0YTtcblx0XHRyZXQucHVibGljVmFycyAgICAgICAgICA9IHZhbHVlT2JqZWN0LnB1YmxpY1ZhcnM7XG5cdFx0cmV0LnByaXZhdGVWYXJzICAgICAgICAgPSB2YWx1ZU9iamVjdC5wcml2YXRlVmFycztcblx0XHRyZXQucHJvdGVjdGVkVmFycyAgICAgICA9IHZhbHVlT2JqZWN0LnByb3RlY3RlZFZhcnM7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGZ1bmN0aW9uIHRvU3RyaW5nICgpe1xuXHRcdHJldHVybiBzd2FybURlYnVnLmNsZWFuRHVtcCh0aGlzT2JqZWN0LnZhbHVlT2YoKSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhcmFsbGVsKGNhbGxiYWNrKXtcblx0XHRyZXR1cm4gcmVxdWlyZShcIi4uL3BhcmFsbGVsSm9pblBvaW50XCIpLmNyZWF0ZUpvaW5Qb2ludCh0aGlzT2JqZWN0LCBjYWxsYmFjaywgJCQuX19pbnRlcm4ubWtBcmdzKGFyZ3VtZW50cywxKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVTZXJpYWwoY2FsbGJhY2spe1xuXHRcdHJldHVybiByZXF1aXJlKFwiLi4vc2VyaWFsSm9pblBvaW50XCIpLmNyZWF0ZVNlcmlhbEpvaW5Qb2ludCh0aGlzT2JqZWN0LCBjYWxsYmFjaywgJCQuX19pbnRlcm4ubWtBcmdzKGFyZ3VtZW50cywxKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNwZWN0KCl7XG5cdFx0cmV0dXJuIHN3YXJtRGVidWcuY2xlYW5EdW1wKHRoaXNPYmplY3QudmFsdWVPZigpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdG9yKCl7XG5cdFx0cmV0dXJuIFN3YXJtRGVzY3JpcHRpb247XG5cdH1cblxuXHRmdW5jdGlvbiBlbnN1cmVMb2NhbElkKCl7XG5cdFx0aWYoIXZhbHVlT2JqZWN0LmxvY2FsSWQpe1xuXHRcdFx0dmFsdWVPYmplY3QubG9jYWxJZCA9IHZhbHVlT2JqZWN0Lm1ldGEuc3dhcm1UeXBlTmFtZSArIFwiLVwiICsgbG9jYWxJZDtcblx0XHRcdGxvY2FsSWQrKztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvYnNlcnZlKGNhbGxiYWNrLCB3YWl0Rm9yTW9yZSwgZmlsdGVyKXtcblx0XHRpZighd2FpdEZvck1vcmUpe1xuXHRcdFx0d2FpdEZvck1vcmUgPSBmdW5jdGlvbiAoKXtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGVuc3VyZUxvY2FsSWQoKTtcblxuXHRcdCQkLlBTS19QdWJTdWIuc3Vic2NyaWJlKHZhbHVlT2JqZWN0LmxvY2FsSWQsIGNhbGxiYWNrLCB3YWl0Rm9yTW9yZSwgZmlsdGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRvSlNPTihwcm9wKXtcblx0XHQvL3ByZXZlbnRpbmcgbWF4IGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRpbmcgb24gcHJveHkgYXV0byByZWZlcmVuY2luZ1xuXHRcdC8vcmVwbGFjZSB7fSBhcyByZXN1bHQgb2YgSlNPTihQcm94eSkgd2l0aCB0aGUgc3RyaW5nIFtPYmplY3QgcHJvdGVjdGVkIG9iamVjdF1cblx0XHRyZXR1cm4gXCJbT2JqZWN0IHByb3RlY3RlZCBvYmplY3RdXCI7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRKU09OKGNhbGxiYWNrKXtcblx0XHRyZXR1cm5cdGJlZXNIZWFsZXIuYXNKU09OKHZhbHVlT2JqZWN0LCBudWxsLCBudWxsLGNhbGxiYWNrKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5vdGlmeShldmVudCl7XG5cdFx0aWYoIWV2ZW50KXtcblx0XHRcdGV2ZW50ID0gdmFsdWVPYmplY3Q7XG5cdFx0fVxuXHRcdGVuc3VyZUxvY2FsSWQoKTtcblx0XHQkJC5QU0tfUHViU3ViLnB1Ymxpc2godmFsdWVPYmplY3QubG9jYWxJZCwgZXZlbnQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TWV0YShuYW1lKXtcblx0XHRyZXR1cm4gdmFsdWVPYmplY3QuZ2V0TWV0YShuYW1lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldE1ldGEobmFtZSwgdmFsdWUpe1xuXHRcdHJldHVybiB2YWx1ZU9iamVjdC5zZXRNZXRhKG5hbWUsIHZhbHVlKTtcblx0fVxuXG5cdHJldC5zZXRNZXRhXHRcdFx0PSBzZXRNZXRhO1xuXHRyZXQuZ2V0TWV0YVx0XHRcdD0gZ2V0TWV0YTtcblx0cmV0LnN3YXJtICAgICAgICAgICA9IHN3YXJtRnVuY3Rpb247XG5cdHJldC5ub3RpZnkgICAgICAgICAgPSBub3RpZnk7XG5cdHJldC5nZXRKU09OICAgIFx0ICAgID0gZ2V0SlNPTjtcblx0cmV0LnRvSlNPTiAgICAgICAgICA9IHRvSlNPTjtcblx0cmV0Lm9ic2VydmUgICAgICAgICA9IG9ic2VydmU7XG5cdHJldC5pbnNwZWN0ICAgICAgICAgPSBpbnNwZWN0O1xuXHRyZXQuam9pbiAgICAgICAgICAgID0gY3JlYXRlUGFyYWxsZWw7XG5cdHJldC5wYXJhbGxlbCAgICAgICAgPSBjcmVhdGVQYXJhbGxlbDtcblx0cmV0LnNlcmlhbCAgICAgICAgICA9IGNyZWF0ZVNlcmlhbDtcblx0cmV0LnZhbHVlT2YgICAgICAgICA9IHZhbHVlT2Y7XG5cdHJldC51cGRhdGUgICAgICAgICAgPSB1cGRhdGU7XG5cdHJldC5ydW5QaGFzZSAgICAgICAgPSBydW5QaGFzZTtcblx0cmV0Lm9uUmV0dXJuICAgICAgICA9IHdhaXRSZXN1bHRzO1xuXHRyZXQub25SZXN1bHQgICAgICAgID0gd2FpdFJlc3VsdHM7XG5cdHJldC5hc3luY1JldHVybiAgICAgPSBhc3luY1JldHVybjtcblx0cmV0LnJldHVybiAgICAgICAgICA9IGFzeW5jUmV0dXJuO1xuXHRyZXQuZ2V0SW5uZXJWYWx1ZSAgID0gZ2V0SW5uZXJWYWx1ZTtcblx0cmV0LmhvbWUgICAgICAgICAgICA9IGhvbWU7XG5cdHJldC50b1N0cmluZyAgICAgICAgPSB0b1N0cmluZztcblx0cmV0LmNvbnN0cnVjdG9yICAgICA9IGNvbnN0cnVjdG9yO1xuXHRyZXQuc2V0TWV0YWRhdGFcdFx0PSB2YWx1ZU9iamVjdC5zZXRNZXRhLmJpbmQodmFsdWVPYmplY3QpO1xuXHRyZXQuZ2V0TWV0YWRhdGFcdFx0PSB2YWx1ZU9iamVjdC5nZXRNZXRhLmJpbmQodmFsdWVPYmplY3QpO1xuXG5cdHJldC5hdXRvSW5pdFx0XHQ9IG51bGw7XG5cdHJldHVybiByZXQ7XG5cbn07XG4iLCJleHBvcnRzLmNyZWF0ZUZvck9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0LCBsb2NhbElkKXtcblx0dmFyIHJldCA9IHJlcXVpcmUoXCIuL2Jhc2VcIikuY3JlYXRlRm9yT2JqZWN0KHZhbHVlT2JqZWN0LCB0aGlzT2JqZWN0LCBsb2NhbElkKTtcblxuXHRyZXQuc3dhcm0gICAgICAgICAgID0gbnVsbDtcblx0cmV0Lm9uUmV0dXJuICAgICAgICA9IG51bGw7XG5cdHJldC5vblJlc3VsdCAgICAgICAgPSBudWxsO1xuXHRyZXQuYXN5bmNSZXR1cm4gICAgID0gbnVsbDtcblx0cmV0LnJldHVybiAgICAgICAgICA9IG51bGw7XG5cdHJldC5ob21lICAgICAgICAgICAgPSBudWxsO1xuXG5cdHJldHVybiByZXQ7XG59OyIsImV4cG9ydHMuY3JlYXRlRm9yT2JqZWN0ID0gZnVuY3Rpb24odmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpe1xuXHR2YXIgcmV0ID0gcmVxdWlyZShcIi4vYmFzZVwiKS5jcmVhdGVGb3JPYmplY3QodmFsdWVPYmplY3QsIHRoaXNPYmplY3QsIGxvY2FsSWQpO1xuXG5cdHJldC5zd2FybSAgICAgICAgICAgPSBudWxsO1xuXHRyZXQub25SZXR1cm4gICAgICAgID0gbnVsbDtcblx0cmV0Lm9uUmVzdWx0ICAgICAgICA9IG51bGw7XG5cdHJldC5hc3luY1JldHVybiAgICAgPSBudWxsO1xuXHRyZXQucmV0dXJuICAgICAgICAgID0gbnVsbDtcblx0cmV0LmhvbWUgICAgICAgICAgICA9IG51bGw7XG5cdHJldC5hdXRvSW5pdCAgICAgICAgPSBmdW5jdGlvbigpe1xuXHRcdHRoaXNPYmplY3QudHJhbnNhY3Rpb24gPSAkJC5ibG9ja2NoYWluLmJlZ2luVHJhbnNhY3Rpb24odGhpc09iamVjdCk7XG5cdH07XG5cdHJldC5pc1BlcnNpc3RlZCAgXHQ9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpc09iamVjdC5nZXRNZXRhZGF0YSgncGVyc2lzdGVkJykgPT09IHRydWU7XG5cdH07XG5cblx0cmV0dXJuIHJldDtcbn07IiwibGV0IGxvZ2dlciA9IGNvbnNvbGU7XG5cbmlmIChwcm9jZXNzLmVudi5OT19MT0dTICE9PSAndHJ1ZScpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQU0tMb2dnZXJNb2R1bGUgPSByZXF1aXJlKCdwc2tsb2dnZXInKTtcbiAgICAgICAgY29uc3QgUFNLTG9nZ2VyID0gUFNLTG9nZ2VyTW9kdWxlLlBTS0xvZ2dlcjtcbiAgICAgICAgXG4gICAgICAgIGxvZ2dlciA9IFBTS0xvZ2dlci5nZXRMb2dnZXIoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgJCQgbG9nZ2VyIGlzIHVzZWQgaW5zdGVhZCBvZiBjb25zb2xlXG4gICAgICAgIFBTS0xvZ2dlck1vZHVsZS5vdmVyd3JpdGVDb25zb2xlKCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0xvZ2dlciBpbml0IHN1Y2Nlc3NmdWwnLCBwcm9jZXNzLnBpZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0xvZ2dlciBub3QgYXZhaWxhYmxlLCB1c2luZyBjb25zb2xlJywgZSk7XG4gICAgICAgIGxvZ2dlciA9IGNvbnNvbGU7XG4gICAgfVxufSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygnRW52aXJvbm1lbnQgZmxhZyBOT19MT0dTIGlzIHNldCwgbG9nZ2luZyB0byBjb25zb2xlJyk7XG59XG5cbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sID0gZnVuY3Rpb24gKG5ld1N5bWJvbCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICQkW25ld1N5bWJvbF0gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoJCQsIG5ld1N5bWJvbCwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIlJlZnVzaW5nIHRvIG92ZXJ3cml0ZSAkJC5cIiArIG5ld1N5bWJvbCk7XG4gICAgfVxufTtcblxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJhdXRvVGhyb3dcIiwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59KTtcblxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJpZ25vcmVFcnJvclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICAkJC5lcnJvcihlcnIpO1xuICAgIH1cbn0pO1xuXG4kJC5yZWdpc3Rlckdsb2JhbFN5bWJvbChcImV4Y2VwdGlvblwiLCBmdW5jdGlvbiAobWVzc2FnZSwgdHlwZSkge1xuICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59KTtcblxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJlcnJcIiwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBsb2dnZXIuZXJyb3IoLi4uYXJncyk7XG59KTtcblxuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJ3YXJuXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbG9nZ2VyLndhcm4oLi4uYXJncyk7XG59KTtcblxuLyogYSBmZWF0dXJlIGlzIHBsYW5uZWQgYnV0IG5vdCBpbXBsZW1lbnRlZCAoZHVyaW5nIGRldmVsb3BtZW50KSBidXRcbmFsc28gaXQgY291bGQgcmVtYWluIGluIHByb2R1Y3Rpb24gYW5kIHNob3VsZCBiZSBmbGFnZ2VkIGFzYXAqL1xuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJpbmNvbXBsZXRlXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbG9nZ2VyLndhcm4oLi4uYXJncyk7XG59KTtcblxuLyogdXNlZCBkdXJpbmcgZGV2ZWxvcG1lbnQgYW5kIHdoZW4gdHJ5aW5nIHRvIGRpc2NvdmVyIGVsdXNpdmUgZXJyb3JzKi9cbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwiYXNzZXJ0XCIsIGZ1bmN0aW9uICh2YWx1ZSwgZXhwbGFpbldoeSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0IGZhbHNlIFwiICsgZXhwbGFpbldoeSk7XG4gICAgfVxufSk7XG5cbi8qIGVuYWJsZS9kaXNhYmFsZSBmbGFncyB0aGF0IGNvbnRyb2wgcHNrIGJlaGF2aW91ciovXG4kJC5yZWdpc3Rlckdsb2JhbFN5bWJvbChcImZsYWdzXCIsIGZ1bmN0aW9uIChmbGFnTmFtZSwgdmFsdWUpIHtcbiAgICAkJC5pbmNvbXBsZXRlKFwiZmxhZ3MgaGFuZGxpbmcgbm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5cbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwib2Jzb2xldGVcIiwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBsb2dnZXIubG9nKC4uLmFyZ3MpO1xufSk7XG5cbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwibG9nXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbG9nZ2VyLmxvZyguLi5hcmdzKTtcbn0pO1xuXG4kJC5yZWdpc3Rlckdsb2JhbFN5bWJvbChcInN5bnRheEVycm9yXCIsIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbG9nZ2VyLmxvZyguLi5hcmdzKTtcbn0pO1xuXG4vKiBsb2cgdW5rbm93biBleGNlcHRpb25zKi9cbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwidW5rbm93bkV4Y2VwdGlvblwiLCBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGxvZ2dlci5sb2coLi4uYXJncyk7XG59KTtcblxuLyogUHJpdmF0ZVNreSBldmVudCwgdXNlZCBieSBtb25pdG9yaW5nIGFuZCBzdGF0aXN0aWNzKi9cbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwiZXZlbnRcIiwgZnVuY3Rpb24gKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKGxvZ2dlci5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSkge1xuICAgICAgICBsb2dnZXIuZXZlbnQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG59KTtcblxuLyogKi9cbiQkLnJlZ2lzdGVyR2xvYmFsU3ltYm9sKFwicmVkaXJlY3RMb2dcIiwgZnVuY3Rpb24obG9nVHlwZSwgbG9nT2JqZWN0KSB7XG4gICAgbG9nZ2VyLnJlZGlyZWN0KGxvZ1R5cGUsIGxvZ09iamVjdCk7XG59KTtcblxuLyogbG9nIHRocm90dGxpbmcgZXZlbnQgLy8gaXQgaXMganVzdCBhbiBldmVudD8qL1xuJCQucmVnaXN0ZXJHbG9iYWxTeW1ib2woXCJ0aHJvdHRsaW5nRXZlbnRcIiwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBsb2dnZXIubG9nKC4uLmFyZ3MpO1xufSk7XG4iLCJcbm1vZHVsZS5leHBvcnRzLmluaXQgPSBmdW5jdGlvbihzZiwgbG9nZ2VyKXtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBoYW5kbGVyIGZvciBmYWlsZWQgYXNzZXJ0cy4gVGhlIGhhbmRsZXIgaXMgZG9pbmcgbG9nZ2luZyBhbmQgaXMgdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIGV4cGxhbmF0aW9uIHtTdHJpbmd9IC0gZmFpbGluZyByZWFzb24gbWVzc2FnZS5cbiAgICAgKi9cbiAgICBzZi5leGNlcHRpb25zLnJlZ2lzdGVyKCdhc3NlcnRGYWlsJywgZnVuY3Rpb24oZXhwbGFuYXRpb24pe1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJBc3NlcnQgb3IgaW52YXJpYW50IGhhcyBmYWlsZWQgXCIgKyAoZXhwbGFuYXRpb24gPyBleHBsYW5hdGlvbiA6IFwiXCIpO1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGxvZ2dlci5yZWNvcmRBc3NlcnQoJ1tGYWlsXSAnICsgbWVzc2FnZSwgZXJyLCB0cnVlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJpbmcgYXNzZXJ0IGZvciBlcXVhbGl0eS4gSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHYxIHtTdHJpbmd8TnVtYmVyfE9iamVjdH0gLSBmaXJzdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB2MSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IC0gc2Vjb25kIHZhbHVlXG4gICAgICogQHBhcmFtIGV4cGxhbmF0aW9uIHtTdHJpbmd9IC0gZmFpbGluZyByZWFzb24gbWVzc2FnZSBpbiBjYXNlIHRoZSBhc3NlcnQgZmFpbHMuXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdlcXVhbCcsIGZ1bmN0aW9uKHYxICwgdjIsIGV4cGxhbmF0aW9uKXtcbiAgICAgICAgaWYodjEgIT09IHYyKXtcbiAgICAgICAgICAgIGlmKCFleHBsYW5hdGlvbil7XG4gICAgICAgICAgICAgICAgZXhwbGFuYXRpb24gPSAgXCJBc3NlcnRpb24gZmFpbGVkOiBbXCIgKyB2MSArIFwiICE9PSBcIiArIHYyICsgXCJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGluZXF1YWxpdHkuIElmIGNoZWNrIGZhaWxzLCB0aGUgYXNzZXJ0RmFpbCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB2MSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IC0gZmlyc3QgdmFsdWVcbiAgICAgKiBAcGFyYW0gdjEge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fSAtIHNlY29uZCB2YWx1ZVxuICAgICAqIEBwYXJhbSBleHBsYW5hdGlvbiB7U3RyaW5nfSAtIGZhaWxpbmcgcmVhc29uIG1lc3NhZ2UgaW4gY2FzZSB0aGUgYXNzZXJ0IGZhaWxzXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdub3RFcXVhbCcsIGZ1bmN0aW9uKHYxLCB2MiwgZXhwbGFuYXRpb24pe1xuICAgICAgICBpZih2MSA9PT0gdjIpe1xuICAgICAgICAgICAgaWYoIWV4cGxhbmF0aW9uKXtcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBbXCIrIHYxICsgXCIgPT0gXCIgKyB2MiArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2YuZXhjZXB0aW9ucy5hc3NlcnRGYWlsKGV4cGxhbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJpbmcgYXNzZXJ0IGZvciBldmFsdWF0aW5nIGFuIGV4cHJlc3Npb24gdG8gdHJ1ZS4gSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIGIge0Jvb2xlYW59IC0gcmVzdWx0IG9mIGFuIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlIGluIGNhc2UgdGhlIGFzc2VydCBmYWlsc1xuICAgICAqL1xuICAgIHNmLmFzc2VydC5hZGRDaGVjaygndHJ1ZScsIGZ1bmN0aW9uKGIsIGV4cGxhbmF0aW9uKXtcbiAgICAgICAgaWYoIWIpe1xuICAgICAgICAgICAgaWYoIWV4cGxhbmF0aW9uKXtcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBleHByZXNzaW9uIGlzIGZhbHNlIGJ1dCBpcyBleHBlY3RlZCB0byBiZSB0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGV2YWx1YXRpbmcgYW4gZXhwcmVzc2lvbiB0byBmYWxzZS4gSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIGIge0Jvb2xlYW59IC0gcmVzdWx0IG9mIGFuIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlIGluIGNhc2UgdGhlIGFzc2VydCBmYWlsc1xuICAgICAqL1xuICAgIHNmLmFzc2VydC5hZGRDaGVjaygnZmFsc2UnLCBmdW5jdGlvbihiLCBleHBsYW5hdGlvbil7XG4gICAgICAgIGlmKGIpe1xuICAgICAgICAgICAgaWYoIWV4cGxhbmF0aW9uKXtcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBleHByZXNzaW9uIGlzIHRydWUgYnV0IGlzIGV4cGVjdGVkIHRvIGJlIGZhbHNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGV2YWx1YXRpbmcgYSB2YWx1ZSB0byBudWxsLiBJZiBjaGVjayBmYWlscywgdGhlIGFzc2VydEZhaWwgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0gYiB7Qm9vbGVhbn0gLSByZXN1bHQgb2YgYW4gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBleHBsYW5hdGlvbiB7U3RyaW5nfSAtIGZhaWxpbmcgcmVhc29uIG1lc3NhZ2UgaW4gY2FzZSB0aGUgYXNzZXJ0IGZhaWxzXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdpc051bGwnLCBmdW5jdGlvbih2MSwgZXhwbGFuYXRpb24pe1xuICAgICAgICBpZih2MSAhPT0gbnVsbCl7XG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGV2YWx1YXRpbmcgYSB2YWx1ZSB0byBiZSBub3QgbnVsbC4gSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIGIge0Jvb2xlYW59IC0gcmVzdWx0IG9mIGFuIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gZXhwbGFuYXRpb24ge1N0cmluZ30gLSBmYWlsaW5nIHJlYXNvbiBtZXNzYWdlIGluIGNhc2UgdGhlIGFzc2VydCBmYWlsc1xuICAgICAqL1xuICAgIHNmLmFzc2VydC5hZGRDaGVjaygnbm90TnVsbCcsIGZ1bmN0aW9uKHYxICwgZXhwbGFuYXRpb24pe1xuICAgICAgICBpZih2MSA9PT0gbnVsbCAmJiB0eXBlb2YgdjEgPT09IFwib2JqZWN0XCIpe1xuICAgICAgICAgICAgc2YuZXhjZXB0aW9ucy5hc3NlcnRGYWlsKGV4cGxhbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0IGFyZSBvd24gcHJvcGVydGllcyBvZiB0aGUgZmlyc3Qgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBmaXJzdE9iaiB7T2JqZWN0fSAtIGZpcnN0IG9iamVjdFxuICAgICAqIEBwYXJhbSBzZWNvbmRPYmp7T2JqZWN0fSAtIHNlY29uZCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSByZXR1cm5zIHRydWUsIGlmIHRoZSBjaGVjayBoYXMgcGFzc2VkIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RIYXNGaWVsZHMoZmlyc3RPYmosIHNlY29uZE9iail7XG4gICAgICAgIGZvcihsZXQgZmllbGQgaW4gc2Vjb25kT2JqKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RPYmouaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0T2JqW2ZpZWxkXSAhPT0gc2Vjb25kT2JqW2ZpZWxkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2JqZWN0c0FyZUVxdWFsKGZpcnN0T2JqLCBzZWNvbmRPYmopIHtcbiAgICAgICAgbGV0IGFyZUVxdWFsID0gdHJ1ZTtcbiAgICAgICAgaWYoZmlyc3RPYmogIT09IHNlY29uZE9iaikge1xuICAgICAgICAgICAgaWYodHlwZW9mIGZpcnN0T2JqICE9PSB0eXBlb2Ygc2Vjb25kT2JqKSB7XG4gICAgICAgICAgICAgICAgYXJlRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdE9iaikgJiYgQXJyYXkuaXNBcnJheShzZWNvbmRPYmopKSB7XG5cdCAgICAgICAgICAgIGZpcnN0T2JqLnNvcnQoKTtcblx0ICAgICAgICAgICAgc2Vjb25kT2JqLnNvcnQoKTtcblx0XHQgICAgICAgIGlmIChmaXJzdE9iai5sZW5ndGggIT09IHNlY29uZE9iai5sZW5ndGgpIHtcblx0XHRcdCAgICAgICAgYXJlRXF1YWwgPSBmYWxzZTtcblx0XHQgICAgICAgIH0gZWxzZSB7XG5cdFx0XHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RPYmoubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0ICAgICAgICBpZiAoIW9iamVjdHNBcmVFcXVhbChmaXJzdE9ialtpXSwgc2Vjb25kT2JqW2ldKSkge1xuXHRcdFx0XHRcdCAgICAgICAgYXJlRXF1YWwgPSBmYWxzZTtcblx0XHRcdFx0XHQgICAgICAgIGJyZWFrO1xuXHRcdFx0XHQgICAgICAgIH1cblx0XHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZigodHlwZW9mIGZpcnN0T2JqID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzZWNvbmRPYmogPT09ICdmdW5jdGlvbicpIHx8XG5cdFx0ICAgICAgICAoZmlyc3RPYmogaW5zdGFuY2VvZiBEYXRlICYmIHNlY29uZE9iaiBpbnN0YW5jZW9mIERhdGUpIHx8XG5cdFx0ICAgICAgICAoZmlyc3RPYmogaW5zdGFuY2VvZiBSZWdFeHAgJiYgc2Vjb25kT2JqIGluc3RhbmNlb2YgUmVnRXhwKSB8fFxuXHRcdCAgICAgICAgKGZpcnN0T2JqIGluc3RhbmNlb2YgU3RyaW5nICYmIHNlY29uZE9iaiBpbnN0YW5jZW9mIFN0cmluZykgfHxcblx0XHQgICAgICAgIChmaXJzdE9iaiBpbnN0YW5jZW9mIE51bWJlciAmJiBzZWNvbmRPYmogaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gZmlyc3RPYmoudG9TdHJpbmcoKSA9PT0gc2Vjb25kT2JqLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGZpcnN0T2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2Vjb25kT2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGFyZUVxdWFsID0gb2JqZWN0SGFzRmllbGRzKGZpcnN0T2JqLCBzZWNvbmRPYmopO1xuICAgICAgICAgICAgLy8gaXNOYU4odW5kZWZpbmVkKSByZXR1cm5zIHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZihpc05hTihmaXJzdE9iaikgJiYgaXNOYU4oc2Vjb25kT2JqKSAmJiB0eXBlb2YgZmlyc3RPYmogPT09ICdudW1iZXInICYmIHR5cGVvZiBzZWNvbmRPYmogPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYXJlRXF1YWwgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmVFcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZUVxdWFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgZXZhbHVhdGluZyBpZiBhbGwgcHJvcGVydGllcyBvZiB0aGUgc2Vjb25kIG9iamVjdCBhcmUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdC5cbiAgICAgKiBJZiBjaGVjayBmYWlscywgdGhlIGFzc2VydEZhaWwgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0gZmlyc3RPYmoge09iamVjdH0gLSBmaXJzdCBvYmplY3RcbiAgICAgKiBAcGFyYW0gc2Vjb25kT2Jqe09iamVjdH0gLSBzZWNvbmQgb2JqZWN0XG4gICAgICogQHBhcmFtIGV4cGxhbmF0aW9uIHtTdHJpbmd9IC0gZmFpbGluZyByZWFzb24gbWVzc2FnZSBpbiBjYXNlIHRoZSBhc3NlcnQgZmFpbHNcbiAgICAgKi9cbiAgICBzZi5hc3NlcnQuYWRkQ2hlY2soXCJvYmplY3RIYXNGaWVsZHNcIiwgZnVuY3Rpb24oZmlyc3RPYmosIHNlY29uZE9iaiwgZXhwbGFuYXRpb24pe1xuICAgICAgICBpZighb2JqZWN0SGFzRmllbGRzKGZpcnN0T2JqLCBzZWNvbmRPYmopKSB7XG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGV2YWx1YXRpbmcgaWYgYWxsIGVsZW1lbnQgZnJvbSB0aGUgc2Vjb25kIGFycmF5IGFyZSBwcmVzZW50IGluIHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKiBEZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGUgZWxlbWVudHMgb2YgdGhlIGFycmF5IGlzIHVzZWQuXG4gICAgICogSWYgY2hlY2sgZmFpbHMsIHRoZSBhc3NlcnRGYWlsIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIGZpcnN0QXJyYXkge0FycmF5fS0gZmlyc3QgYXJyYXlcbiAgICAgKiBAcGFyYW0gc2Vjb25kQXJyYXkge0FycmF5fSAtIHNlY29uZCBhcnJheVxuICAgICAqIEBwYXJhbSBleHBsYW5hdGlvbiB7U3RyaW5nfSAtIGZhaWxpbmcgcmVhc29uIG1lc3NhZ2UgaW4gY2FzZSB0aGUgYXNzZXJ0IGZhaWxzXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKFwiYXJyYXlzTWF0Y2hcIiwgZnVuY3Rpb24oZmlyc3RBcnJheSwgc2Vjb25kQXJyYXksIGV4cGxhbmF0aW9uKXtcbiAgICAgICAgaWYoZmlyc3RBcnJheS5sZW5ndGggIT09IHNlY29uZEFycmF5Lmxlbmd0aCl7XG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmFzc2VydEZhaWwoZXhwbGFuYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb2JqZWN0c0FyZUVxdWFsKGZpcnN0QXJyYXksIHNlY29uZEFycmF5KTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGFycmF5c0RvbnRNYXRjaCA9IHNlY29uZEFycmF5LmV2ZXJ5KGVsZW1lbnQgPT4gZmlyc3RBcnJheS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMSk7XG4gICAgICAgICAgICAvLyBsZXQgYXJyYXlzRG9udE1hdGNoID0gc2Vjb25kQXJyYXkuc29tZShmdW5jdGlvbiAoZXhwZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyAgICAgbGV0IGZvdW5kID0gZmlyc3RBcnJheS5zb21lKGZ1bmN0aW9uKHJlc3VsdEVsZW1lbnQpe1xuICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm4gb2JqZWN0SGFzRmllbGRzKHJlc3VsdEVsZW1lbnQsZXhwZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gZm91bmQgPT09IGZhbHNlO1xuICAgICAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgICAgIGlmKCFyZXN1bHQpe1xuICAgICAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuYXNzZXJ0RmFpbChleHBsYW5hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGFkZGVkIG1haW5seSBmb3IgdGVzdCBwdXJwb3NlcywgYmV0dGVyIHRlc3QgZnJhbWV3b3JrcyBsaWtlIG1vY2hhIGNvdWxkIGJlIG11Y2ggYmV0dGVyXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGNoZWNraW5nIGlmIGEgZnVuY3Rpb24gaXMgZmFpbGluZy5cbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gaXMgdGhyb3dpbmcgYW4gZXhjZXB0aW9uLCB0aGUgdGVzdCBpcyBwYXNzZWQgb3IgZmFpbGVkIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0gdGVzdE5hbWUge1N0cmluZ30gLSB0ZXN0IG5hbWUgb3IgZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gZnVuYyB7RnVuY3Rpb259IC0gZnVuY3Rpb24gdG8gYmUgaW52b2tlZFxuICAgICAqL1xuICAgIHNmLmFzc2VydC5hZGRDaGVjaygnZmFpbCcsIGZ1bmN0aW9uKHRlc3ROYW1lLCBmdW5jKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICAgICAgbG9nZ2VyLnJlY29yZEFzc2VydChcIltGYWlsXSBcIiArIHRlc3ROYW1lKTtcbiAgICAgICAgfSBjYXRjaChlcnIpe1xuICAgICAgICAgICAgbG9nZ2VyLnJlY29yZEFzc2VydChcIltQYXNzXSBcIiArIHRlc3ROYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJpbmcgYXNzZXJ0IGZvciBjaGVja2luZyBpZiBhIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggbm8gZXhjZXB0aW9ucy5cbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gaXMgbm90IHRocm93aW5nIGFueSBleGNlcHRpb24sIHRoZSB0ZXN0IGlzIHBhc3NlZCBvciBmYWlsZWQgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB0ZXN0TmFtZSB7U3RyaW5nfSAtIHRlc3QgbmFtZSBvciBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSBmdW5jIHtGdW5jdGlvbn0gLSBmdW5jdGlvbiB0byBiZSBpbnZva2VkXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdwYXNzJywgZnVuY3Rpb24odGVzdE5hbWUsIGZ1bmMpe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KFwiW1Bhc3NdIFwiICsgdGVzdE5hbWUpO1xuICAgICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KFwiW0ZhaWxdIFwiICsgdGVzdE5hbWUsIGVyci5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB0aGUgcGFzcyBhc3NlcnQuXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFsaWFzKCd0ZXN0JywgJ3Bhc3MnKTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgY2hlY2tpbmcgaWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBleGVjdXRlZCBiZWZvcmUgdGltZW91dCBpcyByZWFjaGVkIHdpdGhvdXQgYW55IGV4Y2VwdGlvbnMuXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIGlzIHRocm93aW5nIGFueSBleGNlcHRpb24gb3IgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgdGhlIHRlc3QgaXMgZmFpbGVkIG9yIHBhc3NlZCBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHRlc3ROYW1lIHtTdHJpbmd9IC0gdGVzdCBuYW1lIG9yIGRlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufSAtIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAgICAgKiBAcGFyYW0gdGltZW91dCB7TnVtYmVyfSAtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0aW1lb3V0IGNoZWNrLiBEZWZhdWx0IHRvIDUwMG1zLlxuICAgICAqL1xuICAgIHNmLmFzc2VydC5hZGRDaGVjaygnY2FsbGJhY2snLCBmdW5jdGlvbih0ZXN0TmFtZSwgZnVuYywgdGltZW91dCl7XG5cbiAgICAgICAgaWYoIWZ1bmMgfHwgdHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIHVzYWdlIG9mIGFzc2VydC5jYWxsYmFjayFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGltZW91dCl7XG4gICAgICAgICAgICB0aW1lb3V0ID0gNTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhc3NlZCA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpe1xuICAgICAgICAgICAgaWYoIXBhc3NlZCl7XG4gICAgICAgICAgICAgICAgcGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KFwiW1Bhc3NdIFwiICsgdGVzdE5hbWUpO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NUZXN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5yZWNvcmRBc3NlcnQoXCJbRmFpbCAobXVsdGlwbGUgY2FsbHMpXSBcIiArIHRlc3ROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgZnVuYyhjYWxsYmFjayk7XG4gICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGxvZ2dlci5yZWNvcmRBc3NlcnQoXCJbRmFpbF0gXCIgKyB0ZXN0TmFtZSwgIGVyciwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzVGVzdChmb3JjZSl7XG4gICAgICAgICAgICBpZighcGFzc2VkKXtcbiAgICAgICAgICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KFwiW0ZhaWwgVGltZW91dF0gXCIgKyB0ZXN0TmFtZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChzdWNjZXNzVGVzdCwgdGltZW91dCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBhc3NlcnQgZm9yIGNoZWNraW5nIGlmIGFuIGFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQgaW4gYSB3YXRlcmZhbGwgbWFubmVyLFxuICAgICAqIGJlZm9yZSB0aW1lb3V0IGlzIHJlYWNoZWQgd2l0aG91dCBhbnkgZXhjZXB0aW9ucy5cbiAgICAgKiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBpcyB0aHJvd2luZyBhbnkgZXhjZXB0aW9uIG9yIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHRoZSB0ZXN0IGlzIGZhaWxlZCBvciBwYXNzZWQgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB0ZXN0TmFtZSB7U3RyaW5nfSAtIHRlc3QgbmFtZSBvciBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSBmdW5jIHtGdW5jdGlvbn0gLSBmdW5jdGlvbiB0byBiZSBpbnZva2VkXG4gICAgICogQHBhcmFtIHRpbWVvdXQge051bWJlcn0gLSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZvciB0aGUgdGltZW91dCBjaGVjay4gRGVmYXVsdCB0byA1MDBtcy5cbiAgICAgKi9cbiAgICBzZi5hc3NlcnQuYWRkQ2hlY2soJ3N0ZXBzJywgZnVuY3Rpb24odGVzdE5hbWUsIGFyciwgdGltZW91dCl7XG4gICAgICAgIGlmKCF0aW1lb3V0KXtcbiAgICAgICAgICAgIHRpbWVvdXQgPSA1MDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFN0ZXAgPSAwO1xuICAgICAgICB2YXIgcGFzc2VkID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpe1xuICAgICAgICAgICAgaWYoY3VycmVudFN0ZXAgPT09IGFyci5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHBhc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnJlY29yZEFzc2VydChcIltQYXNzXSBcIiArIHRlc3ROYW1lICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZnVuYyA9IGFycltjdXJyZW50U3RlcF07XG4gICAgICAgICAgICBjdXJyZW50U3RlcCsrO1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGZ1bmMobmV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnJlY29yZEFzc2VydChcIltGYWlsXSBcIiArIHRlc3ROYW1lICArIFwiIFthdCBzdGVwIFwiICsgY3VycmVudFN0ZXAgKyBcIl1cIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3NUZXN0KGZvcmNlKXtcbiAgICAgICAgICAgIGlmKCFwYXNzZWQpe1xuICAgICAgICAgICAgICAgIGxvZ2dlci5yZWNvcmRBc3NlcnQoXCJbRmFpbCBUaW1lb3V0XSBcIiArIHRlc3ROYW1lICArIFwiIFthdCBzdGVwIFwiICsgY3VycmVudFN0ZXAgKyBcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KHN1Y2Nlc3NUZXN0LCB0aW1lb3V0KTtcbiAgICAgICAgbmV4dCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHRoZSBzdGVwcyBhc3NlcnQuXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFsaWFzKCd3YXRlcmZhbGwnLCAnc3RlcHMnKTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyaW5nIGFzc2VydCBmb3IgYXN5bmNocm9ub3VzbHkgcHJpbnRpbmcgYWxsIGV4ZWN1dGlvbiBzdW1tYXJ5IGZyb20gbG9nZ2VyLmR1bXBXaHlzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIHtTdHJpbmd9IC0gbWVzc2FnZSB0byBiZSByZWNvcmRlZFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IHtOdW1iZXJ9IC0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRpbWVvdXQgY2hlY2suIERlZmF1bHQgdG8gNTAwbXMuXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdlbmQnLCBmdW5jdGlvbih0aW1lb3V0LCBzaWxlbmNlKXtcbiAgICAgICAgaWYoIXRpbWVvdXQpe1xuICAgICAgICAgICAgdGltZW91dCA9IDEwMDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYobG9nZ2VyLmR1bXBXaHlzKXtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZHVtcFdoeXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRpb25TdW1tYXJ5ID0gYy5nZXRFeGVjdXRpb25TdW1tYXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGV4ZWN1dGlvblN1bW1hcnksIG51bGwsIDQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIXNpbGVuY2Upe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRm9yY2luZyBleGl0IGFmdGVyXCIsIHRpbWVvdXQsIFwibXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJpbmcgYXNzZXJ0IGZvciBwcmludGluZyBhIG1lc3NhZ2UgYW5kIGFzeW5jaHJvbm91c2x5IHByaW50aW5nIGFsbCBsb2dzIGZyb20gbG9nZ2VyLmR1bXBXaHlzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIHtTdHJpbmd9IC0gbWVzc2FnZSB0byBiZSByZWNvcmRlZFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IHtOdW1iZXJ9IC0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRpbWVvdXQgY2hlY2suIERlZmF1bHQgdG8gNTAwbXMuXG4gICAgICovXG4gICAgc2YuYXNzZXJ0LmFkZENoZWNrKCdiZWdpbicsIGZ1bmN0aW9uKG1lc3NhZ2UsIHRpbWVvdXQpe1xuICAgICAgICBsb2dnZXIucmVjb3JkQXNzZXJ0KG1lc3NhZ2UpO1xuICAgICAgICBzZi5hc3NlcnQuZW5kKHRpbWVvdXQsIHRydWUpO1xuICAgIH0pO1xufTsiLCIvKlxuICAgIGNoZWNrcyBhcmUgbGlrZSBhc3NlcnRzIGJ1dCBhcmUgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBwcm9kdWN0aW9uIGNvZGUgdG8gaGVscCBkZWJ1Z2dpbmcgYW5kIHNpZ25hbGluZyB3cm9uZyBiZWhhdmlvdXJzXG5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbihzZil7XG4gICAgc2YuZXhjZXB0aW9ucy5yZWdpc3RlcignY2hlY2tGYWlsJywgZnVuY3Rpb24oZXhwbGFuYXRpb24sIGVycil7XG4gICAgICAgIHZhciBzdGFjaztcbiAgICAgICAgaWYoZXJyKXtcbiAgICAgICAgICAgIHN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2hlY2sgZmFpbGVkIFwiLCBleHBsYW5hdGlvbiwgc3RhY2spO1xuICAgIH0pO1xuXG4gICAgc2YuY2hlY2suYWRkQ2hlY2soJ2VxdWFsJywgZnVuY3Rpb24odjEgLCB2MiwgZXhwbGFuYXRpb24pe1xuXG4gICAgICAgIGlmKHYxICE9PSB2Mil7XG4gICAgICAgICAgICBpZighZXhwbGFuYXRpb24pe1xuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gIFwiIFtcIisgdjEgKyBcIiAhPSBcIiArIHYyICsgXCJdXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuY2hlY2tGYWlsKGV4cGxhbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBzZi5jaGVjay5hZGRDaGVjaygndHJ1ZScsIGZ1bmN0aW9uKGIsIGV4cGxhbmF0aW9uKXtcbiAgICAgICAgaWYoIWIpe1xuICAgICAgICAgICAgaWYoIWV4cGxhbmF0aW9uKXtcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBleHByZXNzaW9uIGlzIGZhbHNlIGJ1dCBpcyBleHBlY3RlZCB0byBiZSB0cnVlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuY2hlY2tGYWlsKGV4cGxhbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBzZi5jaGVjay5hZGRDaGVjaygnZmFsc2UnLCBmdW5jdGlvbihiLCBleHBsYW5hdGlvbil7XG4gICAgICAgIGlmKGIpe1xuICAgICAgICAgICAgaWYoIWV4cGxhbmF0aW9uKXtcbiAgICAgICAgICAgICAgICBleHBsYW5hdGlvbiA9ICBcIiBleHByZXNzaW9uIGlzIHRydWUgYnV0IGlzIGV4cGVjdGVkIHRvIGJlIGZhbHNlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNmLmV4Y2VwdGlvbnMuY2hlY2tGYWlsKGV4cGxhbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2YuY2hlY2suYWRkQ2hlY2soJ25vdGVxdWFsJywgZnVuY3Rpb24odjEgLCB2MiwgZXhwbGFuYXRpb24pe1xuICAgICAgICBpZih2MSA9PSB2Mil7XG4gICAgICAgICAgICBpZighZXhwbGFuYXRpb24pe1xuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uID0gIFwiIFtcIisgdjEgKyBcIiA9PSBcIiArIHYyICsgXCJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZi5leGNlcHRpb25zLmNoZWNrRmFpbChleHBsYW5hdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLypcbiAgICAgICAgYWRkZWQgbWFpbmx5IGZvciB0ZXN0IHB1cnBvc2VzLCBiZXR0ZXIgdGVzdCBmcmFtZXdvcmtzIGxpa2UgbW9jaGEgY291bGQgYmUgbXVjaCBiZXR0ZXIgOilcbiAgICAqL1xuICAgIHNmLmNoZWNrLmFkZENoZWNrKCdmYWlsJywgZnVuY3Rpb24odGVzdE5hbWUgLGZ1bmMpe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltGYWlsXSBcIiArIHRlc3ROYW1lICk7XG4gICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1Bhc3NdIFwiICsgdGVzdE5hbWUgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBzZi5jaGVjay5hZGRDaGVjaygncGFzcycsIGZ1bmN0aW9uKHRlc3ROYW1lICxmdW5jKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUGFzc10gXCIgKyB0ZXN0TmFtZSApO1xuICAgICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltGYWlsXSBcIiArIHRlc3ROYW1lICAsICBlcnIuc3RhY2spO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIHNmLmNoZWNrLmFsaWFzKCd0ZXN0JywncGFzcycpO1xuXG5cbiAgICBzZi5jaGVjay5hZGRDaGVjaygnY2FsbGJhY2snLCBmdW5jdGlvbih0ZXN0TmFtZSAsZnVuYywgdGltZW91dCl7XG4gICAgICAgIGlmKCF0aW1lb3V0KXtcbiAgICAgICAgICAgIHRpbWVvdXQgPSA1MDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhc3NlZCA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpe1xuICAgICAgICAgICAgaWYoIXBhc3NlZCl7XG4gICAgICAgICAgICAgICAgcGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltQYXNzXSBcIiArIHRlc3ROYW1lICk7XG4gICAgICAgICAgICAgICAgU3VjY2Vzc1Rlc3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbRmFpbCAobXVsdGlwbGUgY2FsbHMpXSBcIiArIHRlc3ROYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgZnVuYyhjYWxsYmFjayk7XG4gICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0ZhaWxdIFwiICsgdGVzdE5hbWUgICwgIGVyci5zdGFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBTdWNjZXNzVGVzdChmb3JjZSl7XG4gICAgICAgICAgICBpZighcGFzc2VkKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltGYWlsIFRpbWVvdXRdIFwiICsgdGVzdE5hbWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoU3VjY2Vzc1Rlc3QsIHRpbWVvdXQpO1xuICAgIH0pO1xuXG5cbiAgICBzZi5jaGVjay5hZGRDaGVjaygnc3RlcHMnLCBmdW5jdGlvbih0ZXN0TmFtZSAsIGFyciwgdGltZW91dCl7XG4gICAgICAgIHZhciAgY3VycmVudFN0ZXAgPSAwO1xuICAgICAgICB2YXIgcGFzc2VkID0gZmFsc2U7XG4gICAgICAgIGlmKCF0aW1lb3V0KXtcbiAgICAgICAgICAgIHRpbWVvdXQgPSA1MDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBuZXh0KCl7XG4gICAgICAgICAgICBpZihjdXJyZW50U3RlcCA9PT0gYXJyLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgcGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltQYXNzXSBcIiArIHRlc3ROYW1lICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmdW5jID0gYXJyW2N1cnJlbnRTdGVwXTtcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwKys7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgZnVuYyhuZXh0KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltGYWlsXSBcIiArIHRlc3ROYW1lICAsXCJcXG5cXHRcIiAsIGVyci5zdGFjayArIFwiXFxuXFx0XCIgLCBcIiBbYXQgc3RlcCBcIiwgY3VycmVudFN0ZXAgKyBcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBTdWNjZXNzVGVzdChmb3JjZSl7XG4gICAgICAgICAgICBpZighcGFzc2VkKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltGYWlsIFRpbWVvdXRdIFwiICsgdGVzdE5hbWUgKyBcIlxcblxcdFwiICwgXCIgW2F0IHN0ZXAgXCIsIGN1cnJlbnRTdGVwKyBcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KFN1Y2Nlc3NUZXN0LCB0aW1lb3V0KTtcbiAgICAgICAgbmV4dCgpO1xuICAgIH0pO1xuXG4gICAgc2YuY2hlY2suYWxpYXMoJ3dhdGVyZmFsbCcsJ3N0ZXBzJyk7XG4gICAgc2YuY2hlY2suYWxpYXMoJ25vdEVxdWFsJywnbm90ZXF1YWwnKTtcblxuICAgIHNmLmNoZWNrLmFkZENoZWNrKCdlbmQnLCBmdW5jdGlvbih0aW1lT3V0LCBzaWxlbmNlKXtcbiAgICAgICAgaWYoIXRpbWVPdXQpe1xuICAgICAgICAgICAgdGltZU91dCA9IDEwMDA7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZighc2lsZW5jZSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3JjaW5nIGV4aXQgYWZ0ZXJcIiwgdGltZU91dCwgXCJtc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICAgICAgfSwgdGltZU91dCk7XG4gICAgfSk7XG5cblxuICAgIHNmLmNoZWNrLmFkZENoZWNrKCdiZWdpbicsIGZ1bmN0aW9uKG1lc3NhZ2UsIHRpbWVPdXQpe1xuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgc2YuY2hlY2suZW5kKHRpbWVPdXQsIHRydWUpO1xuICAgIH0pO1xuXG5cbn07IiwiZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oc2Ype1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyaW5nIHVua25vd24gZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAgICovXG4gICAgc2YuZXhjZXB0aW9ucy5yZWdpc3RlcigndW5rbm93bicsIGZ1bmN0aW9uKGV4cGxhbmF0aW9uKXtcbiAgICAgICAgZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbiB8fCBcIlwiO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJVbmtub3duIGV4Y2VwdGlvblwiICsgZXhwbGFuYXRpb247XG4gICAgICAgIHRocm93KG1lc3NhZ2UpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJpbmcgcmVzZW5kIGV4Y2VwdGlvbiBoYW5kbGVyLlxuICAgICAqL1xuICAgIHNmLmV4Y2VwdGlvbnMucmVnaXN0ZXIoJ3Jlc2VuZCcsIGZ1bmN0aW9uKGV4Y2VwdGlvbnMpe1xuICAgICAgICB0aHJvdyhleGNlcHRpb25zKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyaW5nIG5vdEltcGxlbWVudGVkIGV4Y2VwdGlvbiBoYW5kbGVyLlxuICAgICAqL1xuICAgIHNmLmV4Y2VwdGlvbnMucmVnaXN0ZXIoJ25vdEltcGxlbWVudGVkJywgZnVuY3Rpb24oZXhwbGFuYXRpb24pe1xuICAgICAgICBleHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIm5vdEltcGxlbWVudGVkIGV4Y2VwdGlvblwiICsgZXhwbGFuYXRpb247XG4gICAgICAgIHRocm93KG1lc3NhZ2UpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJpbmcgc2VjdXJpdHkgZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAgICovXG4gICAgc2YuZXhjZXB0aW9ucy5yZWdpc3Rlcignc2VjdXJpdHknLCBmdW5jdGlvbihleHBsYW5hdGlvbil7XG4gICAgICAgIGV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb24gfHwgXCJcIjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2VjdXJpdHkgZXhjZXB0aW9uXCIgKyBleHBsYW5hdGlvbjtcbiAgICAgICAgdGhyb3cobWVzc2FnZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmluZyBkdXBsaWNhdGVEZXBlbmRlbmN5IGV4Y2VwdGlvbiBoYW5kbGVyLlxuICAgICAqL1xuICAgIHNmLmV4Y2VwdGlvbnMucmVnaXN0ZXIoJ2R1cGxpY2F0ZURlcGVuZGVuY3knLCBmdW5jdGlvbih2YXJpYWJsZSl7XG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUgfHwgXCJcIjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiZHVwbGljYXRlRGVwZW5kZW5jeSBleGNlcHRpb25cIiArIHZhcmlhYmxlO1xuICAgICAgICB0aHJvdyhtZXNzYWdlKTtcbiAgICB9KTtcbn07IiwiY29uc3QgTE9HX0xFVkVMUyA9IHtcbiAgICBIQVJEX0VSUk9SOiAgICAgMCwgIC8vIHN5c3RlbSBsZXZlbCBjcml0aWNhbCBlcnJvcjogaGFyZEVycm9yXG4gICAgRVJST1I6ICAgICAgICAgIDEsICAvLyBwb3RlbnRpYWxseSBjYXVzaW5nIHVzZXIncyBkYXRhIGxvb3NpbmcgZXJyb3I6IGVycm9yXG4gICAgTE9HX0VSUk9SOiAgICAgIDIsICAvLyBtaW5vciBhbm5veWFuY2UsIHJlY292ZXJhYmxlIGVycm9yOiAgIGxvZ0Vycm9yXG4gICAgVVhfRVJST1I6ICAgICAgIDMsICAvLyB1c2VyIGV4cGVyaWVuY2UgY2F1c2luZyBpc3N1ZXMgZXJyb3I6ICB1eEVycm9yXG4gICAgV0FSTjogICAgICAgICAgIDQsICAvLyB3YXJuaW5nLHBvc3NpYmxlIGlzdWVzIGJ1dCBzb21laG93IHVuY2xlYXIgYmVoYXZpb3VyOiB3YXJuXG4gICAgSU5GTzogICAgICAgICAgIDUsICAvLyBzdG9yZSBnZW5lcmFsIGluZm8gYWJvdXQgdGhlIHN5c3RlbSB3b3JraW5nOiBpbmZvXG4gICAgREVCVUc6ICAgICAgICAgIDYsICAvLyBzeXN0ZW0gbGV2ZWwgZGVidWc6IGRlYnVnXG4gICAgTE9DQUxfREVCVUc6ICAgIDcsICAvLyBsb2NhbCBub2RlL3NlcnZpY2UgZGVidWc6IGxkZWJ1Z1xuICAgIFVTRVJfREVCVUc6ICAgICA4LCAgLy8gdXNlciBsZXZlbCBkZWJ1ZzsgdWRlYnVnXG4gICAgREVWX0RFQlVHOiAgICAgIDksICAvLyBkZXZlbG9wbWVudCB0aW1lIGRlYnVnOiBkZGVidWdcbiAgICBXSFlTOiAgICAgICAgICAgIDEwLCAvLyB3aHlMb2cgZm9yIGNvZGUgcmVhc29uaW5nXG4gICAgVEVTVF9SRVNVTFQ6ICAgIDExLCAvLyB0ZXN0UmVzdWx0IHRvIGxvZyBydW5uaW5nIHRlc3RzXG59O1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbihzZil7XG5cbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIGxvZyBtZXNzYWdlcyBmcm9tIHZhcmlvdXMgdXNlIGNhc2VzLlxuICAgICAqIEBwYXJhbSByZWNvcmQge1N0cmluZ30gLSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBzZi5sb2dnZXIucmVjb3JkID0gZnVuY3Rpb24ocmVjb3JkKXtcbiAgICAgICAgdmFyIGRpc3BsYXlPbkNvbnNvbGUgPSB0cnVlO1xuICAgICAgICBpZihwcm9jZXNzLnNlbmQpIHtcbiAgICAgICAgICAgIHByb2Nlc3Muc2VuZChyZWNvcmQpO1xuICAgICAgICAgICAgZGlzcGxheU9uQ29uc29sZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGlzcGxheU9uQ29uc29sZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldHR5TG9nID0gSlNPTi5zdHJpbmdpZnkocmVjb3JkLCBudWxsLCAyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHByZXR0eUxvZyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkaW5nIGNhc2UgZm9yIGxvZ2dpbmcgc3lzdGVtIGxldmVsIGNyaXRpY2FsIGVycm9ycy5cbiAgICAgKi9cbiAgICBzZi5sb2dnZXIuYWRkQ2FzZSgnaGFyZEVycm9yJywgZnVuY3Rpb24obWVzc2FnZSwgZXhjZXB0aW9uLCBhcmdzLCBwb3MsIGRhdGEpe1xuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuSEFSRF9FUlJPUiwgJ3N5c3RlbUVycm9yJywgbWVzc2FnZSwgZXhjZXB0aW9uLCB0cnVlLCBhcmdzLCBwb3MsIGRhdGEpKTtcbiAgICB9LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgICdtZXNzYWdlJzonZXhwbGFuYXRpb24nXG4gICAgICAgIH1cbiAgICBdKTtcblxuICAgIC8qKlxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIHBvdGVudGlhbGx5IGNhdXNpbmcgdXNlcidzIGRhdGEgbG9vc2luZyBlcnJvcnMuXG4gICAgICovXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ2Vycm9yJywgZnVuY3Rpb24obWVzc2FnZSwgZXhjZXB0aW9uLCBhcmdzLCBwb3MsIGRhdGEpe1xuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuRVJST1IsICdlcnJvcicsIG1lc3NhZ2UsIGV4Y2VwdGlvbiwgdHJ1ZSwgYXJncywgcG9zLCBkYXRhKSk7XG4gICAgfSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICAnbWVzc2FnZSc6J2V4cGxhbmF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAnZXhjZXB0aW9uJzonZXhjZXB0aW9uJ1xuICAgICAgICB9XG4gICAgXSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyBtaW5vciBhbm5veWFuY2UsIHJlY292ZXJhYmxlIGVycm9ycy5cbiAgICAgKi9cbiAgICBzZi5sb2dnZXIuYWRkQ2FzZSgnbG9nRXJyb3InLCBmdW5jdGlvbihtZXNzYWdlLCBleGNlcHRpb24sIGFyZ3MsIHBvcywgZGF0YSl7XG4gICAgICAgIHNmLmxvZ2dlci5yZWNvcmQoY3JlYXRlRGVidWdSZWNvcmQoTE9HX0xFVkVMUy5MT0dfRVJST1IsICdsb2dFcnJvcicsIG1lc3NhZ2UsIGV4Y2VwdGlvbiwgdHJ1ZSwgYXJncywgcG9zLCBkYXRhKSk7XG4gICAgfSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICAnbWVzc2FnZSc6J2V4cGxhbmF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAnZXhjZXB0aW9uJzonZXhjZXB0aW9uJ1xuICAgICAgICB9XG4gICAgXSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyB1c2VyIGV4cGVyaWVuY2UgY2F1c2luZyBpc3N1ZXMgZXJyb3JzLlxuICAgICAqL1xuICAgIHNmLmxvZ2dlci5hZGRDYXNlKCd1eEVycm9yJywgZnVuY3Rpb24obWVzc2FnZSl7XG4gICAgICAgIHNmLmxvZ2dlci5yZWNvcmQoY3JlYXRlRGVidWdSZWNvcmQoTE9HX0xFVkVMUy5VWF9FUlJPUiwgJ3V4RXJyb3InLCBtZXNzYWdlLCBudWxsLCBmYWxzZSkpO1xuICAgIH0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAgJ21lc3NhZ2UnOidleHBsYW5hdGlvbidcbiAgICAgICAgfVxuICAgIF0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkaW5nIGNhc2UgZm9yIGxvZ2dpbmcgdGhyb3R0bGluZyBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBzZi5sb2dnZXIuYWRkQ2FzZSgndGhyb3R0bGluZycsIGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuV0FSTiwgJ3Rocm90dGxpbmcnLCBtZXNzYWdlLCBudWxsLCBmYWxzZSkpO1xuICAgIH0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAgJ21lc3NhZ2UnOidleHBsYW5hdGlvbidcbiAgICAgICAgfVxuICAgIF0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkaW5nIGNhc2UgZm9yIGxvZ2dpbmcgd2FybmluZywgcG9zc2libGUgaXNzdWVzLCBidXQgc29tZWhvdyB1bmNsZWFyIGJlaGF2aW91cnMuXG4gICAgICovXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ3dhcm5pbmcnLCBmdW5jdGlvbihtZXNzYWdlKXtcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLldBUk4sICd3YXJuaW5nJywgbWVzc2FnZSxudWxsLCBmYWxzZSwgYXJndW1lbnRzLCAwKSk7XG4gICAgfSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICAnbWVzc2FnZSc6J2V4cGxhbmF0aW9uJ1xuICAgICAgICB9XG4gICAgXSk7XG4gICAgXG4gICAgc2YubG9nZ2VyLmFsaWFzKCd3YXJuJywgJ3dhcm5pbmcnKTtcblxuICAgIC8qKlxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIGdlbmVyYWwgaW5mbyBhYm91dCB0aGUgc3lzdGVtIHdvcmtpbmcuXG4gICAgICovXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ2luZm8nLCBmdW5jdGlvbihtZXNzYWdlKXtcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLklORk8sICdpbmZvJywgbWVzc2FnZSxudWxsLCBmYWxzZSwgYXJndW1lbnRzLCAwKSk7XG4gICAgfSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICAnbWVzc2FnZSc6J2V4cGxhbmF0aW9uJ1xuICAgICAgICB9XG4gICAgXSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyBzeXN0ZW0gbGV2ZWwgZGVidWcgbWVzc2FnZXMuXG4gICAgICovXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ2RlYnVnJywgZnVuY3Rpb24obWVzc2FnZSl7XG4gICAgICAgIHNmLmxvZ2dlci5yZWNvcmQoY3JlYXRlRGVidWdSZWNvcmQoTE9HX0xFVkVMUy5ERUJVRywgJ2RlYnVnJywgbWVzc2FnZSxudWxsLCBmYWxzZSwgYXJndW1lbnRzLCAwKSk7XG4gICAgfSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICAnbWVzc2FnZSc6J2V4cGxhbmF0aW9uJ1xuICAgICAgICB9XG4gICAgXSk7XG5cblxuICAgIC8qKlxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIGxvY2FsIG5vZGUvc2VydmljZSBkZWJ1ZyBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBzZi5sb2dnZXIuYWRkQ2FzZSgnbGRlYnVnJywgZnVuY3Rpb24obWVzc2FnZSl7XG4gICAgICAgIHNmLmxvZ2dlci5yZWNvcmQoY3JlYXRlRGVidWdSZWNvcmQoTE9HX0xFVkVMUy5MT0NBTF9ERUJVRywgJ2xkZWJ1ZycsIG1lc3NhZ2UsIG51bGwsIGZhbHNlLCBhcmd1bWVudHMsIDApKTtcbiAgICB9LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgICdtZXNzYWdlJzonZXhwbGFuYXRpb24nXG4gICAgICAgIH1cbiAgICBdKTtcblxuICAgIC8qKlxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIHVzZXIgbGV2ZWwgZGVidWcgbWVzc2FnZXMuXG4gICAgICovXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoJ3VkZWJ1ZycsIGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuVVNFUl9ERUJVRywgJ3VkZWJ1ZycsIG1lc3NhZ2UgLG51bGwsIGZhbHNlLCBhcmd1bWVudHMsIDApKTtcbiAgICB9LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgICdtZXNzYWdlJzonZXhwbGFuYXRpb24nXG4gICAgICAgIH1cbiAgICBdKTtcblxuICAgIC8qKlxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIGRldmVsb3BtZW50IGRlYnVnIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHNmLmxvZ2dlci5hZGRDYXNlKCdkZXZlbCcsIGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgICAgICBzZi5sb2dnZXIucmVjb3JkKGNyZWF0ZURlYnVnUmVjb3JkKExPR19MRVZFTFMuREVWX0RFQlVHLCAnZGV2ZWwnLCBtZXNzYWdlLCBudWxsLCBmYWxzZSwgYXJndW1lbnRzLCAwKSk7XG4gICAgfSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICAnbWVzc2FnZSc6J2V4cGxhbmF0aW9uJ1xuICAgICAgICB9XG4gICAgXSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRpbmcgY2FzZSBmb3IgbG9nZ2luZyBcIndoeXNcIiByZWFzb25pbmcgbWVzc2FnZXMuXG4gICAgICovXG4gICAgc2YubG9nZ2VyLmFkZENhc2UoXCJsb2dXaHlcIiwgZnVuY3Rpb24obG9nT25seUN1cnJlbnRXaHlDb250ZXh0KXtcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLldIWVMsICdsb2d3aHknLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBsb2dPbmx5Q3VycmVudFdoeUNvbnRleHQpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZGluZyBjYXNlIGZvciBsb2dnaW5nIGFzc2VydHMgbWVzc2FnZXMgdG8gcnVubmluZyB0ZXN0cy5cbiAgICAgKi9cbiAgICBzZi5sb2dnZXIuYWRkQ2FzZShcInJlY29yZEFzc2VydFwiLCBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3Isc2hvd1N0YWNrKXtcbiAgICAgICAgc2YubG9nZ2VyLnJlY29yZChjcmVhdGVEZWJ1Z1JlY29yZChMT0dfTEVWRUxTLlRFU1RfUkVTVUxULCAnYXNzZXJ0JywgbWVzc2FnZSwgZXJyb3IsIHNob3dTdGFjaykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyBtZXRob2QgdG8gY3JlYXRlIHN0cnVjdHVyZWQgZGVidWcgcmVjb3JkcyBiYXNlZCBvbiB0aGUgbG9nIGxldmVsLlxuICAgICAqIEBwYXJhbSBsZXZlbCB7TnVtYmVyfSAtIG51bWJlciBmcm9tIDEtMTEsIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGxldmVsIG9mIGF0dGVudGlvbiB0aGF0IGEgbG9nIGVudHJ5IHNob3VsZCBnZXQgZnJvbSBvcGVyYXRpb25zIHBvaW50IG9mIHZpZXdcbiAgICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSAtIGlkZW50aWZpZXIgbmFtZSBmb3IgbG9nIHR5cGVcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSB7U3RyaW5nfSAtIGRlc2NyaXB0aW9uIG9mIHRoZSBkZWJ1ZyByZWNvcmRcbiAgICAgKiBAcGFyYW0gZXhjZXB0aW9uIHtTdHJpbmd9IC0gZXhjZXB0aW9uIGRldGFpbHMgaWYgYW55XG4gICAgICogQHBhcmFtIHNhdmVTdGFjayB7Qm9vbGVhbn0gLSBpZiBzZXQgdG8gdHJ1ZSwgdGhlIGV4Y2VwdGlvbiBjYWxsIHN0YWNrIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGRlYnVnIHJlY29yZFxuICAgICAqIEBwYXJhbSBhcmdzIHtBcnJheX0gLSBhcmd1bWVudHMgb2YgdGhlIGNhbGxlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBwb3Mge051bWJlcn0gLSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBkYXRhIHtTdHJpbmd8TnVtYmVyfEFycmF5fE9iamVjdH0gLSBwYXlsb2FkIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIGxvZ09ubHlDdXJyZW50V2h5Q29udGV4dCAtIGlmIHdoeXMgaXMgZW5hYmxlZCwgb25seSB0aGUgY3VycmVudCBjb250ZXh0IHdpbGwgYmUgbG9nZ2VkXG4gICAgICogQHJldHVybnMgRGVidWcgcmVjb3JkIG1vZGVsIHtPYmplY3R9IHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICogW3JlcXVpcmVkXTogbGV2ZWw6ICosIHR5cGU6ICosIHRpbWVzdGFtcDogbnVtYmVyLCBtZXNzYWdlOiAqLCBkYXRhOiAqIGFuZFxuICAgICAqIFtvcHRpb25hbF06IHN0YWNrOiAqLCBleGNlcHRpb246ICosIGFyZ3M6ICosIHdoeUxvZzogKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURlYnVnUmVjb3JkKGxldmVsLCB0eXBlLCBtZXNzYWdlLCBleGNlcHRpb24sIHNhdmVTdGFjaywgYXJncywgcG9zLCBkYXRhLCBsb2dPbmx5Q3VycmVudFdoeUNvbnRleHQpe1xuXG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfTtcblxuICAgICAgICBpZihzYXZlU3RhY2spe1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gJyc7XG4gICAgICAgICAgICBpZihleGNlcHRpb24pe1xuICAgICAgICAgICAgICAgIHN0YWNrID0gZXhjZXB0aW9uLnN0YWNrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjayAgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnN0YWNrID0gc3RhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZihleGNlcHRpb24pe1xuICAgICAgICAgICAgcmV0LmV4Y2VwdGlvbiA9IGV4Y2VwdGlvbi5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJncyl7XG4gICAgICAgICAgICByZXQuYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocHJvY2Vzcy5lbnYuUlVOX1dJVEhfV0hZUyl7XG4gICAgICAgICAgICB2YXIgd2h5ID0gcmVxdWlyZSgnd2h5cycpO1xuICAgICAgICAgICAgaWYobG9nT25seUN1cnJlbnRXaHlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0Wyd3aHlMb2cnXSA9IHdoeS5nZXRHbG9iYWxDdXJyZW50Q29udGV4dCgpLmdldEV4ZWN1dGlvblN1bW1hcnkoKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJldFsnd2h5TG9nJ10gPSB3aHkuZ2V0QWxsQ29udGV4dHMoKS5tYXAoZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RXhlY3V0aW9uU3VtbWFyeSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXByb2Nlc3MuZW52LkRJU0FCTEVfU1RBQ0tQUklOVCl7XG4gICAgICAgICAgICBpZihzdGFjayl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG59O1xuXG4iLCJjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGZvcmtlciA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcblxuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMjAwMDtcblxudmFyIGdsb2JUb1JlZ0V4cCA9ICByZXF1aXJlKFwiLi91dGlscy9nbG9iLXRvLXJlZ2V4cFwiKTtcblxudmFyIGRlZmF1bHRDb25maWcgPSB7XG4gICAgY29uZkZpbGVOYW1lOiBcImRvdWJsZS1jaGVjay5qc29uXCIsICAgICAgLy8gbmFtZSBvZiB0aGUgY29uZiBmaWxlXG4gICAgZmlsZUV4dDogXCIuanNcIiwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBmaWxlIHN1cHBvcnRlZCBieSBleHRlbnNpb25cbiAgICBtYXRjaERpcnM6IFsgJ3Rlc3QnLCAndGVzdHMnIF0sICAgICAgICAgICAvLyBkaXJzIG5hbWVzIGZvciB0ZXN0cyAtIGNhc2UgaW5zZW5zaXRpdmUgKHVzZWQgaW4gZGlzY292ZXJ5IHByb2Nlc3MpXG4gICAgdGVzdHNEaXI6IHByb2Nlc3MuY3dkKCksICAgICAgICAgICAgICAgIC8vIHBhdGggdG8gdGhlIHJvb3QgdGVzdHMgbG9jYXRpb25cbiAgICByZXBvcnRzOiB7XG4gICAgICAgIGJhc2VQYXRoOiBwcm9jZXNzLmN3ZCgpLCAgICAgICAgICAgIC8vIHBhdGggd2hlcmUgdGhlIHJlcG9ydHMgd2lsbCBiZSBzYXZlZFxuICAgICAgICBwcmVmaXg6IFwiUmVwb3J0LVwiLCAgICAgICAgICAgICAgICAgIC8vIHByZWZpeCBmb3IgcmVwb3J0IGZpbGVzLCBmaWxlbmFtZSBwYXR0ZXJuOiBbcHJlZml4XS17dGltZXN0YW1wfXtleHR9XG4gICAgICAgIGV4dDogXCIudHh0XCIgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IGZpbGUgZXh0ZW5zaW9uXG4gICAgfVxufTtcblxuY29uc3QgVEFHID0gXCJbVEVTVF9SVU5ORVJdXCI7XG5jb25zdCBNQVhfV09SS0VSUyA9IHByb2Nlc3MuZW52WydET1VCTEVfQ0hFQ0tfUE9PTF9TSVpFJ10gfHwgMTA7XG5jb25zdCBERUJVRyA9IHR5cGVvZiB2OGRlYnVnID09PSAnb2JqZWN0JztcblxuY29uc3QgVEVTVF9TVEFURVMgPSB7XG4gICAgUkVBRFk6ICdyZWFkeScsXG4gICAgUlVOTklORzogJ3J1bm5pbmcnLFxuICAgIEZJTklTSEVEOiAnZmluaXNoZWQnLFxuICAgIFRJTUVPVVQ6ICd0aW1lb3V0J1xufTtcblxuLy8gU2Vzc2lvbiBvYmplY3RcbnZhciBkZWZhdWx0U2Vzc2lvbiA9IHtcbiAgICB0ZXN0Q291bnQ6IDAsXG4gICAgY3VycmVudFRlc3RJbmRleDogMCxcbiAgICBkZWJ1Z1BvcnQ6IHByb2Nlc3MuZGVidWdQb3J0LCAgIC8vIGN1cnJlbnQgcHJvY2VzcyBkZWJ1ZyBwb3J0LiBUaGUgY2hpbGQgcHJvY2VzcyB3aWxsIGJlIGluY3JlYXNlZCBmcm9tIHRoaXMgcG9ydFxuICAgIHdvcmtlcnM6IHtcbiAgICAgICAgcnVubmluZzogMCxcbiAgICAgICAgdGVybWluYXRlZDogMFxuICAgIH1cbn07XG5cbi8vIFRlbXBsYXRlIHN0cnVjdHVyZSBmb3IgdGVzdCByZXBvcnRzLlxudmFyIHJlcG9ydEZpbGVTdHJ1Y3R1cmUgPSB7XG4gICAgY291bnQ6IDAsXG4gICAgc3VpdGVzOiB7XG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgICBpdGVtczogW11cbiAgICB9LFxuICAgIHBhc3NlZDoge1xuICAgICAgICBjb3VudDogMCxcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgfSxcbiAgICBmYWlsZWQ6IHtcbiAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIGl0ZW1zOiBbXVxuICAgIH0sXG59O1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbihzZil7XG4gICAgc2YudGVzdFJ1bm5lciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSB0ZXN0IHJ1bm5lci5cbiAgICAgICAgICogQHBhcmFtIGNvbmZpZyB7T2JqZWN0fSAtIHNldHRpbmdzIG9iamVjdCB0aGF0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQgb25lXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSB0aGlzLl9fZXh0ZW5kKGRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnRlc3RUcmVlID0ge307XG4gICAgICAgICAgICB0aGlzLnRlc3RMaXN0ID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IGRlZmF1bHRTZXNzaW9uO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVwb3J0cyBkaXJlY3RvcnkgaWYgbm90IGV4aXN0XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmModGhpcy5jb25maWcucmVwb3J0cy5iYXNlUGF0aCkpe1xuICAgICAgICAgICAgICAgIGZzLm1rZGlyU3luYyh0aGlzLmNvbmZpZy5yZXBvcnRzLmJhc2VQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1haW4gZW50cnkgcG9pbnQuIEl0IHdpbGwgc3RhcnQgdGhlIGZsb3cgcnVubmVyIGZsb3cuXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcge09iamVjdH0gLSBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyBzdWNoIGFzIGNvbmYgZmlsZSBuYW1lLCB0ZXN0IGRpci5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn0gLSBoYW5kbGVyKGVycm9yLCByZXN1bHQpIGludm9rZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgcnVubmVyIGhhcyBjb21wbGV0ZWQgYWxsIGpvYnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuXG4gICAgICAgICAgICAvLyB3cmFwcGVyIGZvciBwcm92aWRlZCBjYWxsYmFjaywgaWYgYW55XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlYnVnSW5mbyhlcnIubWVzc2FnZSB8fCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fX2luaXQoY29uZmlnKTtcblxuICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2coXCJEaXNjb3ZlcmluZyB0ZXN0cyAuLi5cIik7XG4gICAgICAgICAgICB0aGlzLnRlc3RUcmVlID0gdGhpcy5fX2Rpc2NvdmVyVGVzdEZpbGVzKHRoaXMuY29uZmlnLnRlc3RzRGlyLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy50ZXN0TGlzdCA9IHRoaXMuX190b1Rlc3RUcmVlVG9MaXN0KHRoaXMudGVzdFRyZWUpO1xuICAgICAgICAgICAgdGhpcy5fX2xhdW5jaFRlc3RzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZyb20gYSBqc29uIGZpbGUuXG4gICAgICAgICAqIEBwYXJhbSBjb25mUGF0aCB7U3RyaW5nfSAtIGFic29sdXRlIHBhdGggdG8gdGhlIGNvbmZpZ3VyYXRpb24gZmlsZS5cbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gLSBjb25maWd1cmF0aW9uIG9iamVjdCB7e319XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX3JlYWRDb25mOiBmdW5jdGlvbihjb25mUGF0aCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHJlcXVpcmUoY29uZlBhdGgpO1xuICAgICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzY292ZXJzIHRlc3QgZmlsZXMgcmVjdXJzaXZlbHkgc3RhcnRpbmcgZnJvbSBhIHBhdGguIFRoZSBkaXIgaXMgdGhlIHJvb3Qgb2YgdGhlIHRlc3QgZmlsZXMuIEl0IGNhbiBjb250YWluc1xuICAgICAgICAgKiB0ZXN0IGZpbGVzIGFuZCB0ZXN0IHN1YiBkaXJlY3Rvcmllcy4gSXQgd2lsbCBjcmVhdGUgYSB0cmVlIHN0cnVjdHVyZSB3aXRoIHRoZSB0ZXN0IGZpbGVzIGRpc2NvdmVyZWQuXG4gICAgICAgICAqIE5vdGVzOiBPbmx5IHRoZSBjb25maWcubWF0Y2hEaXJzIHdpbGwgYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLiBBbHNvLCBiYXNlZCBvbiB0aGUgY29uZiAoZG91YmxlLWNoZWNrLmpzb24pXG4gICAgICAgICAqIGl0IHdpbGwgaW5jbHVkZSB0aGUgdGVzdCBmaWxlcyBvciBub3QuXG4gICAgICAgICAqIEBwYXJhbSBkaXIge1N0cmluZ30gLSBwYXRoIHdoZXJlIHRoZSBkaXNjb3ZlcnkgcHJvY2VzcyBzdGFydHNcbiAgICAgICAgICogQHBhcmFtIHBhcmVudENvbmYge1N0cmluZ30gLSBjb25maWd1cmF0aW9uIG9iamVjdCAoZG91YmxlLWNoZWNrLmpzb24pIGZyb20gdGhlIHBhcmVudCBkaXJlY3RvcnlcbiAgICAgICAgICogQHJldHVybnMgVGhlIHJvb3Qgbm9kZSBvYmplY3Qgb2YgdGhlIGZpbGUgc3RydWN0dXJlIHRyZWUuIEUuZy4geyp8e19fbWV0YSwgZGF0YSwgcmVzdWx0LCBpdGVtc319XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX2Rpc2NvdmVyVGVzdEZpbGVzOiBmdW5jdGlvbihkaXIsIHBhcmVudENvbmYpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhkaXIpO1xuICAgICAgICAgICAgaWYoIXN0YXQuaXNEaXJlY3RvcnkoKSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRpciArIFwiIGlzIG5vdCBhIGRpcmVjdG9yeSFcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29uZiA9IHBhcmVudENvbmY7XG5cbiAgICAgICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IHRoaXMuX19nZXREZWZhdWx0Tm9kZVN0cnVjdHVyZSgpO1xuICAgICAgICAgICAgY3VycmVudE5vZGUuX19tZXRhLnBhcmVudCA9IHBhdGguZGlybmFtZShkaXIpO1xuICAgICAgICAgICAgY3VycmVudE5vZGUuX19tZXRhLmlzRGlyZWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGV0IGZpbGVzID0gZnMucmVhZGRpclN5bmMoZGlyKTtcbiAgICAgICAgICAgIC8vIGZpcnN0IGxvb2sgZm9yIGNvbmYgZmlsZVxuICAgICAgICAgICAgaWYoZmlsZXMuaW5kZXhPZih0aGlzLmNvbmZpZy5jb25mRmlsZU5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBmZCA9IHBhdGguam9pbihkaXIsIHRoaXMuY29uZmlnLmNvbmZGaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmYgPSB0aGlzLl9fcmVhZENvbmYoZmQpO1xuICAgICAgICAgICAgICAgIGlmKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuX19tZXRhLmNvbmYgPSBjb25mO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29uZiA9IGNvbmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5kYXRhLm5hbWUgPSBwYXRoLmJhc2VuYW1lKGRpcik7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5kYXRhLnBhdGggPSBkaXI7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5pdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBmaWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gZmlsZXNbaV07XG5cbiAgICAgICAgICAgICAgICBsZXQgZmQgPSBwYXRoLmpvaW4oZGlyLCBpdGVtKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdCA9IGZzLnN0YXRTeW5jKGZkKTtcbiAgICAgICAgICAgICAgICBsZXQgaXNEaXIgPSBzdGF0LmlzRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgbGV0IGlzVGVzdERpciA9IHRoaXMuX19pc1Rlc3REaXIoZmQpO1xuXG4gICAgICAgICAgICAgICAgaWYoaXNEaXIgJiYgIWlzVGVzdERpcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gaWdub3JlIGRpcnMgdGhhdCBkb2VzIG5vdCBmb2xsb3cgdGhlIG5hbWluZyBydWxlIGZvciB0ZXN0IGRpcnNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZighaXNEaXIgJiYgaXRlbS5tYXRjaCh0aGlzLmNvbmZpZy5jb25mRmlsZU5hbWUpKXtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZXhjbHVkZSBmaWxlcyBiYXNlZCBvbiBnbG9iIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudENvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudENvbmZbJ2lnbm9yZSddIC0gYXJyYXkgb2YgcmVnRXhwXG4gICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRDb25mWydpZ25vcmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNNYXRjaCA9IHRoaXMuX19pc0FueU1hdGNoKGN1cnJlbnRDb25mWydpZ25vcmUnXSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpc01hdGNoKSB7Y29udGludWU7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IHRoaXMuX19nZXREZWZhdWx0Tm9kZVN0cnVjdHVyZSgpO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5fX21ldGEuY29uZiA9IHt9O1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5fX21ldGEuaXNEaXJlY3RvcnkgPSBpc0RpcjtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX19tZXRhLnBhcmVudCA9IHBhdGguZGlybmFtZShmZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNEaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBDaGlsZE5vZGUgPSB0aGlzLl9fZGlzY292ZXJUZXN0RmlsZXMoZmQsIGN1cnJlbnRDb25mKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gT2JqZWN0LmFzc2lnbihjaGlsZE5vZGUsIHRlbXBDaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5pdGVtcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYocGF0aC5leHRuYW1lKGZkKSA9PT0gIHRoaXMuY29uZmlnLmZpbGVFeHQpe1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuX19tZXRhLmNvbmYucnVucyA9IGN1cnJlbnRDb25mWydydW5zJ10gfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLl9fbWV0YS5jb25mLnNpbGVudCA9IGN1cnJlbnRDb25mWydzaWxlbnQnXTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLl9fbWV0YS5jb25mLnRpbWVvdXQgPSBjdXJyZW50Q29uZlsndGltZW91dCddIHx8IERFRkFVTFRfVElNRU9VVDtcblxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuZGF0YS5uYW1lID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmRhdGEucGF0aCA9IGZkO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLml0ZW1zLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExhdW5jaCBjb2xsZWN0ZWQgdGVzdHMuIEluaXRpYWxpc2VzIHNlc3Npb24gdmFyaWFibGVzLCB0aGF0IGFyZSBzcGVjaWZpYyBmb3IgdGhlIGN1cnJlbnQgbGF1bmNoLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX19sYXVuY2hUZXN0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9fY29uc29sZUxvZyhcIkxhdW5jaGluZyB0ZXN0cyAuLi5cIik7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24udGVzdENvdW50ID0gdGhpcy50ZXN0TGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucHJvY2Vzc2VkVGVzdENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi53b3JrZXJzLnJ1bm5pbmcgPSAwO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLndvcmtlcnMudGVybWluYXRlZCA9IDA7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuc2Vzc2lvbi50ZXN0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3NjaGVkdWxlV29yaygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZG9UZXN0UmVwb3J0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGVzIHdvcmsgYmFzZWQgb24gdGhlIE1BWCBhdmFpbGFibGUgd29ya2VycywgYW5kIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgcnVucyBvZiBhIHRlc3QuXG4gICAgICAgICAqIElmIGEgdGVzdCBoYXMgbXVsdGlwbGUgcnVucyBhcyBhIG9wdGlvbiwgaXQgd2lsbCBiZSBzdGFydGVkIGluIG11bHRpcGxlIHdvcmtlcnMuIE9uY2UgYWxsIHJ1bnMgYXJlIGNvbXBsZXRlZCxcbiAgICAgICAgICogdGhlIHRlc3QgaXMgY29uc2lkZXJlZCBhcyBwcm9jZXNzZWQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX3NjaGVkdWxlV29yazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3aGlsZSh0aGlzLnNlc3Npb24ud29ya2Vycy5ydW5uaW5nIDwgTUFYX1dPUktFUlMgJiYgdGhpcy5zZXNzaW9uLmN1cnJlbnRUZXN0SW5kZXggPCB0aGlzLnNlc3Npb24udGVzdENvdW50KXtcbiAgICAgICAgICAgICAgICBsZXQgdGVzdCA9IHRoaXMudGVzdExpc3RbdGhpcy5zZXNzaW9uLmN1cnJlbnRUZXN0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmKHRlc3QucmVzdWx0LnJ1bnMgPCB0ZXN0Ll9fbWV0YS5jb25mLnJ1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQucnVucysrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbGF1bmNoVGVzdCh0ZXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uY3VycmVudFRlc3RJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExhdW5jaCBhIHRlc3QgaW50byBhIHNlcGFyYXRlIHdvcmtlciAoY2hpbGQgcHJvY2VzcykuXG4gICAgICAgICAqIEVhY2ggd29ya2VyIGhhcyBoYW5kbGVycyBmb3IgbWVzc2FnZSwgZXhpdCBhbmQgZXJyb3IgZXZlbnRzLiBPbmNlIHRoZSBleGl0IG9yIGVycm9yIGV2ZW50IGlzIGludm9rZWQsXG4gICAgICAgICAqIG5ldyB3b3JrIGlzIHNjaGVkdWxlZCBhbmQgc2Vzc2lvbiBvYmplY3QgaXMgdXBkYXRlZC5cbiAgICAgICAgICogTm90ZXM6IE9uIGRlYnVnIG1vZGUsIHRoZSB3b3JrZXJzIHdpbGwgcmVjZWl2ZSBhIGRlYnVnIHBvcnQsIHRoYXQgaXMgaW5jcmVhc2VkIGluY3JlbWVudGFsbHkuXG4gICAgICAgICAqIEBwYXJhbSB0ZXN0IHtPYmplY3R9IC0gdGVzdCBvYmplY3RcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9fbGF1bmNoVGVzdDogZnVuY3Rpb24odGVzdCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLndvcmtlcnMucnVubmluZysrO1xuXG4gICAgICAgICAgICB0ZXN0LnJlc3VsdC5zdGF0ZSA9IFRFU1RfU1RBVEVTLlJVTk5JTkc7XG4gICAgICAgICAgICB0ZXN0LnJlc3VsdC5wYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRlc3QucmVzdWx0LmFzc2VydHNbdGVzdC5yZXN1bHQucnVuc10gPSBbXTtcbiAgICAgICAgICAgIHRlc3QucmVzdWx0Lm1lc3NhZ2VzW3Rlc3QucmVzdWx0LnJ1bnNdID0gW107XG5cbiAgICAgICAgICAgIGxldCBlbnYgPSBwcm9jZXNzLmVudjtcblxuICAgICAgICAgICAgbGV0IGV4ZWNBcmd2ID0gW107XG4gICAgICAgICAgICBpZihERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlYnVnUG9ydCA9ICsrZGVmYXVsdFNlc3Npb24uZGVidWdQb3J0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlYnVnRmxhZyA9ICctLWRlYnVnPScgKyBkZWJ1Z1BvcnQ7XG4gICAgICAgICAgICAgICAgZXhlY0FyZ3YucHVzaChkZWJ1Z0ZsYWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjd2QgPSB0ZXN0Ll9fbWV0YS5wYXJlbnQ7XG5cbiAgICAgICAgICAgIGxldCB3b3JrZXIgPSBmb3JrZXIuZm9yayh0ZXN0LmRhdGEucGF0aCwgW10sIHsnY3dkJzogY3dkLCAnZW52JzogZW52LCAnZXhlY0FyZ3YnOiBleGVjQXJndiwgc3RkaW86IFsgJ2luaGVyaXQnLCBcInBpcGVcIiwgJ2luaGVyaXQnLCAnaXBjJyBdLCBzaWxlbnQ6ZmFsc2UgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX19kZWJ1Z0luZm8oYExhdW5jaGluZyB0ZXN0ICR7dGVzdC5kYXRhLm5hbWV9LCBydW5bJHt0ZXN0LnJlc3VsdC5ydW5zfV0sIG9uIHdvcmtlciBwaWRbJHt3b3JrZXIucGlkfV0gYCtuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cbiAgICAgICAgICAgIHdvcmtlci5vbihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlRXZlbnRIYW5kbGVyV3JhcHBlcih0ZXN0KSk7XG4gICAgICAgICAgICB3b3JrZXIub24oXCJleGl0XCIsIG9uRXhpdEV2ZW50SGFuZGxlcldyYXBwZXIodGVzdCkpO1xuICAgICAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgb25FcnJvckV2ZW50SGFuZGxlcldyYXBwZXIodGVzdCkpO1xuXG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB3b3JrZXIuc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBuZXcgQnVmZmVyKGNodW5rKS50b1N0cmluZygndXRmOCcpOyAvL1RPRE86IHJlcGxhY2Ugd2l0aCBQU0tCVUZGRVJcbiAgICAgICAgICAgICAgICBpZih0ZXN0Ll9fbWV0YS5jb25mLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY29uc29sZUxvZyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBmdW5jdGlvbiBvbk1lc3NhZ2VFdmVudEhhbmRsZXJXcmFwcGVyKHRlc3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UnVuID0gdGVzdC5yZXN1bHQucnVucztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obG9nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGxvZy50eXBlID09PSAnYXNzZXJ0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsb2cubWVzc2FnZS5pbmNsdWRlcyhcIltGYWlsXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQucGFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQuYXNzZXJ0c1tjdXJyZW50UnVuXS5wdXNoKGxvZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXN0LnJlc3VsdC5tZXNzYWdlc1tjdXJyZW50UnVuXS5wdXNoKGxvZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkV4aXRFdmVudEhhbmRsZXJXcmFwcGVyKHRlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29kZSwgc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3b3JrZXIudGltZXJWYXIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9fZGVidWdJbmZvKGBXb3JrZXIgJHt3b3JrZXIucGlkfSAtIGV4aXQgZXZlbnQuIENvZGUgJHtjb2RlfSwgc2lnbmFsICR7c2lnbmFsfSBgK25ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGVzdC5yZXN1bHQuc3RhdGUgPSBURVNUX1NUQVRFUy5GSU5JU0hFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYoY29kZSAhPT0gbnVsbCAmJiBjb2RlIT09MCAvKiYmIHR5cGVvZiB0ZXN0LnJlc3VsdC5wYXNzID09PSAndW5kZWZpbmVkJyovKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QucmVzdWx0LnBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QucmVzdWx0Lm1lc3NhZ2VzW3Rlc3QucmVzdWx0LnJ1bnNdLnB1c2goIHttZXNzYWdlOiBcIlByb2Nlc3MgZmluaXNoZWQgd2l0aCBlcnJvcnMhXCIsIFwiRXhpdCBjb2RlXCI6Y29kZSwgXCJTaWduYWxcIjpzaWduYWx9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Vzc2lvbi53b3JrZXJzLnJ1bm5pbmctLTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXNzaW9uLndvcmtlcnMudGVybWluYXRlZCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX19zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2NoZWNrV29ya2Vyc1N0YXR1cygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMgaGFuZGxlciBjYW4gYmUgdHJpZ2dlcmVkIHdoZW46XG4gICAgICAgICAgICAvLyAxLiBUaGUgcHJvY2VzcyBjb3VsZCBub3QgYmUgc3Bhd25lZCwgb3JcbiAgICAgICAgICAgIC8vIDIuIFRoZSBwcm9jZXNzIGNvdWxkIG5vdCBiZSBraWxsZWQsIG9yXG4gICAgICAgICAgICAvLyAzLiBTZW5kaW5nIGEgbWVzc2FnZSB0byB0aGUgY2hpbGQgcHJvY2VzcyBmYWlsZWQuXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFRoZSAnZXhpdCcgZXZlbnQgbWF5IG9yIG1heSBub3QgZmlyZSBhZnRlciBhbiBlcnJvciBoYXMgb2NjdXJyZWQhXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkVycm9yRXZlbnRIYW5kbGVyV3JhcHBlcih0ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX19kZWJ1Z0luZm8oYFdvcmtlciAke3dvcmtlci5waWR9IC0gZXJyb3IgZXZlbnQuYCwgdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX19kZWJ1Z0Vycm9yKGVycm9yKTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlc3Npb24ud29ya2Vycy5ydW5uaW5nLS07XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Vzc2lvbi53b3JrZXJzLnRlcm1pbmF0ZWQrKztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3RlOiBvbiBkZWJ1ZywgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgZXhpdCBldmVudCBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIHdoZW4ga2lsbCBpcyBjYWxsZWQsIHRoZSBleGl0IGV2ZW50IGlzIHJhaXNlZFxuICAgICAgICAgICAgd29ya2VyLnRpbWVyVmFyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIGlmKCF3b3JrZXIudGVybWluYXRlZCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb25zb2xlTG9nKGB3b3JrZXIgcGlkIFske3dvcmtlci5waWR9XSAtIHRpbWVvdXQgZXZlbnRgLG5ldyBEYXRlKCkuZ2V0VGltZSgpLCAgdGVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodGVzdC5yZXN1bHQuc3RhdGUgIT09IFRFU1RfU1RBVEVTLkZJTklTSEVEKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QucmVzdWx0LnBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXIua2lsbCgpO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0LnJlc3VsdC5zdGF0ZSA9IFRFU1RfU1RBVEVTLlRJTUVPVVQ7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR290IHNvbWV0aGluZywgYnV0IGRvbid0IGtub3cgd2hhdC4uLlwiLCB0ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0ZXN0Ll9fbWV0YS5jb25mLnRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fX2RlYnVnSW5mbyhgV29ya2VyICR7d29ya2VyLnBpZH0gLSBzZXQgdGltZW91dCBldmVudCBhdCBgK25ldyBEYXRlKCkuZ2V0VGltZSgpICsgXCIgZm9yIFwiK3Rlc3QuX19tZXRhLmNvbmYudGltZW91dCk7XG5cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiBhbGwgd29ya2VycyBjb21wbGV0ZWQgdGhlaXIgam9iIChmaW5pc2hlZCBvciBoYXZlIGJlZW4gdGVybWluYXRlZCkuXG4gICAgICAgICAqIElmIHRydWUsIHRoZW4gdGhlIHJlcG9ydGluZyBzdGVwcyBjYW4gYmUgc3RhcnRlZC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9fY2hlY2tXb3JrZXJzU3RhdHVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuc2Vzc2lvbi53b3JrZXJzLnJ1bm5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZG9UZXN0UmVwb3J0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0ZXN0IHJlcG9ydHMgb2JqZWN0IChKU09OKSB0aGF0IHdpbGwgYmUgc2F2ZWQgaW4gdGhlIHRlc3QgcmVwb3J0LlxuICAgICAgICAgKiBGaWxlbmFtZSBvZiB0aGUgcmVwb3J0IGlzIHVzaW5nIHRoZSBmb2xsb3dpbmcgcGF0dGVybjoge3ByZWZpeH0te3RpbWVzdGFtcH17ZXh0fVxuICAgICAgICAgKiBUaGUgZmlsZSB3aWxsIGJlIHNhdmVkIGluIGNvbmZpZy5yZXBvcnRzLmJhc2VQYXRoLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX19kb1Rlc3RSZXBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb25zb2xlTG9nKFwiRG9pbmcgcmVwb3J0cyAuLi5cIik7XG4gICAgICAgICAgICByZXBvcnRGaWxlU3RydWN0dXJlLmNvdW50ID0gdGhpcy50ZXN0TGlzdC5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIHBhc3MvZmFpbGVkIHRlc3RzXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnRlc3RMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlc3QgPSB0aGlzLnRlc3RMaXN0W2ldO1xuXG4gICAgICAgICAgICAgICAgbGV0IHRlc3RQYXRoID0gdGhpcy5fX3RvUmVsYXRpdmVQYXRoKHRlc3QuZGF0YS5wYXRoKTtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHtwYXRoOiB0ZXN0UGF0aH07XG4gICAgICAgICAgICAgICAgaWYodGVzdC5yZXN1bHQucGFzcykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlYXNvbiA9IHRoaXMuX19nZXRGaXJzdEZhaWxSZWFzb25QZXJSdW4odGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydEZpbGVTdHJ1Y3R1cmUucGFzc2VkLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5yZWFzb24gPSB0aGlzLl9fZ2V0Rmlyc3RGYWlsUmVhc29uUGVyUnVuKHRlc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRGaWxlU3RydWN0dXJlLmZhaWxlZC5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcG9ydEZpbGVTdHJ1Y3R1cmUucGFzc2VkLmNvdW50ID0gcmVwb3J0RmlsZVN0cnVjdHVyZS5wYXNzZWQuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgcmVwb3J0RmlsZVN0cnVjdHVyZS5mYWlsZWQuY291bnQgPSByZXBvcnRGaWxlU3RydWN0dXJlLmZhaWxlZC5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIHN1aXRlcyAoZmlyc3QgbGV2ZWwgb2YgZGlyZWN0b3JpZXMpXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnRlc3RUcmVlLml0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnRlc3RUcmVlLml0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0uX19tZXRhLmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWl0ZVBhdGggPSB0aGlzLl9fdG9SZWxhdGl2ZVBhdGgoaXRlbS5kYXRhLnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRGaWxlU3RydWN0dXJlLnN1aXRlcy5pdGVtcy5wdXNoKHN1aXRlUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwb3J0RmlsZVN0cnVjdHVyZS5zdWl0ZXMuY291bnQgPSByZXBvcnRGaWxlU3RydWN0dXJlLnN1aXRlcy5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGxldCBudW1iZXJPZlJlcG9ydHMgPSAyO1xuXG4gICAgICAgICAgICBsZXQgZmluaXNoUmVwb3J0cyA9IChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmKG51bWJlck9mUmVwb3J0cyA+IDEpe1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZlJlcG9ydHMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihyZXBvcnRGaWxlU3RydWN0dXJlLmZhaWxlZC5jb3VudCA9PT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb25zb2xlTG9nKFwiXFxuRXZlcnl0aGluZyB3ZW50IHdlbGwhIE5vIGZhaWxlZCB0ZXN0cy5cXG5cXG5cIik7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb25zb2xlTG9nKFwiXFxuU29tZSB0ZXN0cyBmYWlsZWQuIENoZWNrIHJlcG9ydCBmaWxlcyFcXG5cXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhlcnIsIFwiRG9uZVwiKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2codGhpcy5jb25maWcucmVwb3J0cy5wcmVmaXgpO1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBgJHt0aGlzLmNvbmZpZy5yZXBvcnRzLnByZWZpeH1sYXRlc3Qke3RoaXMuY29uZmlnLnJlcG9ydHMuZXh0fWA7XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5yZXBvcnRzLmJhc2VQYXRoLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9fc2F2ZVJlcG9ydFRvRmlsZShyZXBvcnRGaWxlU3RydWN0dXJlLCBmaWxlUGF0aCwgZmluaXNoUmVwb3J0cyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBodG1sRmlsZU5hbWUgPSBgJHt0aGlzLmNvbmZpZy5yZXBvcnRzLnByZWZpeH1sYXRlc3QuaHRtbGA7XG4gICAgICAgICAgICBjb25zdCBodG1sRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5jb25maWcucmVwb3J0cy5iYXNlUGF0aCwgaHRtbEZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX19zYXZlSHRtbFJlcG9ydFRvRmlsZShyZXBvcnRGaWxlU3RydWN0dXJlLCBodG1sRmlsZVBhdGgsIHRpbWVzdGFtcCwgZmluaXNoUmVwb3J0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYXZlcyB0ZXN0IHJlcG9ydHMgb2JqZWN0IChKU09OKSBpbiB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICAgICAqIEBwYXJhbSByZXBvcnRGaWxlU3RydWN0dXJlIHtPYmplY3R9IC0gdGVzdCByZXBvcnRzIG9iamVjdCAoSlNPTilcbiAgICAgICAgICogQHBhcmFtIGRlc3RpbmF0aW9uIHtTdHJpbmd9IC0gcGF0aCBvZiB0aGUgZmlsZSByZXBvcnQgKHRoZSBiYXNlIHBhdGggTVVTVCBleGlzdClcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9fc2F2ZVJlcG9ydFRvRmlsZTogZnVuY3Rpb24ocmVwb3J0RmlsZVN0cnVjdHVyZSwgZGVzdGluYXRpb24sIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocmVwb3J0RmlsZVN0cnVjdHVyZSwgbnVsbCwgNCk7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGUoZGVzdGluYXRpb24sIGNvbnRlbnQsICd1dGY4JywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgd3JpdGluZyB0aGUgcmVwb3J0IGZpbGUsIHdpdGggdGhlIGZvbGxvd2luZyBlcnJvcjogXCIgKyBKU09OLnN0cmluZ2lmeShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVidWdJbmZvKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZpbmlzaGVkIHdyaXRpbmcgcmVwb3J0IHRvICR7ZGVzdGluYXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2cobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2F2ZXMgdGVzdCByZXBvcnRzIGFzIEhUTUwgaW4gdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAgICAgKiBAcGFyYW0gcmVwb3J0RmlsZVN0cnVjdHVyZSB7T2JqZWN0fSAtIHRlc3QgcmVwb3J0cyBvYmplY3QgKEpTT04pXG4gICAgICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiB7U3RyaW5nfSAtIHBhdGggb2YgdGhlIGZpbGUgcmVwb3J0ICh0aGUgYmFzZSBwYXRoIE1VU1QgZXhpc3QpXG4gICAgICAgICAqIEBwYXJhbSB0aW1lc3RhbXAge1N0cmluZ30gLSB0aW1lc3RhbXAgdG8gYmUgaW5qZWN0ZWQgaW4gaHRtbCB0ZW1wbGF0ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX19zYXZlSHRtbFJlcG9ydFRvRmlsZTogZnVuY3Rpb24gKHJlcG9ydEZpbGVTdHJ1Y3R1cmUsIGRlc3RpbmF0aW9uLCB0aW1lc3RhbXAsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUpO1xuICAgICAgICAgICAgZnMucmVhZEZpbGUocGF0aC5qb2luKGZvbGRlck5hbWUsJy91dGlscy9yZXBvcnRUZW1wbGF0ZS5odG1sJyksICd1dGY4JywgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlYWRpbmcgdGhlIGh0bWwgcmVwb3J0IHRlbXBsYXRlIGZpbGUsIHdpdGggdGhlIGZvbGxvd2luZyBlcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZWJ1Z0luZm8obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGUoZGVzdGluYXRpb24sIHJlcyArIGA8c2NyaXB0PmluaXQoJHtKU09OLnN0cmluZ2lmeShyZXBvcnRGaWxlU3RydWN0dXJlKX0sICR7dGltZXN0YW1wfSk7PC9zY3JpcHQ+YCwgJ3V0ZjgnLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgd3JpdGluZyB0aGUgaHRtbCByZXBvcnQgZmlsZSwgd2l0aCB0aGUgZm9sbG93aW5nIGVycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZWJ1Z0luZm8obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZpbmlzaGVkIHdyaXRpbmcgcmVwb3J0IHRvICR7ZGVzdGluYXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnNvbGVMb2cobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYWJzb2x1dGUgZmlsZSBwYXRoIHRvIHJlbGF0aXZlIHBhdGguXG4gICAgICAgICAqIEBwYXJhbSBhYnNvbHV0ZVBhdGgge1N0cmluZ30gLSBhYnNvbHV0ZSBwYXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmcgfCB2b2lkIHwgKn0gLSByZWxhdGl2ZSBwYXRoXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX3RvUmVsYXRpdmVQYXRoOiBmdW5jdGlvbihhYnNvbHV0ZVBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gcGF0aC5qb2luKHRoaXMuY29uZmlnLnRlc3RzRGlyLCBcIi9cIik7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBhYnNvbHV0ZVBhdGgucmVwbGFjZShiYXNlUGF0aCwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVsYXRpdmVQYXRoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIGEgZGlyZWN0b3J5IGlzIGEgdGVzdCBkaXIsIGJ5IG1hdGNoaW5nIGl0cyBuYW1lIGFnYWluc3QgY29uZmlnLm1hdGNoRGlycyBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGRpciB7U3RyaW5nfSAtIGRpcmVjdG9yeSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhIG1hdGNoIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX2lzVGVzdERpcjogZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICBpZighdGhpcy5jb25maWcgfHwgIXRoaXMuY29uZmlnLm1hdGNoRGlycyApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBgbWF0Y2hEaXJzIGlzIG5vdCBkZWZpbmVkIG9uIGNvbmZpZyAke0pTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlnKX0gZG9lcyBub3QgZXhpc3QhYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzVGVzdERpciA9IHRoaXMuY29uZmlnLm1hdGNoRGlycy5zb21lKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoaXRlbS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNUZXN0RGlyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGEgZmFpbGVkIHRlc3QsIGl0IHJldHVybnMgb25seSB0aGUgZmlyc3QgZmFpbCByZWFzb24gcGVyIGVhY2ggcnVuLlxuICAgICAgICAgKiBAcGFyYW0gdGVzdCB7T2JqZWN0fSAtIHRlc3Qgb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBhbiBhcnJheSBvZiByZWFzb25zIHBlciBlYWNoIHRlc3QgcnVuLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX19nZXRGaXJzdEZhaWxSZWFzb25QZXJSdW46IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IFtdO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8PSB0ZXN0LnJlc3VsdC5ydW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZih0ZXN0LnJlc3VsdC5hc3NlcnRzW2ldICYmIHRlc3QucmVzdWx0LmFzc2VydHNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRSZWFzb24oaSwgdGVzdC5yZXN1bHQuYXNzZXJ0c1tpXVswXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYodGVzdC5yZXN1bHQubWVzc2FnZXNbaV0gJiYgdGVzdC5yZXN1bHQubWVzc2FnZXNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRSZWFzb24oaSwgdGVzdC5yZXN1bHQubWVzc2FnZXNbaV1bMF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJlYXNvbihydW4sIGxvZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuOiBydW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2c6IGxvZ1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbi5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlYXNvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc2NyaWJlZCBkZWZhdWx0IHRyZWUgbm9kZSBzdHJ1Y3R1cmUuXG4gICAgICAgICAqIEByZXR1cm5zIHt7X19tZXRhOiB7Y29uZjogbnVsbCwgcGFyZW50OiBudWxsLCBpc0RpcmVjdG9yeTogYm9vbGVhbn0sIGRhdGE6IHtuYW1lOiBudWxsLCBwYXRoOiBudWxsfSwgcmVzdWx0OiB7c3RhdGU6IHN0cmluZywgcGFzczogbnVsbCwgZXhlY3V0aW9uVGltZTogbnVtYmVyLCBydW5zOiBudW1iZXIsIGFzc2VydHM6IHt9LCBtZXNzYWdlczoge319LCBpdGVtczogbnVsbH19XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX2dldERlZmF1bHROb2RlU3RydWN0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAge1xuICAgICAgICAgICAgICAgIF9fbWV0YToge1xuICAgICAgICAgICAgICAgICAgICBjb25mOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGlzRGlyZWN0b3J5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBURVNUX1NUQVRFUy5SRUFEWSwgLy8gcmVhZHkgfCBydW5uaW5nIHwgdGVybWluYXRlZCB8IHRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgcGFzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uVGltZTogMCxcbiAgICAgICAgICAgICAgICAgICAgcnVuczogMCxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0czoge30sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXRlbXM6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXRjaCBhIHRlc3QgZmlsZSBwYXRoIHRvIGEgVU5JWCBnbG9iIGV4cHJlc3Npb24gYXJyYXkuIElmIGl0cyBhbnkgbWF0Y2ggcmV0dXJucyB0cnVlLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICogQHBhcmFtIGdsb2JFeHBBcnJheSB7QXJyYXl9IC0gYW4gYXJyYXkgd2l0aCBnbG9iIGV4cHJlc3Npb24gKFVOSVggc3R5bGUpXG4gICAgICAgICAqIEBwYXJhbSBzdHIge1N0cmluZ30gLSB0aGUgc3RyaW5nIHRvIGJlIG1hdGNoZWRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gcmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGFueSBtYXRjaCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX19pc0FueU1hdGNoOiBmdW5jdGlvbihnbG9iRXhwQXJyYXksIHN0cikge1xuICAgICAgICAgICAgY29uc3QgaGFzTWF0Y2ggPSBmdW5jdGlvbihnbG9iRXhwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBnbG9iVG9SZWdFeHAoZ2xvYkV4cCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3Qoc3RyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBnbG9iRXhwQXJyYXkuc29tZShoYXNNYXRjaCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIHRyZWUgc3RydWN0dXJlIGludG8gYW4gYXJyYXkgbGlzdCBvZiB0ZXN0IG5vZGVzLiBUaGUgdHJlZSB0cmF2ZXJzYWwgaXMgREZTIChEZWVwLUZpcnN0LVNlYXJjaCkuXG4gICAgICAgICAqIEBwYXJhbSByb290Tm9kZSB7T2JqZWN0fSAtIHJvb3Qgbm9kZSBvZiB0aGUgdGVzdCB0cmVlLlxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gTGlzdCBvZiB0ZXN0IG5vZGVzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX190b1Rlc3RUcmVlVG9MaXN0OiBmdW5jdGlvbihyb290Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHRlc3RMaXN0ID0gW107XG5cbiAgICAgICAgICAgIHRyYXZlcnNlKHJvb3ROb2RlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmKCFub2RlLl9fbWV0YS5pc0RpcmVjdG9yeSB8fCAhbm9kZS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMCwgbGVuID0gbm9kZS5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbm9kZS5pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5fX21ldGEuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdExpc3QucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRlc3RMaXN0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9nZ2luZyB0byBjb25zb2xlIHdyYXBwZXIuXG4gICAgICAgICAqIEBwYXJhbSBsb2cge1N0cmluZ3xPYmplY3R8TnVtYmVyfSAtIGxvZyBtZXNzYWdlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfX2NvbnNvbGVMb2c6IGZ1bmN0aW9uKGxvZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coVEFHLCBsb2cpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTG9nZ2luZyBkZWJ1Z2dpbmcgaW5mbyBtZXNzYWdlcyB3cmFwcGVyLlxuICAgICAgICAgKiBMb2dnZXI6IGNvbnNvbGUuaW5mb1xuICAgICAgICAgKiBAcGFyYW0gbG9nIHtTdHJpbmd8T2JqZWN0fE51bWJlcn0gLSBsb2cgbWVzc2FnZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX19kZWJ1Z0luZm86IGZ1bmN0aW9uKGxvZykge1xuICAgICAgICAgICAgdGhpcy5fX2RlYnVnKGNvbnNvbGUuaW5mbywgbG9nKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvZ2dpbmcgZGVidWdnaW5nIGVycm9yIG1lc3NhZ2VzIHdyYXBwZXIuXG4gICAgICAgICAqIExvZ2dlcjogY29uc29sZS5lcnJvclxuICAgICAgICAgKiBAcGFyYW0gbG9nIHtTdHJpbmd8T2JqZWN0fE51bWJlcn0gLSBsb2cgbWVzc2FnZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX19kZWJ1Z0Vycm9yOiBmdW5jdGlvbihsb2cpIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWJ1Zyhjb25zb2xlLmVycm9yLCBsb2cpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogIExvZ2dpbmcgZGVidWdnaW5nIG1lc3NhZ2VzIHdyYXBwZXIuIE9uZSBkZWJ1ZyBtb2RlLCB0aGUgbG9nZ2luZyBpcyBzaWxlbnQuXG4gICAgICAgICAqIEBwYXJhbSBsb2dnZXIge0Z1bmN0aW9ufSAtIGhhbmRsZXIgZm9yIGxvZ2dpbmdcbiAgICAgICAgICogQHBhcmFtIGxvZyB7U3RyaW5nfE9iamVjdHxOdW1iZXJ9IC0gbG9nIG1lc3NhZ2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9fZGVidWc6IGZ1bmN0aW9uKGxvZ2dlciwgbG9nKSB7XG4gICAgICAgICAgICBpZighREVCVUcpIHtyZXR1cm47fVxuXG4gICAgICAgICAgICAvLyBsZXQgcHJldHR5TG9nID0gSlNPTi5zdHJpbmdpZnkobG9nLCBudWxsLCAyKTtcbiAgICAgICAgICAgIGxvZ2dlcihcIkRFQlVHXCIsIGxvZyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWVwIGV4dGVuZCBvbmUgb2JqZWN0IHdpdGggcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdC5cbiAgICAgICAgICogSWYgdGhlIHByb3BlcnR5IGV4aXN0cyBpbiBib3RoIG9iamVjdHMgdGhlIHByb3BlcnR5IGZyb20gdGhlIGZpcnN0IG9iamVjdCBpcyBvdmVycmlkZGVuLlxuICAgICAgICAgKiBAcGFyYW0gZmlyc3Qge09iamVjdH0gLSB0aGUgZmlyc3Qgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBzZWNvbmQge09iamVjdH0gLSB0aGUgc2Vjb25kIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIGFuIG9iamVjdCB3aXRoIGJvdGggcHJvcGVydGllcyBmcm9tIHRoZSBmaXJzdCBhbmQgc2Vjb25kIG9iamVjdC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9fZXh0ZW5kOiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0W2tleV0gPSBzZWNvbmRba2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc2Vjb25kW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBmaXJzdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5fX2V4dGVuZChmaXJzdFtrZXldLCBzZWNvbmRba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmaXJzdFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJcbi8vIGdsb2JUb1JlZ0V4cCB0dXJucyBhIFVOSVggZ2xvYiBleHByZXNzaW9uIGludG8gYSBSZWdFeCBleHByZXNzaW9uLlxuLy8gIFN1cHBvcnRzIGFsbCBzaW1wbGUgZ2xvYiBwYXR0ZXJucy4gRXhhbXBsZXM6ICouZXh0LCAvZm9vLyosIC4uLy4uL3BhdGgsIF5mb28uKlxuLy8gLSBzaW5nbGUgY2hhcmFjdGVyIG1hdGNoaW5nLCBtYXRjaGluZyByYW5nZXMgb2YgY2hhcmFjdGVycyBldGMuIGdyb3VwIG1hdGNoaW5nIGFyZSBubyBzdXBwb3J0ZWRcbi8vIC0gZmxhZ3MgYXJlIG5vdCBzdXBwb3J0ZWRcbnZhciBnbG9iVG9SZWdFeHAgPSBmdW5jdGlvbiAoZ2xvYkV4cCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYkV4cCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2xvYiBFeHByZXNzaW9uIG11c3QgYmUgYSBzdHJpbmchJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlZ0V4cCA9IFwiXCI7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZ2xvYkV4cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgYyA9IGdsb2JFeHBbaV07XG5cbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgIHJlZ0V4cCArPSBcIlxcXFxcIiArIGM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgLy8gdHJlYXQgYW55IG51bWJlciBvZiBcIipcIiBhcyBvbmVcbiAgICAgICAgICAgICAgICB3aGlsZShnbG9iRXhwW2kgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdFeHAgKz0gXCIuKlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlZ0V4cCArPSBjO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBeICYgJFxuICAgIHJlZ0V4cCA9IFwiXlwiICsgcmVnRXhwICsgXCIkXCI7XG5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdFeHApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iVG9SZWdFeHA7IiwiY29uc3QgdXRpbHMgPSByZXF1aXJlKFwic3dhcm11dGlsc1wiKTtcbmNvbnN0IE93TSA9IHV0aWxzLk93TTtcbnZhciBiZWVzSGVhbGVyID0gdXRpbHMuYmVlc0hlYWxlcjtcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5cblxuLy9UT0RPOiBwcmV2ZW50IGEgY2xhc3Mgb2YgcmFjZSBjb25kaXRpb24gdHlwZSBvZiBlcnJvcnMgYnkgc2lnbmFsaW5nIHdpdGggZmlsZXMgbWV0YWRhdGEgdG8gdGhlIHdhdGNoZXIgd2hlbiBpdCBpcyBzYWZlIHRvIGNvbnN1bWVcblxuZnVuY3Rpb24gRm9sZGVyTVEoZm9sZGVyLCBjYWxsYmFjayA9ICgpID0+IHt9KXtcblxuXHRpZih0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIil7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBjYWxsYmFjayBmdW5jdGlvblwiKTtcblx0fVxuXG5cdGZvbGRlciA9IHBhdGgubm9ybWFsaXplKGZvbGRlcik7XG5cblx0ZnMubWtkaXIoZm9sZGVyLCB7cmVjdXJzaXZlOiB0cnVlfSwgZnVuY3Rpb24oZXJyLCByZXMpe1xuXHRcdGZzLmV4aXN0cyhmb2xkZXIsIGZ1bmN0aW9uKGV4aXN0cykge1xuXHRcdFx0aWYgKGV4aXN0cykge1xuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9sZGVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblxuXHRmdW5jdGlvbiBta0ZpbGVOYW1lKHN3YXJtUmF3KXtcblx0XHRsZXQgbWV0YSA9IE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20oc3dhcm1SYXcpO1xuXHRcdGxldCBuYW1lID0gYCR7Zm9sZGVyfSR7cGF0aC5zZXB9JHttZXRhLnN3YXJtSWR9LiR7bWV0YS5zd2FybVR5cGVOYW1lfWA7XG5cdFx0Y29uc3QgdW5pcXVlID0gbWV0YS5waGFzZUlkIHx8ICQkLnVpZEdlbmVyYXRvci5zYWZlX3V1aWQoKTtcblxuXHRcdG5hbWUgPSBuYW1lK2AuJHt1bmlxdWV9YDtcblx0XHRyZXR1cm4gcGF0aC5ub3JtYWxpemUobmFtZSk7XG5cdH1cblxuXHR0aGlzLmdldEhhbmRsZXIgPSBmdW5jdGlvbigpe1xuXHRcdGlmKHByb2R1Y2VyKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGNvbnN1bWVyIGlzIGFsbG93ZWQhXCIpO1xuXHRcdH1cblx0XHRwcm9kdWNlciA9IHRydWU7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmRTd2FybVNlcmlhbGl6YXRpb246IGZ1bmN0aW9uKHNlcmlhbGl6YXRpb24sIGNhbGxiYWNrKXtcblx0XHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0d3JpdGVGaWxlKG1rRmlsZU5hbWUoSlNPTi5wYXJzZShzZXJpYWxpemF0aW9uKSksIHNlcmlhbGl6YXRpb24sIGNhbGxiYWNrKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRTdHJlYW0gOiBmdW5jdGlvbihzdHJlYW0sIGNhbGxiYWNrKXtcblx0XHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZighc3RyZWFtIHx8ICFzdHJlYW0ucGlwZSB8fCB0eXBlb2Ygc3RyZWFtLnBpcGUgIT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIlNvbWV0aGluZyB3cm9uZyBoYXBwZW5lZFwiKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgc3dhcm0gPSBcIlwiO1xuXHRcdFx0XHRzdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+e1xuXHRcdFx0XHRcdHN3YXJtICs9IGNodW5rO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdHdyaXRlRmlsZShta0ZpbGVOYW1lKEpTT04ucGFyc2Uoc3dhcm0pKSwgc3dhcm0sIGNhbGxiYWNrKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c3RyZWFtLm9uKFwiZXJyb3JcIiwgKGVycikgPT57XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkU3dhcm0gOiBmdW5jdGlvbihzd2FybSwgY2FsbGJhY2spe1xuXHRcdFx0XHRpZighY2FsbGJhY2spe1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gJCQuZGVmYXVsdEVycm9ySGFuZGxpbmdJbXBsZW1lbnRhdGlvbjtcblx0XHRcdFx0fWVsc2UgaWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNlY29uZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiZWVzSGVhbGVyLmFzSlNPTihzd2FybSxudWxsLCBudWxsLCBmdW5jdGlvbihlcnIsIHJlcyl7XG5cdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d3JpdGVGaWxlKG1rRmlsZU5hbWUocmVzKSwgSihyZXMpLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdHNlbmRTd2FybUZvckV4ZWN1dGlvbjogZnVuY3Rpb24oc3dhcm0sIGNhbGxiYWNrKXtcblx0XHRcdFx0aWYoIWNhbGxiYWNrKXtcblx0XHRcdFx0XHRjYWxsYmFjayA9ICQkLmRlZmF1bHRFcnJvckhhbmRsaW5nSW1wbGVtZW50YXRpb247XG5cdFx0XHRcdH1lbHNlIGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmVlc0hlYWxlci5hc0pTT04oc3dhcm0sIE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20oc3dhcm0sIFwicGhhc2VOYW1lXCIpLCBPd00ucHJvdG90eXBlLmdldE1ldGFGcm9tKHN3YXJtLCBcImFyZ3NcIiksIGZ1bmN0aW9uKGVyciwgcmVzKXtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhlcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgZmlsZSA9IG1rRmlsZU5hbWUocmVzKTtcblx0XHRcdFx0XHR2YXIgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHJlcyk7XG5cblx0XHRcdFx0XHQvL2lmIHRoZXJlIGFyZSBubyBtb3JlIEZEJ3MgZm9yIGZpbGVzIHRvIGJlIHdyaXR0ZW4gd2UgcmV0cnkuXG5cdFx0XHRcdFx0ZnVuY3Rpb24gd3JhcHBlcihlcnJvciwgcmVzdWx0KXtcblx0XHRcdFx0XHRcdGlmKGVycm9yKXtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYENhdWdodCBhbiB3cml0ZSBlcnJvci4gUmV0cnkgdG8gd3JpdGUgZmlsZSBbJHtmaWxlfV1gKTtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dCgoKT0+e1xuXHRcdFx0XHRcdFx0XHRcdHdyaXRlRmlsZShmaWxlLCBjb250ZW50LCB3cmFwcGVyKTtcblx0XHRcdFx0XHRcdFx0fSwgMTApO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3cml0ZUZpbGUoZmlsZSwgY29udGVudCwgd3JhcHBlcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cblx0dmFyIHJlY2lwaWVudDtcblx0dGhpcy5zZXRJUENDaGFubmVsID0gZnVuY3Rpb24ocHJvY2Vzc0NoYW5uZWwpe1xuXHRcdGlmKHByb2Nlc3NDaGFubmVsICYmICFwcm9jZXNzQ2hhbm5lbC5zZW5kIHx8ICh0eXBlb2YgcHJvY2Vzc0NoYW5uZWwuc2VuZCkgIT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlJlY2lwaWVudCBpcyBub3QgaW5zdGFuY2Ugb2YgcHJvY2Vzcy9jaGlsZF9wcm9jZXNzIG9yIGl0IHdhcyBub3Qgc3Bhd25lZCB3aXRoIElQQyBjaGFubmVsIVwiKTtcblx0XHR9XG5cdFx0cmVjaXBpZW50ID0gcHJvY2Vzc0NoYW5uZWw7XG5cdFx0aWYoY29uc3VtZXIpe1xuXHRcdFx0Y29uc29sZS5sb2coYENoYW5uZWwgdXBkYXRlZGApO1xuXHRcdFx0KHJlY2lwaWVudCB8fCBwcm9jZXNzKS5vbihcIm1lc3NhZ2VcIiwgcmVjZWl2ZUVudmVsb3BlKTtcblx0XHR9XG5cdH07XG5cblxuXHR2YXIgY29uc3VtZWRNZXNzYWdlcyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGNoZWNrSWZDb25zdW1tZWQobmFtZSwgbWVzc2FnZSl7XG5cdFx0Y29uc3Qgc2hvcnROYW1lID0gcGF0aC5iYXNlbmFtZShuYW1lKTtcblx0XHRjb25zdCBwcmV2aW91c1NhdmVkID0gY29uc3VtZWRNZXNzYWdlc1tzaG9ydE5hbWVdO1xuXHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblx0XHRpZihwcmV2aW91c1NhdmVkICYmICFwcmV2aW91c1NhdmVkLmxvY2FsZUNvbXBhcmUobWVzc2FnZSkpe1xuXHRcdFx0cmVzdWx0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNhdmUySGlzdG9yeShlbnZlbG9wZSl7XG5cdFx0Y29uc3VtZWRNZXNzYWdlc1twYXRoLmJhc2VuYW1lKGVudmVsb3BlLm5hbWUpXSA9IGVudmVsb3BlLm1lc3NhZ2U7XG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZEVudmVsb3BlQ29uZmlybWF0aW9uKGVudmVsb3BlLCBzYXZlSGlzdG9yeSl7XG5cdFx0aWYoc2F2ZUhpc3Rvcnkpe1xuXHRcdFx0c2F2ZTJIaXN0b3J5KGVudmVsb3BlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGBDb25maXJtIGVudmVsb3BlICR7ZW52ZWxvcGUudGltZXN0YW1wfSBzZW50IHRvICR7ZW52ZWxvcGUuZGVzdH1gO1xuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRFbnZlbG9wZShuYW1lLCBtZXNzYWdlKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVzdDogZm9sZGVyLFxuXHRcdFx0c3JjOiBwcm9jZXNzLnBpZCxcblx0XHRcdHRpbWVzdGFtcDogbmV3IERhdGUoKS5nZXRUaW1lKCksXG5cdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0bmFtZTogbmFtZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiByZWNlaXZlRW52ZWxvcGUoZW52ZWxvcGUpe1xuXHRcdGlmKCFlbnZlbG9wZSB8fCB0eXBlb2YgZW52ZWxvcGUgIT09IFwib2JqZWN0XCIpe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvL2NvbnNvbGUubG9nKFwicmVjZWl2ZWQgZW52ZWxvcGVcIiwgZW52ZWxvcGUsIGZvbGRlcik7XG5cblx0XHRpZihlbnZlbG9wZS5kZXN0ICE9PSBmb2xkZXIgJiYgZm9sZGVyLmluZGV4T2YoZW52ZWxvcGUuZGVzdCkhPT0gLTEgJiYgZm9sZGVyLmxlbmd0aCA9PT0gZW52ZWxvcGUuZGVzdCsxKXtcblx0XHRcdGNvbnNvbGUubG9nKFwiVGhpcyBlbnZlbG9wZSBpcyBub3QgZm9yIG1lIVwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgbWVzc2FnZSA9IGVudmVsb3BlLm1lc3NhZ2U7XG5cblx0XHRpZihjYWxsYmFjayl7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiU2VuZGluZyBjb25maXJtYXRpb25cIiwgcHJvY2Vzcy5waWQpO1xuXHRcdFx0cmVjaXBpZW50LnNlbmQoYnVpbGRFbnZlbG9wZUNvbmZpcm1hdGlvbihlbnZlbG9wZSwgdHJ1ZSkpO1xuXHRcdFx0Y29uc3VtZXIobnVsbCwgSlNPTi5wYXJzZShtZXNzYWdlKSk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5yZWdpc3RlckFzSVBDQ29uc3VtZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuXHRcdH1cblx0XHRyZWdpc3RlcmVkQXNJUENDb25zdW1lciA9IHRydWU7XG5cdFx0Ly93aWxsIHJlZ2lzdGVyIGFzIG5vcm1hbCBjb25zdW1lciBpbiBvcmRlciB0byBjb25zdW1lIGFsbCBleGlzdGluZyBtZXNzYWdlcyBidXQgd2l0aG91dCBzZXR0aW5nIHRoZSB3YXRjaGVyXG5cdFx0dGhpcy5yZWdpc3RlckNvbnN1bWVyKGNhbGxiYWNrLCB0cnVlLCAod2F0Y2hlcikgPT4gIXdhdGNoZXIpO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcIlJlZ2lzdGVyZWQgYXMgSVBDIENvbnN1bW1lclwiLCApO1xuXHRcdChyZWNpcGllbnQgfHwgcHJvY2Vzcykub24oXCJtZXNzYWdlXCIsIHJlY2VpdmVFbnZlbG9wZSk7XG5cdH07XG5cblx0dGhpcy5yZWdpc3RlckNvbnN1bWVyID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzaG91bGREZWxldGVBZnRlclJlYWQgPSB0cnVlLCBzaG91bGRXYWl0Rm9yTW9yZSA9ICh3YXRjaGVyKSA9PiB0cnVlKSB7XG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuXHRcdH1cblx0XHRpZiAoY29uc3VtZXIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGNvbnN1bWVyIGlzIGFsbG93ZWQhIFwiICsgZm9sZGVyKTtcblx0XHR9XG5cblx0XHRjb25zdW1lciA9IGNhbGxiYWNrO1xuXG5cdFx0ZnMubWtkaXIoZm9sZGVyLCB7cmVjdXJzaXZlOiB0cnVlfSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG5cdFx0XHRpZiAoZXJyICYmIChlcnIuY29kZSAhPT0gJ0VFWElTVCcpKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGVycik7XG5cdFx0XHR9XG5cdFx0XHRjb25zdW1lQWxsRXhpc3Rpbmcoc2hvdWxkRGVsZXRlQWZ0ZXJSZWFkLCBzaG91bGRXYWl0Rm9yTW9yZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0dGhpcy53cml0ZU1lc3NhZ2UgPSB3cml0ZUZpbGU7XG5cblx0dGhpcy51bmxpbmtDb250ZW50ID0gZnVuY3Rpb24gKG1lc3NhZ2VJZCwgY2FsbGJhY2spIHtcblx0XHRjb25zdCBtZXNzYWdlUGF0aCA9IHBhdGguam9pbihmb2xkZXIsIG1lc3NhZ2VJZCk7XG5cblx0XHRmcy51bmxpbmsobWVzc2FnZVBhdGgsIChlcnIpID0+IHtcblx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0fSk7XG5cdH07XG5cblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oZm9yY2Upe1xuXHRcdGlmKHR5cGVvZiBmb2xkZXIgIT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHR2YXIgZmlsZXM7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdGZpbGVzID0gZnMucmVhZGRpclN5bmMoZm9sZGVyKTtcblx0XHRcdH1jYXRjaChlcnJvcil7XG5cdFx0XHRcdC8vLi5cblx0XHRcdH1cblxuXHRcdFx0aWYoZmlsZXMgJiYgZmlsZXMubGVuZ3RoID4gMCAmJiAhZm9yY2Upe1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkRpc3Bvc2luZyBhIGNoYW5uZWwgdGhhdCBzdGlsbCBoYXMgbWVzc2FnZXMhIERpciB3aWxsIG5vdCBiZSByZW1vdmVkIVwiKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRmcy5ybWRpclN5bmMoZm9sZGVyKTtcblx0XHRcdFx0fWNhdGNoKGVycil7XG5cdFx0XHRcdFx0Ly8uLlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvbGRlciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYocHJvZHVjZXIpe1xuXHRcdFx0Ly9ubyBuZWVkIHRvIGRvIGFueXRoaW5nIGVsc2Vcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgY29uc3VtZXIgIT0gXCJ1bmRlZmluZWRcIil7XG5cdFx0XHRjb25zdW1lciA9ICgpID0+IHt9O1xuXHRcdH1cblxuXHRcdGlmKHdhdGNoZXIpe1xuXHRcdFx0d2F0Y2hlci5jbG9zZSgpO1xuXHRcdFx0d2F0Y2hlciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tIHByb3RlY3RlZCAgZnVuY3Rpb25zICovXG5cdHZhciBjb25zdW1lciA9IG51bGw7XG5cdHZhciByZWdpc3RlcmVkQXNJUENDb25zdW1lciA9IGZhbHNlO1xuXHR2YXIgcHJvZHVjZXIgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIGJ1aWxkUGF0aEZvckZpbGUoZmlsZW5hbWUpe1xuXHRcdHJldHVybiBwYXRoLm5vcm1hbGl6ZShwYXRoLmpvaW4oZm9sZGVyLCBmaWxlbmFtZSkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29uc3VtZU1lc3NhZ2UoZmlsZW5hbWUsIHNob3VsZERlbGV0ZUFmdGVyUmVhZCwgY2FsbGJhY2spIHtcblx0XHR2YXIgZnVsbFBhdGggPSBidWlsZFBhdGhGb3JGaWxlKGZpbGVuYW1lKTtcblxuXHRcdGZzLnJlYWRGaWxlKGZ1bGxQYXRoLCBcInV0ZjhcIiwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuXHRcdFx0aWYgKCFlcnIpIHtcblx0XHRcdFx0aWYgKGRhdGEgIT09IFwiXCIpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlBhcnNpbmcgZXJyb3JcIiwgZXJyb3IpO1xuXHRcdFx0XHRcdFx0ZXJyID0gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoY2hlY2tJZkNvbnN1bW1lZChmdWxsUGF0aCwgZGF0YSkpe1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhgbWVzc2FnZSBhbHJlYWR5IGNvbnN1bWVkIFske2ZpbGVuYW1lfV1gKTtcblx0XHRcdFx0XHRcdHJldHVybiA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHNob3VsZERlbGV0ZUFmdGVyUmVhZCkge1xuXG5cdFx0XHRcdFx0XHRmcy51bmxpbmsoZnVsbFBhdGgsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuXHRcdFx0XHRcdFx0XHRpZiAoZXJyKSB7dGhyb3cgZXJyO307XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyLCBtZXNzYWdlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJDb25zdW1lIGVycm9yXCIsIGVycik7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29uc3VtZUFsbEV4aXN0aW5nKHNob3VsZERlbGV0ZUFmdGVyUmVhZCwgc2hvdWxkV2FpdEZvck1vcmUpIHtcblxuXHRcdGxldCBjdXJyZW50RmlsZXMgPSBbXTtcblxuXHRcdGZzLnJlYWRkaXIoZm9sZGVyLCAndXRmOCcsIGZ1bmN0aW9uIChlcnIsIGZpbGVzKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdCQkLmVycm9ySGFuZGxlci5lcnJvcihlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50RmlsZXMgPSBmaWxlcztcblx0XHRcdGl0ZXJhdGVBbmRDb25zdW1lKGZpbGVzKTtcblxuXHRcdH0pO1xuXG5cdFx0ZnVuY3Rpb24gc3RhcnRXYXRjaGluZygpe1xuXHRcdFx0aWYgKHNob3VsZFdhaXRGb3JNb3JlKHRydWUpKSB7XG5cdFx0XHRcdHdhdGNoRm9sZGVyKHNob3VsZERlbGV0ZUFmdGVyUmVhZCwgc2hvdWxkV2FpdEZvck1vcmUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGl0ZXJhdGVBbmRDb25zdW1lKGZpbGVzLCBjdXJyZW50SW5kZXggPSAwKSB7XG5cdFx0XHRpZiAoY3VycmVudEluZGV4ID09PSBmaWxlcy5sZW5ndGgpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcInN0YXJ0IHdhdGNoaW5nXCIsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblx0XHRcdFx0c3RhcnRXYXRjaGluZygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwYXRoLmV4dG5hbWUoZmlsZXNbY3VycmVudEluZGV4XSkgIT09IGluX3Byb2dyZXNzKSB7XG5cdFx0XHRcdGNvbnN1bWVNZXNzYWdlKGZpbGVzW2N1cnJlbnRJbmRleF0sIHNob3VsZERlbGV0ZUFmdGVyUmVhZCwgKGVyciwgZGF0YSkgPT4ge1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdGl0ZXJhdGVBbmRDb25zdW1lKGZpbGVzLCArK2N1cnJlbnRJbmRleCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN1bWVyKG51bGwsIGRhdGEsIHBhdGguYmFzZW5hbWUoZmlsZXNbY3VycmVudEluZGV4XSkpO1xuXHRcdFx0XHRcdGlmIChzaG91bGRXYWl0Rm9yTW9yZSgpKSB7XG5cdFx0XHRcdFx0XHRpdGVyYXRlQW5kQ29uc3VtZShmaWxlcywgKytjdXJyZW50SW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpdGVyYXRlQW5kQ29uc3VtZShmaWxlcywgKytjdXJyZW50SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHdyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudCwgY2FsbGJhY2spe1xuXHRcdGlmKHJlY2lwaWVudCl7XG5cdFx0XHR2YXIgZW52ZWxvcGUgPSBidWlsZEVudmVsb3BlKGZpbGVuYW1lLCBjb250ZW50KTtcblx0XHRcdC8vY29uc29sZS5sb2coXCJTZW5kaW5nIHRvXCIsIHJlY2lwaWVudC5waWQsIHJlY2lwaWVudC5wcGlkLCBcImVudmVsb3BlXCIsIGVudmVsb3BlKTtcblx0XHRcdHJlY2lwaWVudC5zZW5kKGVudmVsb3BlKTtcblx0XHRcdHZhciBjb25maXJtYXRpb25SZWNlaXZlZCA9IGZhbHNlO1xuXG5cdFx0XHRmdW5jdGlvbiByZWNlaXZlQ29uZmlybWF0aW9uKG1lc3NhZ2Upe1xuXHRcdFx0XHRpZihtZXNzYWdlID09PSBidWlsZEVudmVsb3BlQ29uZmlybWF0aW9uKGVudmVsb3BlKSl7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIlJlY2VpdmVkIGNvbmZpcm1hdGlvblwiLCByZWNpcGllbnQucGlkKTtcblx0XHRcdFx0XHRjb25maXJtYXRpb25SZWNlaXZlZCA9IHRydWU7XG5cdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0cmVjaXBpZW50Lm9mZihcIm1lc3NhZ2VcIiwgcmVjZWl2ZUNvbmZpcm1hdGlvbik7XG5cdFx0XHRcdFx0fWNhdGNoKGVycil7XG5cdFx0XHRcdFx0XHQvLy4uLlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJlY2lwaWVudC5vbihcIm1lc3NhZ2VcIiwgcmVjZWl2ZUNvbmZpcm1hdGlvbik7XG5cblx0XHRcdHNldFRpbWVvdXQoKCk9Pntcblx0XHRcdFx0aWYoIWNvbmZpcm1hdGlvblJlY2VpdmVkKXtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiTm8gY29uZmlybWF0aW9uLi4uXCIsIHByb2Nlc3MucGlkKTtcblx0XHRcdFx0XHRoaWRkZW5fd3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50LCBjYWxsYmFjayk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGlmKGNhbGxiYWNrKXtcblx0XHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjb250ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIDIwMCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRoaWRkZW5fd3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50LCBjYWxsYmFjayk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgaW5fcHJvZ3Jlc3MgPSBcIi5pbl9wcm9ncmVzc1wiO1xuXHRmdW5jdGlvbiBoaWRkZW5fd3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50LCBjYWxsYmFjayl7XG5cdFx0dmFyIHRtcEZpbGVuYW1lID0gZmlsZW5hbWUraW5fcHJvZ3Jlc3M7XG5cdFx0dHJ5e1xuXHRcdFx0aWYoZnMuZXhpc3RzU3luYyh0bXBGaWxlbmFtZSkgfHwgZnMuZXhpc3RzU3luYyhmaWxlbmFtZSkpe1xuXHRcdFx0XHRjb25zb2xlLmxvZyhuZXcgRXJyb3IoYE92ZXJ3cml0aW5nIGZpbGUgJHtmaWxlbmFtZX1gKSk7XG5cdFx0XHR9XG5cdFx0XHRmcy53cml0ZUZpbGVTeW5jKHRtcEZpbGVuYW1lLCBjb250ZW50KTtcblx0XHRcdGZzLnJlbmFtZVN5bmModG1wRmlsZW5hbWUsIGZpbGVuYW1lKTtcblx0XHR9Y2F0Y2goZXJyKXtcblx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xuXHRcdH1cblx0XHRjYWxsYmFjayhudWxsLCBjb250ZW50KTtcblx0fVxuXG5cdHZhciBhbHJlYWR5S25vd25DaGFuZ2VzID0ge307XG5cblx0ZnVuY3Rpb24gYWxyZWFkeUZpcmVkQ2hhbmdlcyhmaWxlbmFtZSwgY2hhbmdlKXtcblx0XHR2YXIgcmVzID0gZmFsc2U7XG5cdFx0aWYoYWxyZWFkeUtub3duQ2hhbmdlc1tmaWxlbmFtZV0pe1xuXHRcdFx0cmVzID0gdHJ1ZTtcblx0XHR9ZWxzZXtcblx0XHRcdGFscmVhZHlLbm93bkNoYW5nZXNbZmlsZW5hbWVdID0gY2hhbmdlO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHRmdW5jdGlvbiB3YXRjaEZvbGRlcihzaG91bGREZWxldGVBZnRlclJlYWQsIHNob3VsZFdhaXRGb3JNb3JlKXtcblxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdGZzLnJlYWRkaXIoZm9sZGVyLCAndXRmOCcsIGZ1bmN0aW9uIChlcnIsIGZpbGVzKSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHQkJC5lcnJvckhhbmRsZXIuZXJyb3IoZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IodmFyIGk9MDsgaTxmaWxlcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0d2F0Y2hGaWxlc0hhbmRsZXIoXCJjaGFuZ2VcIiwgZmlsZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCAxMDAwKTtcblxuXHRcdGZ1bmN0aW9uIHdhdGNoRmlsZXNIYW5kbGVyKGV2ZW50VHlwZSwgZmlsZW5hbWUpe1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhgR290ICR7ZXZlbnRUeXBlfSBvbiAke2ZpbGVuYW1lfWApO1xuXG5cdFx0XHRpZighZmlsZW5hbWUgfHwgcGF0aC5leHRuYW1lKGZpbGVuYW1lKSA9PT0gaW5fcHJvZ3Jlc3Mpe1xuXHRcdFx0XHQvL2NhdWdodCBhIGRlbGV0ZSBldmVudCBvZiBhIGZpbGVcblx0XHRcdFx0Ly9vclxuXHRcdFx0XHQvL2ZpbGUgbm90IHJlYWR5IHRvIGJlIGNvbnN1bWVkIChpbiBwcm9ncmVzcylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZiA9IGJ1aWxkUGF0aEZvckZpbGUoZmlsZW5hbWUpO1xuXHRcdFx0aWYoIWZzLmV4aXN0c1N5bmMoZikpe1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiRmlsZSBub3QgZm91bmRcIiwgZik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly9jb25zb2xlLmxvZyhgUHJlcGFyaW5nIHRvIGNvbnN1bWUgJHtmaWxlbmFtZX1gKTtcblx0XHRcdGlmKCFhbHJlYWR5RmlyZWRDaGFuZ2VzKGZpbGVuYW1lLCBldmVudFR5cGUpKXtcblx0XHRcdFx0Y29uc3VtZU1lc3NhZ2UoZmlsZW5hbWUsIHNob3VsZERlbGV0ZUFmdGVyUmVhZCwgKGVyciwgZGF0YSkgPT4ge1xuXHRcdFx0XHRcdC8vYWxsb3cgYSByZWFkIGEgdGhlIGZpbGVcblx0XHRcdFx0XHRhbHJlYWR5S25vd25DaGFuZ2VzW2ZpbGVuYW1lXSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdC8vID8/XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlxcbkNhdWdodCBhbiBlcnJvclwiLCBlcnIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN1bWVyKG51bGwsIGRhdGEsIGZpbGVuYW1lKTtcblxuXG5cdFx0XHRcdFx0aWYgKCFzaG91bGRXYWl0Rm9yTW9yZSgpKSB7XG5cdFx0XHRcdFx0XHR3YXRjaGVyLmNsb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIlNvbWV0aGluZyBoYXBwZW5zLi4uXCIsIGZpbGVuYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGNvbnN0IHdhdGNoZXIgPSBmcy53YXRjaChmb2xkZXIsIHdhdGNoRmlsZXNIYW5kbGVyKTtcblxuXHRcdGNvbnN0IGludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbCgoKT0+e1xuXHRcdFx0ZnMucmVhZGRpcihmb2xkZXIsICd1dGY4JywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdCQkLmVycm9ySGFuZGxlci5lcnJvcihlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGZpbGVzLmxlbmd0aCA+IDApe1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBcXG5cXG5Gb3VuZCAke2ZpbGVzLmxlbmd0aH0gZmlsZXMgbm90IGNvbnN1bWVkIHlldCBpbiAke2ZvbGRlcn1gLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcIlxcblxcblwiKTtcblx0XHRcdFx0XHQvL2Zha2luZyBhIHJlbmFtZSBldmVudCB0cmlnZ2VyXG5cdFx0XHRcdFx0d2F0Y2hGaWxlc0hhbmRsZXIoXCJyZW5hbWVcIiwgZmlsZXNbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCA1MDAwKTtcblx0fVxufVxuXG5leHBvcnRzLmdldEZvbGRlclF1ZXVlID0gZnVuY3Rpb24oZm9sZGVyLCBjYWxsYmFjayl7XG5cdHJldHVybiBuZXcgRm9sZGVyTVEoZm9sZGVyLCBjYWxsYmFjayk7XG59O1xuIiwiZnVuY3Rpb24gUFNLQnVmZmVyKCkge31cblxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXJJbnRlcmZhY2UgKCkge1xuICAgIGlmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBTaGFyZWRBcnJheUJ1ZmZlcjtcbiAgICB9XG59XG5cblBTS0J1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGNvbnN0IEFycmF5QnVmZmVySW50ZXJmYWNlID0gZ2V0QXJyYXlCdWZmZXJJbnRlcmZhY2UoKTtcblxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlckludGVyZmFjZShzb3VyY2UubGVuZ3RoKSk7XG4gICAgYnVmZmVyLnNldChzb3VyY2UsIDApO1xuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cblBTS0J1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAoWyAuLi5wYXJhbXMgXSwgdG90YWxMZW5ndGgpIHtcbiAgICBjb25zdCBBcnJheUJ1ZmZlckludGVyZmFjZSA9IGdldEFycmF5QnVmZmVySW50ZXJmYWNlKCk7XG5cbiAgICBpZiAoIXRvdGFsTGVuZ3RoICYmIHRvdGFsTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgcGFyYW1zKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVySW50ZXJmYWNlKHRvdGFsTGVuZ3RoKSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gb2Zmc2V0ICsgbGVuO1xuICAgICAgICBpZiAobmV4dE9mZnNldCA+IHRvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IHRvdGFsTGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1haW5pbmdTcGFjZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gYnVmW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLnNldChidWYsIG9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG59O1xuXG5QU0tCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAocHNrQnVmZmVyKSB7XG4gICAgcmV0dXJuICEhQXJyYXlCdWZmZXIuaXNWaWV3KHBza0J1ZmZlcik7XG59O1xuXG5QU0tCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgY29uc3QgQXJyYXlCdWZmZXJJbnRlcmZhY2UgPSBnZXRBcnJheUJ1ZmZlckludGVyZmFjZSgpO1xuXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlckludGVyZmFjZShzaXplKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBTS0J1ZmZlcjsiLCJjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IEtleUVuY29kZXIgPSByZXF1aXJlKCcuL2tleUVuY29kZXInKTtcblxuZnVuY3Rpb24gRUNEU0EoY3VydmVOYW1lKXtcbiAgICB0aGlzLmN1cnZlID0gY3VydmVOYW1lIHx8ICdzZWNwMjU2azEnO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ICAgICA9IHt9O1xuICAgICAgICBjb25zdCBlYyAgICAgICAgID0gY3J5cHRvLmNyZWF0ZUVDREgoc2VsZi5jdXJ2ZSk7XG4gICAgICAgIHJlc3VsdC5wdWJsaWMgID0gZWMuZ2VuZXJhdGVLZXlzKCdoZXgnKTtcbiAgICAgICAgcmVzdWx0LnByaXZhdGUgPSBlYy5nZXRQcml2YXRlS2V5KCdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGtleXNUb1BFTShyZXN1bHQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBrZXlzVG9QRU0oa2V5cyl7XG4gICAgICAgIGNvbnN0IHJlc3VsdCAgICAgICAgICAgICAgICAgID0ge307XG4gICAgICAgIGNvbnN0IEVDUHJpdmF0ZUtleUFTTiAgICAgICAgID0gS2V5RW5jb2Rlci5FQ1ByaXZhdGVLZXlBU047XG4gICAgICAgIGNvbnN0IFN1YmplY3RQdWJsaWNLZXlJbmZvQVNOID0gS2V5RW5jb2Rlci5TdWJqZWN0UHVibGljS2V5SW5mb0FTTjtcbiAgICAgICAgY29uc3Qga2V5RW5jb2RlciAgICAgICAgICAgICAgPSBuZXcgS2V5RW5jb2RlcihzZWxmLmN1cnZlKTtcblxuICAgICAgICBjb25zdCBwcml2YXRlS2V5T2JqZWN0ICAgICAgICA9IGtleUVuY29kZXIucHJpdmF0ZUtleU9iamVjdChrZXlzLnByaXZhdGUsa2V5cy5wdWJsaWMpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlPYmplY3QgICAgICAgICA9IGtleUVuY29kZXIucHVibGljS2V5T2JqZWN0KGtleXMucHVibGljKTtcblxuICAgICAgICByZXN1bHQucHJpdmF0ZSAgICAgICAgICAgICAgPSBFQ1ByaXZhdGVLZXlBU04uZW5jb2RlKHByaXZhdGVLZXlPYmplY3QsICdwZW0nLCBwcml2YXRlS2V5T2JqZWN0LnBlbU9wdGlvbnMpO1xuICAgICAgICByZXN1bHQucHVibGljICAgICAgICAgICAgICAgPSBTdWJqZWN0UHVibGljS2V5SW5mb0FTTi5lbmNvZGUocHVibGljS2V5T2JqZWN0LCAncGVtJywgcHVibGljS2V5T2JqZWN0LnBlbU9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNpZ24gPSBmdW5jdGlvbiAocHJpdmF0ZUtleSxkaWdlc3QpIHtcbiAgICAgICAgY29uc3Qgc2lnbiA9IGNyeXB0by5jcmVhdGVTaWduKFwic2hhMjU2XCIpO1xuICAgICAgICBzaWduLnVwZGF0ZShkaWdlc3QpO1xuXG4gICAgICAgIHJldHVybiBzaWduLnNpZ24ocHJpdmF0ZUtleSwnaGV4Jyk7XG4gICAgfTtcblxuICAgIHRoaXMudmVyaWZ5ID0gZnVuY3Rpb24gKHB1YmxpY0tleSxzaWduYXR1cmUsZGlnZXN0KSB7XG4gICAgICAgIGNvbnN0IHZlcmlmeSA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ3NoYTI1NicpO1xuICAgICAgICB2ZXJpZnkudXBkYXRlKGRpZ2VzdCk7XG5cbiAgICAgICAgcmV0dXJuIHZlcmlmeS52ZXJpZnkocHVibGljS2V5LHNpZ25hdHVyZSwnaGV4Jyk7XG4gICAgfVxufVxuXG5leHBvcnRzLmNyZWF0ZUVDRFNBID0gZnVuY3Rpb24gKGN1cnZlKXtcbiAgICByZXR1cm4gbmV3IEVDRFNBKGN1cnZlKTtcbn07IiwiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NyeXB0b1V0aWxzXCIpO1xuXG5jb25zdCBQYXNzVGhyb3VnaFN0cmVhbSA9IHJlcXVpcmUoJy4vdXRpbHMvUGFzc1Rocm91Z2hTdHJlYW0nKTtcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB0ZW1wRm9sZGVyID0gb3MudG1wZGlyKCk7XG5cbmZ1bmN0aW9uIFBza0NyeXB0bygpIHtcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICB0aGlzLm9uID0gZXZlbnQub247XG4gICAgdGhpcy5vZmYgPSBldmVudC5yZW1vdmVMaXN0ZW5lcjtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyA9IGV2ZW50LnJlbW92ZUFsbExpc3RlbmVycztcbiAgICB0aGlzLmVtaXQgPSBldmVudC5lbWl0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRUNEU0EgZnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgY29uc3QgZWNkc2EgPSByZXF1aXJlKFwiLi9FQ0RTQVwiKS5jcmVhdGVFQ0RTQSgpO1xuICAgIHRoaXMuZ2VuZXJhdGVFQ0RTQUtleVBhaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlY2RzYS5nZW5lcmF0ZUtleVBhaXIoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaWduID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGRpZ2VzdCkge1xuICAgICAgICByZXR1cm4gZWNkc2Euc2lnbihwcml2YXRlS2V5LCBkaWdlc3QpO1xuICAgIH07XG5cbiAgICB0aGlzLnZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNpZ25hdHVyZSwgZGlnZXN0KSB7XG4gICAgICAgIHJldHVybiBlY2RzYS52ZXJpZnkocHVibGljS2V5LCBzaWduYXR1cmUsIGRpZ2VzdCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tRW5jcnlwdGlvbiBmdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICB0aGlzLmVuY3J5cHRTdHJlYW0gPSBmdW5jdGlvbiAoaW5wdXRQYXRoLCBkZXN0aW5hdGlvblBhdGgsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBQc2tBcmNoaXZlciA9IHJlcXVpcmUoXCIuL3Bzay1hcmNoaXZlclwiKTtcbiAgICAgICAgY29uc3QgYXJjaGl2ZXIgPSBuZXcgUHNrQXJjaGl2ZXIoKTtcblxuICAgICAgICBhcmNoaXZlci5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZzLm9wZW4oZGVzdGluYXRpb25QYXRoLCBcInd4XCIsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB3cyA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRlc3RpbmF0aW9uUGF0aCwge2F1dG9DbG9zZTogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwga2V5U2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhYWRTYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhYWQgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgYWFkU2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzYWx0ID0gQnVmZmVyLmNvbmNhdChba2V5U2FsdCwgYWFkU2FsdF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl2ID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIHV0aWxzLml0ZXJhdGlvbnNfbnVtYmVyLCAxMiwgJ3NoYTUxMicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KHV0aWxzLmFsZ29yaXRobSwga2V5LCBpdik7XG4gICAgICAgICAgICAgICAgY2lwaGVyLnNldEFBRChhYWQpO1xuICAgICAgICAgICAgICAgIGFyY2hpdmVyLnppcFN0cmVhbShpbnB1dFBhdGgsIGNpcGhlciwgZnVuY3Rpb24gKGVyciwgY2lwaGVyU3RyZWFtKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaXBoZXJTdHJlYW0ub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3Mud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YVRvQXBwZW5kID0gQnVmZmVyLmNvbmNhdChbc2FsdCwgdGFnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cy5lbmQoZGF0YVRvQXBwZW5kLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuZGVjcnlwdFN0cmVhbSA9IGZ1bmN0aW9uIChlbmNyeXB0ZWRJbnB1dFBhdGgsIG91dHB1dEZvbGRlciwgcGFzc3dvcmQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IFBza0FyY2hpdmVyID0gcmVxdWlyZShcIi4vcHNrLWFyY2hpdmVyXCIpO1xuICAgICAgICBjb25zdCBhcmNoaXZlciA9IG5ldyBQc2tBcmNoaXZlcigpO1xuXG4gICAgICAgIGRlY3J5cHRGaWxlKGVuY3J5cHRlZElucHV0UGF0aCwgdGVtcEZvbGRlciwgcGFzc3dvcmQsIGZ1bmN0aW9uIChlcnIsIHRlbXBBcmNoaXZlUGF0aCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcmNoaXZlci5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgMTAgKyAwLjkgKiBwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICBhcmNoaXZlci51bnppcFN0cmVhbSh0ZW1wQXJjaGl2ZVBhdGgsIG91dHB1dEZvbGRlciwgZnVuY3Rpb24gKGVyciwgdW56aXBwZWRGaWxlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGV0ZVJlY3Vyc2l2ZWx5KHRlbXBBcmNoaXZlUGF0aCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdW56aXBwZWRGaWxlTmFtZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9O1xuXG4gICAgdGhpcy5lbmNyeXB0T2JqZWN0ID0gZnVuY3Rpb24gKGlucHV0T2JqLCBkc2VlZCwgZGVwdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IFBza0FyY2hpdmVyID0gcmVxdWlyZShcIi4vcHNrLWFyY2hpdmVyXCIpO1xuICAgICAgICBjb25zdCBhcmNoaXZlciA9IG5ldyBQc2tBcmNoaXZlcigpO1xuXG4gICAgICAgIGFyY2hpdmVyLnppcEluTWVtb3J5KGlucHV0T2JqLCBkZXB0aCwgZnVuY3Rpb24gKGVyciwgemlwcGVkT2JqKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaXBoZXJUZXh0ID0gdXRpbHMuZW5jcnlwdCh6aXBwZWRPYmosIGRzZWVkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNpcGhlclRleHQpO1xuICAgICAgICB9KVxuICAgIH07XG5cbiAgICB0aGlzLmRlY3J5cHRPYmplY3QgPSBmdW5jdGlvbiAoZW5jcnlwdGVkRGF0YSwgZHNlZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IFBza0FyY2hpdmVyID0gcmVxdWlyZShcIi4vcHNrLWFyY2hpdmVyXCIpO1xuICAgICAgICBjb25zdCBhcmNoaXZlciA9IG5ldyBQc2tBcmNoaXZlcigpO1xuXG4gICAgICAgIGNvbnN0IHppcHBlZE9iamVjdCA9IHV0aWxzLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgZHNlZWQpO1xuICAgICAgICBhcmNoaXZlci51bnppcEluTWVtb3J5KHppcHBlZE9iamVjdCwgZnVuY3Rpb24gKGVyciwgb2JqKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBvYmopO1xuICAgICAgICB9KVxuICAgIH07XG5cbiAgICB0aGlzLnBza0hhc2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuY3JlYXRlUHNrSGFzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmNyZWF0ZVBza0hhc2goSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVQc2tIYXNoKGRhdGEpO1xuICAgIH07XG5cbiAgICB0aGlzLnBza0hhc2hTdHJlYW0gPSBmdW5jdGlvbiAocmVhZFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcHNrSGFzaCA9IG5ldyB1dGlscy5Qc2tIYXNoKCk7XG5cbiAgICAgICAgcmVhZFN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcHNrSGFzaC51cGRhdGUoY2h1bmspO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIHJlYWRTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBza0hhc2guZGlnZXN0KCkpO1xuICAgICAgICB9KVxuICAgIH07XG5cblxuICAgIHRoaXMuc2F2ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgcGFzc3dvcmQsIHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSB0aGlzLmRlcml2ZUtleShwYXNzd29yZCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IGl2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KCdhZXMtMjU2LWNmYicsIGVuY3J5cHRpb25LZXksIGl2KTtcbiAgICAgICAgbGV0IGVuY3J5cHRlZERTZWVkID0gY2lwaGVyLnVwZGF0ZShkYXRhLCAnYmluYXJ5Jyk7XG4gICAgICAgIGNvbnN0IGZpbmFsID0gQnVmZmVyLmZyb20oY2lwaGVyLmZpbmFsKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgICBlbmNyeXB0ZWREU2VlZCA9IEJ1ZmZlci5jb25jYXQoW2l2LCBlbmNyeXB0ZWREU2VlZCwgZmluYWxdKTtcbiAgICAgICAgZnMud3JpdGVGaWxlKHBhdGgsIGVuY3J5cHRlZERTZWVkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLmxvYWREYXRhID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBwYXRoLCBjYWxsYmFjaykge1xuXG4gICAgICAgIGZzLnJlYWRGaWxlKHBhdGgsIG51bGwsIChlcnIsIGVuY3J5cHRlZERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdiA9IGVuY3J5cHRlZERhdGEuc2xpY2UoMCwgMTYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZERzZWVkID0gZW5jcnlwdGVkRGF0YS5zbGljZSgxNik7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jcnlwdGlvbktleSA9IHRoaXMuZGVyaXZlS2V5KHBhc3N3b3JkLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMjU2LWNmYicsIGVuY3J5cHRpb25LZXksIGl2KTtcbiAgICAgICAgICAgICAgICBsZXQgZHNlZWQgPSBCdWZmZXIuZnJvbShkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkRHNlZWQsICdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsID0gQnVmZmVyLmZyb20oZGVjaXBoZXIuZmluYWwoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICAgICAgZHNlZWQgPSBCdWZmZXIuY29uY2F0KFtkc2VlZCwgZmluYWxdKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkc2VlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIHRoaXMuZ2VuZXJhdGVTYWZlVWlkID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBhZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICBwYXNzd29yZCA9IHBhc3N3b3JkIHx8IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgaWYgKCFhZGRpdGlvbmFsRGF0YSkge1xuICAgICAgICAgICAgYWRkaXRpb25hbERhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhZGRpdGlvbmFsRGF0YSkpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxEYXRhID0gQnVmZmVyLmZyb20oYWRkaXRpb25hbERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnBza0hhc2goQnVmZmVyLmNvbmNhdChbcGFzc3dvcmQsIGFkZGl0aW9uYWxEYXRhXSkpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5kZXJpdmVLZXkgPSBmdW5jdGlvbiBkZXJpdmVLZXkocGFzc3dvcmQsIGl0ZXJhdGlvbnMsIGRrTGVuKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zIHx8IDEwMDA7XG4gICAgICAgIGRrTGVuID0gZGtMZW4gfHwgMzI7XG4gICAgICAgIGNvbnN0IHNhbHQgPSB1dGlscy5nZW5lcmF0ZVNhbHQocGFzc3dvcmQsIDMyKTtcbiAgICAgICAgY29uc3QgZGsgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywgZGtMZW4sICdzaGE1MTInKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRrKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yYW5kb21CeXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcztcbiAgICB0aGlzLlBza0hhc2ggPSB1dGlscy5Qc2tIYXNoO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJbnRlcm5hbCBmdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBkZWNyeXB0RmlsZShlbmNyeXB0ZWRJbnB1dFBhdGgsIHRlbXBGb2xkZXIsIHBhc3N3b3JkLCBjYWxsYmFjaykge1xuICAgICAgICBmcy5zdGF0KGVuY3J5cHRlZElucHV0UGF0aCwgZnVuY3Rpb24gKGVyciwgc3RhdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmlsZVNpemVJbkJ5dGVzID0gc3RhdHMuc2l6ZTtcblxuICAgICAgICAgICAgZnMub3BlbihlbmNyeXB0ZWRJbnB1dFBhdGgsIFwiclwiLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRBdXRoRGF0YSA9IEJ1ZmZlci5hbGxvYyg4MCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZnMucmVhZChmZCwgZW5jcnlwdGVkQXV0aERhdGEsIDAsIDgwLCBmaWxlU2l6ZUluQnl0ZXMgLSA4MCwgZnVuY3Rpb24gKGVyciwgYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzYWx0ID0gZW5jcnlwdGVkQXV0aERhdGEuc2xpY2UoMCwgNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5U2FsdCA9IHNhbHQuc2xpY2UoMCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWFkU2FsdCA9IHNhbHQuc2xpY2UoLTMyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXYgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDEyLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwga2V5U2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhYWQgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgYWFkU2FsdCwgdXRpbHMuaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSBlbmNyeXB0ZWRBdXRoRGF0YS5zbGljZSgtMTYpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KHV0aWxzLmFsZ29yaXRobSwga2V5LCBpdik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2lwaGVyLnNldEFBRChhYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyh0YWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnMgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGVuY3J5cHRlZElucHV0UGF0aCwge3N0YXJ0OiAwLCBlbmQ6IGZpbGVTaXplSW5CeXRlcyAtIDgxfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcy5ta2Rpcih0ZW1wRm9sZGVyLCB7cmVjdXJzaXZlOiB0cnVlfSwgZnVuY3Rpb24gKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEFyY2hpdmVQYXRoID0gcGF0aC5qb2luKHRlbXBGb2xkZXIsIHBhdGguYmFzZW5hbWUoZW5jcnlwdGVkSW5wdXRQYXRoKSArIFwiLnppcFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzLm9wZW4odGVtcEFyY2hpdmVQYXRoLCBcIndcIiwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoZXJyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2hTdHJlYW0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3MgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbSh0ZW1wQXJjaGl2ZVBhdGgsIHthdXRvQ2xvc2U6IGZhbHNlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cy5vbihcImZpbmlzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGVtcEFyY2hpdmVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm9ncmVzc0xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRPRE8gcmV2aWV3IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEluIGJyb3dzZXIsIHBpcGluZyB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIGFuZCB0aGUgc3RhY2sgcXVldWUgaXMgbm90IGNhbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnMub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NMZW5ndGggPiAzMDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0UHJvZ3Jlc3MoZmlsZVNpemVJbkJ5dGVzLCB0b3RhbExlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnMucGlwZShkZWNpcGhlcikucGlwZShwdFN0cmVhbSkucGlwZSh3cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbWl0UHJvZ3Jlc3ModG90YWwsIHByb2Nlc3NlZCkge1xuXG5cbiAgICAgICAgaWYgKHByb2Nlc3NlZCA+IHRvdGFsKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWQgPSB0b3RhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gKDEwMCAqIHByb2Nlc3NlZCkgLyB0b3RhbDtcbiAgICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIHBhcnNlSW50KHByb2dyZXNzKSk7XG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFBza0NyeXB0bygpO1xuIiwidmFyIGFzbjEgPSByZXF1aXJlKCcuL2FzbjEnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcblxudmFyIGFwaSA9IGV4cG9ydHM7XG5cbmFwaS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUobmFtZSwgYm9keSkge1xuICByZXR1cm4gbmV3IEVudGl0eShuYW1lLCBib2R5KTtcbn07XG5cbmZ1bmN0aW9uIEVudGl0eShuYW1lLCBib2R5KSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgdGhpcy5kZWNvZGVycyA9IHt9O1xuICB0aGlzLmVuY29kZXJzID0ge307XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9jcmVhdGVOYW1lZCA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVkKGJhc2UpIHtcbiAgdmFyIG5hbWVkO1xuICB0cnkge1xuICAgIG5hbWVkID0gcmVxdWlyZSgndm0nKS5ydW5JblRoaXNDb250ZXh0KFxuICAgICAgJyhmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJyhlbnRpdHkpIHtcXG4nICtcbiAgICAgICcgIHRoaXMuX2luaXROYW1lZChlbnRpdHkpO1xcbicgK1xuICAgICAgJ30pJ1xuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBuYW1lZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgIHRoaXMuX2luaXROYW1lZChlbnRpdHkpO1xuICAgIH07XG4gIH1cbiAgaW5oZXJpdHMobmFtZWQsIGJhc2UpO1xuICBuYW1lZC5wcm90b3R5cGUuX2luaXROYW1lZCA9IGZ1bmN0aW9uIGluaXRuYW1lZChlbnRpdHkpIHtcbiAgICBiYXNlLmNhbGwodGhpcywgZW50aXR5KTtcbiAgfTtcblxuICByZXR1cm4gbmV3IG5hbWVkKHRoaXMpO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fZ2V0RGVjb2RlciA9IGZ1bmN0aW9uIF9nZXREZWNvZGVyKGVuYykge1xuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcbiAgaWYgKCF0aGlzLmRlY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5kZWNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5kZWNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZGVjb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5fZ2V0RGVjb2RlcihlbmMpLmRlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldEVuY29kZXIgPSBmdW5jdGlvbiBfZ2V0RW5jb2RlcihlbmMpIHtcbiAgLy8gTGF6aWx5IGNyZWF0ZSBlbmNvZGVyXG4gIGlmICghdGhpcy5lbmNvZGVycy5oYXNPd25Qcm9wZXJ0eShlbmMpKVxuICAgIHRoaXMuZW5jb2RlcnNbZW5jXSA9IHRoaXMuX2NyZWF0ZU5hbWVkKGFzbjEuZW5jb2RlcnNbZW5jXSk7XG4gIHJldHVybiB0aGlzLmVuY29kZXJzW2VuY107XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBlbmMsIC8qIGludGVybmFsICovIHJlcG9ydGVyKSB7XG4gIHJldHVybiB0aGlzLl9nZXRFbmNvZGVyKGVuYykuZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbn07XG4iLCJ2YXIgYXNuMSA9IGV4cG9ydHM7XG5cbmFzbjEuYmlnbnVtID0gcmVxdWlyZSgnLi9iaWdudW0vYm4nKTtcblxuYXNuMS5kZWZpbmUgPSByZXF1aXJlKCcuL2FwaScpLmRlZmluZTtcbmFzbjEuYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS9pbmRleCcpO1xuYXNuMS5jb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9pbmRleCcpO1xuYXNuMS5kZWNvZGVycyA9IHJlcXVpcmUoJy4vZGVjb2RlcnMvaW5kZXgnKTtcbmFzbjEuZW5jb2RlcnMgPSByZXF1aXJlKCcuL2VuY29kZXJzL2luZGV4Jyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBEZWNvZGVyQnVmZmVyKGJhc2UsIG9wdGlvbnMpIHtcbiAgUmVwb3J0ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYmFzZSkpIHtcbiAgICB0aGlzLmVycm9yKCdJbnB1dCBub3QgQnVmZmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLmxlbmd0aCA9IGJhc2UubGVuZ3RoO1xufVxuaW5oZXJpdHMoRGVjb2RlckJ1ZmZlciwgUmVwb3J0ZXIpO1xuZXhwb3J0cy5EZWNvZGVyQnVmZmVyID0gRGVjb2RlckJ1ZmZlcjtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHJldHVybiB7IG9mZnNldDogdGhpcy5vZmZzZXQsIHJlcG9ydGVyOiBSZXBvcnRlci5wcm90b3R5cGUuc2F2ZS5jYWxsKHRoaXMpIH07XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShzYXZlKSB7XG4gIC8vIFJldHVybiBza2lwcGVkIGRhdGFcbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0O1xuXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIFJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlLmNhbGwodGhpcywgc2F2ZS5yZXBvcnRlcik7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IHRoaXMubGVuZ3RoO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KGZhaWwpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICsgMSA8PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChieXRlcywgZmFpbCkge1xuICBpZiAoISh0aGlzLm9mZnNldCArIGJ5dGVzIDw9IHRoaXMubGVuZ3RoKSlcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcblxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcblxuICAvLyBTaGFyZSByZXBvcnRlciBzdGF0ZVxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJlcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XG4gIHRoaXMub2Zmc2V0ICs9IGJ5dGVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiByYXcoc2F2ZSkge1xuICByZXR1cm4gdGhpcy5iYXNlLnNsaWNlKHNhdmUgPyBzYXZlLm9mZnNldCA6IHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIEVuY29kZXJCdWZmZXIodmFsdWUsIHJlcG9ydGVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBFbmNvZGVyQnVmZmVyKSlcbiAgICAgICAgaXRlbSA9IG5ldyBFbmNvZGVyQnVmZmVyKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMHhmZikpXG4gICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ25vbi1ieXRlIEVuY29kZXJCdWZmZXIgdmFsdWUnKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xuXG5FbmNvZGVyQnVmZmVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihvdXQsIG9mZnNldCkge1xuICBpZiAoIW91dClcbiAgICBvdXQgPSBuZXcgQnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgaWYgKCFvZmZzZXQpXG4gICAgb2Zmc2V0ID0gMDtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG91dDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpdGVtLmpvaW4ob3V0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGl0ZW0ubGVuZ3RoO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICBvdXRbb2Zmc2V0XSA9IHRoaXMudmFsdWU7XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgb3V0LndyaXRlKHRoaXMudmFsdWUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMudmFsdWUpKVxuICAgICAgdGhpcy52YWx1ZS5jb3B5KG91dCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbiIsInZhciBiYXNlID0gZXhwb3J0cztcblxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmJhc2UuRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmJhc2UuRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRW5jb2RlckJ1ZmZlcjtcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuIiwidmFyIFJlcG9ydGVyID0gcmVxdWlyZSgnLi4vYmFzZScpLlJlcG9ydGVyO1xudmFyIEVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuRW5jb2RlckJ1ZmZlcjtcbi8vdmFyIGFzc2VydCA9IHJlcXVpcmUoJ2RvdWJsZS1jaGVjaycpLmFzc2VydDtcblxuLy8gU3VwcG9ydGVkIHRhZ3NcbnZhciB0YWdzID0gW1xuICAnc2VxJywgJ3NlcW9mJywgJ3NldCcsICdzZXRvZicsICdvY3RzdHInLCAnYml0c3RyJywgJ29iamlkJywgJ2Jvb2wnLFxuICAnZ2VudGltZScsICd1dGN0aW1lJywgJ251bGxfJywgJ2VudW0nLCAnaW50JywgJ2lhNXN0cicsICd1dGY4c3RyJ1xuXTtcblxuLy8gUHVibGljIG1ldGhvZHMgbGlzdFxudmFyIG1ldGhvZHMgPSBbXG4gICdrZXknLCAnb2JqJywgJ3VzZScsICdvcHRpb25hbCcsICdleHBsaWNpdCcsICdpbXBsaWNpdCcsICdkZWYnLCAnY2hvaWNlJyxcbiAgJ2FueSdcbl0uY29uY2F0KHRhZ3MpO1xuXG4vLyBPdmVycmlkZWQgbWV0aG9kcyBsaXN0XG52YXIgb3ZlcnJpZGVkID0gW1xuICAnX3BlZWtUYWcnLCAnX2RlY29kZVRhZycsICdfdXNlJyxcbiAgJ19kZWNvZGVTdHInLCAnX2RlY29kZU9iamlkJywgJ19kZWNvZGVUaW1lJyxcbiAgJ19kZWNvZGVOdWxsJywgJ19kZWNvZGVJbnQnLCAnX2RlY29kZUJvb2wnLCAnX2RlY29kZUxpc3QnLFxuXG4gICdfZW5jb2RlQ29tcG9zaXRlJywgJ19lbmNvZGVTdHInLCAnX2VuY29kZU9iamlkJywgJ19lbmNvZGVUaW1lJyxcbiAgJ19lbmNvZGVOdWxsJywgJ19lbmNvZGVJbnQnLCAnX2VuY29kZUJvb2wnXG5dO1xuXG5mdW5jdGlvbiBOb2RlKGVuYywgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHt9O1xuICB0aGlzLl9iYXNlU3RhdGUgPSBzdGF0ZTtcblxuICBzdGF0ZS5lbmMgPSBlbmM7XG5cbiAgc3RhdGUucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHN0YXRlLmNoaWxkcmVuID0gbnVsbDtcblxuICAvLyBTdGF0ZVxuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5hcmdzID0gbnVsbDtcbiAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBudWxsO1xuICBzdGF0ZS5jaG9pY2UgPSBudWxsO1xuICBzdGF0ZS5vcHRpb25hbCA9IGZhbHNlO1xuICBzdGF0ZS5hbnkgPSBmYWxzZTtcbiAgc3RhdGUub2JqID0gZmFsc2U7XG4gIHN0YXRlLnVzZSA9IG51bGw7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBudWxsO1xuICBzdGF0ZS5rZXkgPSBudWxsO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gbnVsbDtcbiAgc3RhdGUuZXhwbGljaXQgPSBudWxsO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG5cbiAgLy8gU2hvdWxkIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb24gZWFjaCBtZXRob2RcbiAgaWYgKCFzdGF0ZS5wYXJlbnQpIHtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuX3dyYXAoKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG52YXIgc3RhdGVQcm9wcyA9IFtcbiAgJ2VuYycsICdwYXJlbnQnLCAnY2hpbGRyZW4nLCAndGFnJywgJ2FyZ3MnLCAncmV2ZXJzZUFyZ3MnLCAnY2hvaWNlJyxcbiAgJ29wdGlvbmFsJywgJ2FueScsICdvYmonLCAndXNlJywgJ2FsdGVyZWRVc2UnLCAna2V5JywgJ2RlZmF1bHQnLCAnZXhwbGljaXQnLFxuICAnaW1wbGljaXQnXG5dO1xuXG5Ob2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBjc3RhdGUgPSB7fTtcbiAgc3RhdGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBjc3RhdGVbcHJvcF0gPSBzdGF0ZVtwcm9wXTtcbiAgfSk7XG4gIHZhciByZXMgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihjc3RhdGUucGFyZW50KTtcbiAgcmVzLl9iYXNlU3RhdGUgPSBjc3RhdGU7XG4gIHJldHVybiByZXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fd3JhcCA9IGZ1bmN0aW9uIHdyYXAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHRoaXNbbWV0aG9kXSA9IGZ1bmN0aW9uIF93cmFwcGVkTWV0aG9kKCkge1xuICAgICAgdmFyIGNsb25lID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgICBzdGF0ZS5jaGlsZHJlbi5wdXNoKGNsb25lKTtcbiAgICAgIHJldHVybiBjbG9uZVttZXRob2RdLmFwcGx5KGNsb25lLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0sIHRoaXMpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGJvZHkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vYXNzZXJ0LmVxdWFsKHN0YXRlLnBhcmVudCxudWxsLCdzdGF0ZS5wYXJlbnQgc2hvdWxkIGJlIG51bGwnKTtcbiAgYm9keS5jYWxsKHRoaXMpO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlblxuICBzdGF0ZS5jaGlsZHJlbiA9IHN0YXRlLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9PT0gdGhpcztcbiAgfSwgdGhpcyk7XG4gIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5jaGlsZHJlbi5sZW5ndGgsIDEsICdSb290IG5vZGUgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl91c2VBcmdzID0gZnVuY3Rpb24gdXNlQXJncyhhcmdzKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW4gYW5kIGFyZ3NcbiAgdmFyIGNoaWxkcmVuID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I7XG4gIH0sIHRoaXMpO1xuICBhcmdzID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuICEoYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUuY2hpbGRyZW4sIG51bGwsICdzdGF0ZS5jaGlsZHJlbiBzaG91bGQgYmUgbnVsbCcpO1xuICAgIHN0YXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAvLyBSZXBsYWNlIHBhcmVudCB0byBtYWludGFpbiBiYWNrd2FyZCBsaW5rXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPSB0aGlzO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5hcmdzLCBudWxsLCAnc3RhdGUuYXJncyBzaG91bGQgYmUgbnVsbCcpO1xuICAgIHN0YXRlLmFyZ3MgPSBhcmdzO1xuICAgIHN0YXRlLnJldmVyc2VBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpXG4gICAgICAgIHJldHVybiBhcmc7XG5cbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSAoa2V5IHwgMCkpXG4gICAgICAgICAga2V5IHw9IDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ1trZXldO1xuICAgICAgICByZXNbdmFsdWVdID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG59O1xuXG4vL1xuLy8gT3ZlcnJpZGVkIG1ldGhvZHNcbi8vXG5cbm92ZXJyaWRlZC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBOb2RlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gX292ZXJyaWRlZCgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgbm90IGltcGxlbWVudGVkIGZvciBlbmNvZGluZzogJyArIHN0YXRlLmVuYyk7XG4gIH07XG59KTtcblxuLy9cbi8vIFB1YmxpYyBtZXRob2RzXG4vL1xuXG50YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gIE5vZGUucHJvdG90eXBlW3RhZ10gPSBmdW5jdGlvbiBfdGFnTWV0aG9kKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUudGFnLCBudWxsLCAnc3RhdGUudGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgc3RhdGUudGFnID0gdGFnO1xuXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbk5vZGUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShpdGVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBhc3NlcnQuZXF1YWwoc3RhdGUudXNlLCBudWxsLCAnc3RhdGUudXNlIHNob3VsZCBiZSBudWxsJyk7XG4gIHN0YXRlLnVzZSA9IGl0ZW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vcHRpb25hbCA9IGZ1bmN0aW9uIG9wdGlvbmFsKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZGVmID0gZnVuY3Rpb24gZGVmKHZhbCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlWydkZWZhdWx0J10sIG51bGwsIFwic3RhdGVbJ2RlZmF1bHQnXSBzaG91bGQgYmUgbnVsbFwiKTtcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IHZhbDtcbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZXhwbGljaXQgPSBmdW5jdGlvbiBleHBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5leHBsaWNpdCxudWxsLCAnc3RhdGUuZXhwbGljaXQgc2hvdWxkIGJlIG51bGwnKTtcbiAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLmltcGxpY2l0LG51bGwsICdzdGF0ZS5pbXBsaWNpdCBzaG91bGQgYmUgbnVsbCcpO1xuXG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuaW1wbGljaXQgPSBmdW5jdGlvbiBpbXBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gICAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLmV4cGxpY2l0LG51bGwsICdzdGF0ZS5leHBsaWNpdCBzaG91bGQgYmUgbnVsbCcpO1xuICAgIC8vIGFzc2VydC5lcXVhbChzdGF0ZS5pbXBsaWNpdCxudWxsLCAnc3RhdGUuaW1wbGljaXQgc2hvdWxkIGJlIG51bGwnKTtcblxuICAgIHN0YXRlLmltcGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub2JqID0gZnVuY3Rpb24gb2JqKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBzdGF0ZS5vYmogPSB0cnVlO1xuXG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMClcbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24ga2V5KG5ld0tleSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLmtleSwgbnVsbCwgJ3N0YXRlLmtleSBzaG91bGQgYmUgbnVsbCcpO1xuICBzdGF0ZS5rZXkgPSBuZXdLZXk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiBhbnkoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5hbnkgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuY2hvaWNlID0gZnVuY3Rpb24gY2hvaWNlKG9iaikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLmNob2ljZSwgbnVsbCwnc3RhdGUuY2hvaWNlIHNob3VsZCBiZSBudWxsJyk7XG4gIHN0YXRlLmNob2ljZSA9IG9iajtcbiAgdGhpcy5fdXNlQXJncyhPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBEZWNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxuICBpZiAoc3RhdGUucGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBpbnB1dC53cmFwUmVzdWx0KHN0YXRlLmNoaWxkcmVuWzBdLl9kZWNvZGUoaW5wdXQpKTtcblxuICB2YXIgcmVzdWx0ID0gc3RhdGVbJ2RlZmF1bHQnXTtcbiAgdmFyIHByZXNlbnQgPSB0cnVlO1xuXG4gIHZhciBwcmV2S2V5O1xuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsKVxuICAgIHByZXZLZXkgPSBpbnB1dC5lbnRlcktleShzdGF0ZS5rZXkpO1xuXG4gIC8vIENoZWNrIGlmIHRhZyBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwpIHtcbiAgICB2YXIgdGFnID0gbnVsbDtcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5leHBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmltcGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLnRhZztcblxuICAgIGlmICh0YWcgPT09IG51bGwgJiYgIXN0YXRlLmFueSkge1xuICAgICAgLy8gVHJpYWwgYW5kIEVycm9yXG4gICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCk7XG4gICAgICAgIHByZXNlbnQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcmVzZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVzZW50ID0gdGhpcy5fcGVla1RhZyhpbnB1dCwgdGFnLCBzdGF0ZS5hbnkpO1xuXG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihwcmVzZW50KSlcbiAgICAgICAgcmV0dXJuIHByZXNlbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBvYmplY3Qgb24gc3RhY2tcbiAgdmFyIHByZXZPYmo7XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICBwcmV2T2JqID0gaW5wdXQuZW50ZXJPYmplY3QoKTtcblxuICBpZiAocHJlc2VudCkge1xuICAgIC8vIFVud3JhcCBleHBsaWNpdCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpIHtcbiAgICAgIHZhciBleHBsaWNpdCA9IHRoaXMuX2RlY29kZVRhZyhpbnB1dCwgc3RhdGUuZXhwbGljaXQpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoZXhwbGljaXQpKVxuICAgICAgICByZXR1cm4gZXhwbGljaXQ7XG4gICAgICBpbnB1dCA9IGV4cGxpY2l0O1xuICAgIH1cblxuICAgIC8vIFVud3JhcCBpbXBsaWNpdCBhbmQgbm9ybWFsIHZhbHVlc1xuICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5fZGVjb2RlVGFnKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZyxcbiAgICAgICAgc3RhdGUuYW55XG4gICAgICApO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoYm9keSkpXG4gICAgICAgIHJldHVybiBib2R5O1xuXG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICByZXN1bHQgPSBpbnB1dC5yYXcoc2F2ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGlucHV0ID0gYm9keTtcbiAgICB9XG5cbiAgICAvLyBTZWxlY3QgcHJvcGVyIG1ldGhvZCBmb3IgdGFnXG4gICAgaWYgKHN0YXRlLmFueSlcbiAgICAgIHJlc3VsdCA9IHJlc3VsdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQpO1xuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCk7XG5cbiAgICBpZiAoaW5wdXQuaXNFcnJvcihyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIC8vIERlY29kZSBjaGlsZHJlblxuICAgIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhaWwgPSBzdGF0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIGRlY29kZUNoaWxkcmVuKGNoaWxkKSB7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSBpZ25vcmluZyBlcnJvcnMgaGVyZSwgdG8gbGV0IHBhcnNlciBjb250aW51ZSB3aXRoIG90aGVyXG4gICAgICAgIC8vIHBhcnRzIG9mIGVuY29kZWQgZGF0YVxuICAgICAgICBjaGlsZC5fZGVjb2RlKGlucHV0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGZhaWwpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICB9XG5cbiAgLy8gUG9wIG9iamVjdFxuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcmVzdWx0ID0gaW5wdXQubGVhdmVPYmplY3QocHJldk9iaik7XG5cbiAgLy8gU2V0IGtleVxuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsICYmIChyZXN1bHQgIT09IG51bGwgfHwgcHJlc2VudCA9PT0gdHJ1ZSkpXG4gICAgaW5wdXQubGVhdmVLZXkocHJldktleSwgc3RhdGUua2V5LCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlR2VuZXJpYyA9IGZ1bmN0aW9uIGRlY29kZUdlbmVyaWModGFnLCBpbnB1dCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgaWYgKHRhZyA9PT0gJ3NlcScgfHwgdGFnID09PSAnc2V0JylcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHRhZyA9PT0gJ3NlcW9mJyB8fCB0YWcgPT09ICdzZXRvZicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUxpc3QoaW5wdXQsIHRhZywgc3RhdGUuYXJnc1swXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29jdHN0cicgfHwgdGFnID09PSAnYml0c3RyJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpYTVzdHInIHx8IHRhZyA9PT0gJ3V0ZjhzdHInKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgc3RhdGUuYXJnc1swXSwgc3RhdGUuYXJnc1sxXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIG51bGwsIG51bGwpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlVGltZShpbnB1dCwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVOdWxsKGlucHV0KTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJvb2woaW5wdXQpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVJbnQoaW5wdXQsIHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJnc1swXSk7XG4gIGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbClcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgaW5wdXQuX3JlcG9ydGVyU3RhdGUub2JqKS5fZGVjb2RlKGlucHV0KTtcbiAgZWxzZVxuICAgIHJldHVybiBpbnB1dC5lcnJvcigndW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIHJldHVybiBudWxsO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2dldFVzZSA9IGZ1bmN0aW9uIF9nZXRVc2UoZW50aXR5LCBvYmopIHtcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIC8vIENyZWF0ZSBhbHRlcmVkIHVzZSBkZWNvZGVyIGlmIGltcGxpY2l0IGlzIHNldFxuICBzdGF0ZS51c2VEZWNvZGVyID0gdGhpcy5fdXNlKGVudGl0eSwgb2JqKTtcbiAgLy8gYXNzZXJ0LmVxdWFsKHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5wYXJlbnQsIG51bGwsICdzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUucGFyZW50IHNob3VsZCBiZSBudWxsJyk7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuY2hpbGRyZW5bMF07XG4gIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0KSB7XG4gICAgc3RhdGUudXNlRGVjb2RlciA9IHN0YXRlLnVzZURlY29kZXIuY2xvbmUoKTtcbiAgICBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgfVxuICByZXR1cm4gc3RhdGUudXNlRGVjb2Rlcjtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVDaG9pY2UgPSBmdW5jdGlvbiBkZWNvZGVDaG9pY2UoaW5wdXQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2tleV07XG4gICAgdHJ5IHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUuX2RlY29kZShpbnB1dCk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgcmVzdWx0ID0geyB0eXBlOiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCB0aGlzKTtcblxuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBpbnB1dC5lcnJvcignQ2hvaWNlIG5vdCBtYXRjaGVkJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFbmNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2NyZWF0ZUVuY29kZXJCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyQnVmZmVyKGRhdGEsIHRoaXMucmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwgJiYgc3RhdGVbJ2RlZmF1bHQnXSA9PT0gZGF0YSlcbiAgICByZXR1cm47XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2VuY29kZVZhbHVlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpO1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuO1xuXG4gIGlmICh0aGlzLl9za2lwRGVmYXVsdChyZXN1bHQsIHJlcG9ydGVyLCBwYXJlbnQpKVxuICAgIHJldHVybjtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVZhbHVlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gc3RhdGUuY2hpbGRyZW5bMF0uX2VuY29kZShkYXRhLCByZXBvcnRlciB8fCBuZXcgUmVwb3J0ZXIoKSk7XG5cbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBwcmVzZW50ID0gdHJ1ZTtcblxuICAvLyBTZXQgcmVwb3J0ZXIgdG8gc2hhcmUgaXQgd2l0aCBhIGNoaWxkIGNsYXNzXG4gIHRoaXMucmVwb3J0ZXIgPSByZXBvcnRlcjtcblxuICAvLyBDaGVjayBpZiBkYXRhIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbClcbiAgICAgIGRhdGEgPSBzdGF0ZVsnZGVmYXVsdCddXG4gICAgZWxzZVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yIGVycm9yIHJlcG9ydGluZ1xuICB2YXIgcHJldktleTtcblxuICAvLyBFbmNvZGUgY2hpbGRyZW4gZmlyc3RcbiAgdmFyIGNvbnRlbnQgPSBudWxsO1xuICB2YXIgcHJpbWl0aXZlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAvLyBBbnl0aGluZyB0aGF0IHdhcyBnaXZlbiBpcyB0cmFuc2xhdGVkIHRvIGJ1ZmZlclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hvaWNlKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLnRhZyA9PT0gJ251bGxfJylcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xuXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gcmVwb3J0ZXIuZW50ZXJLZXkoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkpO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIGV4cGVjdGVkLCBidXQgaW5wdXQgaXMgbm90IG9iamVjdCcpO1xuXG4gICAgICB2YXIgcmVzID0gY2hpbGQuX2VuY29kZShkYXRhW2NoaWxkLl9iYXNlU3RhdGUua2V5XSwgcmVwb3J0ZXIsIGRhdGEpO1xuICAgICAgcmVwb3J0ZXIubGVhdmVLZXkocHJldktleSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG5cbiAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGUudGFnID09PSAnc2Vxb2YnIHx8IHN0YXRlLnRhZyA9PT0gJ3NldG9mJykge1xuICAgICAgLy8gVE9ETyhpbmR1dG55KTogdGhpcyBzaG91bGQgYmUgdGhyb3duIG9uIERTTCBsZXZlbFxuICAgICAgaWYgKCEoc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzLmxlbmd0aCA9PT0gMSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVG9vIG1hbnkgYXJncyBmb3IgOiAnICsgc3RhdGUudGFnKTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ3NlcW9mL3NldG9mLCBidXQgZGF0YSBpcyBub3QgQXJyYXknKTtcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jbG9uZSgpO1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gICAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLmFyZ3NbMF0sIGRhdGEpLl9lbmNvZGUoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgfSwgY2hpbGQpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuX2VuY29kZVByaW1pdGl2ZShzdGF0ZS50YWcsIGRhdGEpO1xuICAgICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmNvZGUgZGF0YSBpdHNlbGZcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgdmFyIHRhZyA9IHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWc7XG4gICAgdmFyIGNscyA9IHN0YXRlLmltcGxpY2l0ID09PSBudWxsID8gJ3VuaXZlcnNhbCcgOiAnY29udGV4dCc7XG5cbiAgICBpZiAodGFnID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXBvcnRlci5lcnJvcignVGFnIGNvdWxkIGJlIG9tbWl0ZWQgb25seSBmb3IgLnVzZSgpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNvbXBvc2l0ZSh0YWcsIHByaW1pdGl2ZSwgY2xzLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwIGluIGV4cGxpY2l0XG4gIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUoc3RhdGUuZXhwbGljaXQsIGZhbHNlLCAnY29udGV4dCcsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVDaG9pY2UgPSBmdW5jdGlvbiBlbmNvZGVDaG9pY2UoZGF0YSwgcmVwb3J0ZXIpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2RhdGEudHlwZV07XG4gIC8vIGlmICghbm9kZSkge1xuICAvLyAgIGFzc2VydChcbiAgLy8gICAgICAgZmFsc2UsXG4gIC8vICAgICAgIGRhdGEudHlwZSArICcgbm90IGZvdW5kIGluICcgK1xuICAvLyAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKSkpO1xuICAvLyB9XG4gIHJldHVybiBub2RlLl9lbmNvZGUoZGF0YS52YWx1ZSwgcmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVByaW1pdGl2ZSA9IGZ1bmN0aW9uIGVuY29kZVByaW1pdGl2ZSh0YWcsIGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdvY3RzdHInIHx8IHRhZyA9PT0gJ2JpdHN0cicgfHwgdGFnID09PSAnaWE1c3RyJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ3V0ZjhzdHInKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIHN0YXRlLnJldmVyc2VBcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBudWxsLCBudWxsKTtcbiAgZWxzZSBpZiAodGFnID09PSAnZ2VudGltZScgfHwgdGFnID09PSAndXRjdGltZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVRpbWUoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVOdWxsKCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUludChkYXRhLCBzdGF0ZS5hcmdzICYmIHN0YXRlLnJldmVyc2VBcmdzWzBdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUJvb2woZGF0YSk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRhZzogJyArIHRhZyk7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuXG5mdW5jdGlvbiBSZXBvcnRlcihvcHRpb25zKSB7XG4gIHRoaXMuX3JlcG9ydGVyU3RhdGUgPSB7XG4gICAgb2JqOiBudWxsLFxuICAgIHBhdGg6IFtdLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXG4gICAgZXJyb3JzOiBbXVxuICB9O1xufVxuZXhwb3J0cy5SZXBvcnRlciA9IFJlcG9ydGVyO1xuXG5SZXBvcnRlci5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJldHVybiB7IG9iajogc3RhdGUub2JqLCBwYXRoTGVuOiBzdGF0ZS5wYXRoLmxlbmd0aCB9O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5vYmogPSBkYXRhLm9iajtcbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgZGF0YS5wYXRoTGVuKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlcktleSA9IGZ1bmN0aW9uIGVudGVyS2V5KGtleSkge1xuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLnB1c2goa2V5KTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZUtleSA9IGZ1bmN0aW9uIGxlYXZlS2V5KGluZGV4LCBrZXksIHZhbHVlKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgaW5kZXggLSAxKTtcbiAgaWYgKHN0YXRlLm9iaiAhPT0gbnVsbClcbiAgICBzdGF0ZS5vYmpba2V5XSA9IHZhbHVlO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyT2JqZWN0ID0gZnVuY3Rpb24gZW50ZXJPYmplY3QoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIHByZXYgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHt9O1xuICByZXR1cm4gcHJldjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZU9iamVjdCA9IGZ1bmN0aW9uIGxlYXZlT2JqZWN0KHByZXYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgbm93ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSBwcmV2O1xuICByZXR1cm4gbm93O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHZhciBlcnI7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIGluaGVyaXRlZCA9IG1zZyBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG4gIGlmIChpbmhlcml0ZWQpIHtcbiAgICBlcnIgPSBtc2c7XG4gIH0gZWxzZSB7XG4gICAgZXJyID0gbmV3IFJlcG9ydGVyRXJyb3Ioc3RhdGUucGF0aC5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgJ10nO1xuICAgIH0pLmpvaW4oJycpLCBtc2cubWVzc2FnZSB8fCBtc2csIG1zZy5zdGFjayk7XG4gIH1cblxuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICB0aHJvdyBlcnI7XG5cbiAgaWYgKCFpbmhlcml0ZWQpXG4gICAgc3RhdGUuZXJyb3JzLnB1c2goZXJyKTtcblxuICByZXR1cm4gZXJyO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLndyYXBSZXN1bHQgPSBmdW5jdGlvbiB3cmFwUmVzdWx0KHJlc3VsdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB0aGlzLmlzRXJyb3IocmVzdWx0KSA/IG51bGwgOiByZXN1bHQsXG4gICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlcG9ydGVyRXJyb3IocGF0aCwgbXNnKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMucmV0aHJvdyhtc2cpO1xufTtcbmluaGVyaXRzKFJlcG9ydGVyRXJyb3IsIEVycm9yKTtcblxuUmVwb3J0ZXJFcnJvci5wcm90b3R5cGUucmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3cobXNnKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1zZyArICcgYXQ6ICcgKyAodGhpcy5wYXRoIHx8ICcoc2hhbGxvdyknKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVwb3J0ZXJFcnJvcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG4vLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuLy8gYXJjaGl0ZWN0dXJlIHlldC5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcbn1cblxuLy8gQk5cblxuZnVuY3Rpb24gQk4obnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgLy8gTWF5IGJlIGBuZXcgQk4oYm4pYCA/XG4gIGlmIChudW1iZXIgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnICYmXG4gICAgICBBcnJheS5pc0FycmF5KG51bWJlci53b3JkcykpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgdGhpcy5zaWduID0gZmFsc2U7XG4gIHRoaXMud29yZHMgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgdGhpcy5yZWQgPSBudWxsO1xuXG4gIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICBlbmRpYW4gPSBiYXNlO1xuICAgIGJhc2UgPSAxMDtcbiAgfVxuXG4gIGlmIChudW1iZXIgIT09IG51bGwpXG4gICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xufVxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuZWxzZVxuICBleHBvcnRzLkJOID0gQk47XG5cbkJOLkJOID0gQk47XG5CTi53b3JkU2l6ZSA9IDI2O1xuXG5CTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICB9XG4gIGlmIChiYXNlID09PSAnaGV4JylcbiAgICBiYXNlID0gMTY7XG4gIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgaWYgKG51bWJlclswXSA9PT0gJy0nKVxuICAgIHN0YXJ0Kys7XG5cbiAgaWYgKGJhc2UgPT09IDE2KVxuICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuICBlbHNlXG4gICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuXG4gIGlmIChudW1iZXJbMF0gPT09ICctJylcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xuXG4gIHRoaXMuc3RyaXAoKTtcblxuICBpZiAoZW5kaWFuICE9PSAnbGUnKVxuICAgIHJldHVybjtcblxuICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG59O1xuXG5CTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICBpZiAobnVtYmVyIDwgMCkge1xuICAgIHRoaXMuc2lnbiA9IHRydWU7XG4gICAgbnVtYmVyID0gLW51bWJlcjtcbiAgfVxuICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICB0aGlzLndvcmRzID0gW1xuICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICBdO1xuICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgIHRoaXMud29yZHMgPSBbXG4gICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgIDFcbiAgICBdO1xuICAgIHRoaXMubGVuZ3RoID0gMztcbiAgfVxuXG4gIGlmIChlbmRpYW4gIT09ICdsZScpXG4gICAgcmV0dXJuO1xuXG4gIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cbiAgdmFyIG9mZiA9IDA7XG4gIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICBmb3IgKHZhciBpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgdmFyIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgb2ZmICs9IDI0O1xuICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICB2YXIgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuZnVuY3Rpb24gcGFyc2VIZXgoc3RyLCBzdGFydCwgZW5kKSB7XG4gIHZhciByID0gMDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgciA8PD0gNDtcblxuICAgIC8vICdhJyAtICdmJ1xuICAgIGlmIChjID49IDQ5ICYmIGMgPD0gNTQpXG4gICAgICByIHw9IGMgLSA0OSArIDB4YTtcblxuICAgIC8vICdBJyAtICdGJ1xuICAgIGVsc2UgaWYgKGMgPj0gMTcgJiYgYyA8PSAyMilcbiAgICAgIHIgfD0gYyAtIDE3ICsgMHhhO1xuXG4gICAgLy8gJzAnIC0gJzknXG4gICAgZWxzZVxuICAgICAgciB8PSBjICYgMHhmO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5CTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpIHtcbiAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gMDtcblxuICAvLyBTY2FuIDI0LWJpdCBjaHVua3MgYW5kIGFkZCB0aGVtIHRvIHRoZSBudW1iZXJcbiAgdmFyIG9mZiA9IDA7XG4gIGZvciAodmFyIGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuICAgIHZhciB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG4gICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICBvZmYgKz0gMjQ7XG4gICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgb2ZmIC09IDI2O1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG4gICAgdmFyIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG4gICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgfVxuICB0aGlzLnN0cmlwKCk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUJhc2Uoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgdmFyIHIgPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICByICo9IG11bDtcblxuICAgIC8vICdhJ1xuICAgIGlmIChjID49IDQ5KVxuICAgICAgciArPSBjIC0gNDkgKyAweGE7XG5cbiAgICAvLyAnQSdcbiAgICBlbHNlIGlmIChjID49IDE3KVxuICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cbiAgICAvLyAnMCcgLSAnOSdcbiAgICBlbHNlXG4gICAgICByICs9IGM7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbkJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICB0aGlzLndvcmRzID0gWyAwIF07XG4gIHRoaXMubGVuZ3RoID0gMTtcblxuICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKVxuICAgIGxpbWJMZW4rKztcbiAgbGltYkxlbi0tO1xuICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gIHZhciB3b3JkID0gMDtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApXG4gICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgZWxzZVxuICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gIH1cblxuICBpZiAobW9kICE9PSAwKSB7XG4gICAgdmFyIHBvdyA9IDE7XG4gICAgdmFyIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kOyBpKyspXG4gICAgICBwb3cgKj0gYmFzZTtcbiAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKVxuICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICB9XG59O1xuXG5CTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkoZGVzdCkge1xuICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICBkZXN0LnNpZ24gPSB0aGlzLnNpZ247XG4gIGRlc3QucmVkID0gdGhpcy5yZWQ7XG59O1xuXG5CTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gIHRoaXMuY29weShyKTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbkJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwKCkge1xuICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMClcbiAgICB0aGlzLmxlbmd0aC0tO1xuICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24oKSB7XG4gIC8vIC0wID0gMFxuICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMClcbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xufTtcblxuLypcblxudmFyIHplcm9zID0gW107XG52YXIgZ3JvdXBTaXplcyA9IFtdO1xudmFyIGdyb3VwQmFzZXMgPSBbXTtcblxudmFyIHMgPSAnJztcbnZhciBpID0gLTE7XG53aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgemVyb3NbaV0gPSBzO1xuICBzICs9ICcwJztcbn1cbmdyb3VwU2l6ZXNbMF0gPSAwO1xuZ3JvdXBTaXplc1sxXSA9IDA7XG5ncm91cEJhc2VzWzBdID0gMDtcbmdyb3VwQmFzZXNbMV0gPSAwO1xudmFyIGJhc2UgPSAyIC0gMTtcbndoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gIHZhciBncm91cEJhc2UgPSAxO1xuICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgIGdyb3VwU2l6ZSArPSAxO1xuICB9XG4gIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG59XG5cbiovXG5cbnZhciB6ZXJvcyA9IFtcbiAgJycsXG4gICcwJyxcbiAgJzAwJyxcbiAgJzAwMCcsXG4gICcwMDAwJyxcbiAgJzAwMDAwJyxcbiAgJzAwMDAwMCcsXG4gICcwMDAwMDAwJyxcbiAgJzAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuXTtcblxudmFyIGdyb3VwU2l6ZXMgPSBbXG4gIDAsIDAsXG4gIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgOCwgNywgNywgNywgNywgNiwgNixcbiAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuXTtcblxudmFyIGdyb3VwQmFzZXMgPSBbXG4gIDAsIDAsXG4gIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuXTtcblxuQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoYmFzZSwgcGFkZGluZykge1xuICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgdmFyIG91dCA9ICcnO1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpXG4gICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgZWxzZVxuICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgb2ZmICs9IDI7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApXG4gICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKVxuICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgIGlmICh0aGlzLnNpZ24pXG4gICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgcmV0dXJuIG91dDtcbiAgfSBlbHNlIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgYy5zaWduID0gZmFsc2U7XG4gICAgd2hpbGUgKGMuY21wbigwKSAhPT0gMCkge1xuICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICBlbHNlXG4gICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXG4gICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgaWYgKHRoaXMuc2lnbilcbiAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICByZXR1cm4gb3V0O1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfVxufTtcblxuQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xufTtcblxuQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KGVuZGlhbikge1xuICB0aGlzLnN0cmlwKCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkodGhpcy5ieXRlTGVuZ3RoKCkpO1xuICByZXNbMF0gPSAwO1xuXG4gIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuICBpZiAoZW5kaWFuICE9PSAnbGUnKSB7XG4gICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICBmb3IgKHZhciBpID0gMDsgcS5jbXBuKDApICE9PSAwOyBpKyspIHtcbiAgICAgIHZhciBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgIHEuaXNocm4oOCk7XG5cbiAgICAgIHJlc1tyZXMubGVuZ3RoIC0gaSAtIDFdID0gYjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzdW1lIGxpdHRsZS1lbmRpYW5cbiAgICBmb3IgKHZhciBpID0gMDsgcS5jbXBuKDApICE9PSAwOyBpKyspIHtcbiAgICAgIHZhciBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgIHEuaXNocm4oOCk7XG5cbiAgICAgIHJlc1tpXSA9IGI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmlmIChNYXRoLmNsejMyKSB7XG4gIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyh3KSB7XG4gICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgfTtcbn0gZWxzZSB7XG4gIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyh3KSB7XG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgcmV0dXJuIHIgKyB0O1xuICB9O1xufVxuXG5CTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzKHcpIHtcbiAgLy8gU2hvcnQtY3V0XG4gIGlmICh3ID09PSAwKVxuICAgIHJldHVybiAyNjtcblxuICB2YXIgdCA9IHc7XG4gIHZhciByID0gMDtcbiAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgIHIgKz0gMTM7XG4gICAgdCA+Pj49IDEzO1xuICB9XG4gIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgciArPSA3O1xuICAgIHQgPj4+PSA3O1xuICB9XG4gIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICByICs9IDQ7XG4gICAgdCA+Pj49IDQ7XG4gIH1cbiAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgIHIgKz0gMjtcbiAgICB0ID4+Pj0gMjtcbiAgfVxuICBpZiAoKHQgJiAweDEpID09PSAwKVxuICAgIHIrKztcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG5CTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoKCkge1xuICB2YXIgaGkgPSAwO1xuICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xufTtcblxuLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMoKSB7XG4gIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgdmFyIHIgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgIHIgKz0gYjtcbiAgICBpZiAoYiAhPT0gMjYpXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbkJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCgpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG59O1xuXG4vLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG5CTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICBpZiAodGhpcy5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG5cbiAgdmFyIHIgPSB0aGlzLmNsb25lKCk7XG4gIHIuc2lnbiA9ICF0aGlzLnNpZ247XG4gIHJldHVybiByO1xufTtcblxuXG4vLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvcihudW0pIHtcbiAgdGhpcy5zaWduID0gdGhpcy5zaWduIHx8IG51bS5zaWduO1xuXG4gIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpXG4gICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cblxuLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbkJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gIGVsc2VcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xufTtcblxuXG4vLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZChudW0pIHtcbiAgdGhpcy5zaWduID0gdGhpcy5zaWduICYmIG51bS5zaWduO1xuXG4gIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgdmFyIGI7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgYiA9IG51bTtcbiAgZWxzZVxuICAgIGIgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcblxuICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5cbi8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChudW0pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xufTtcblxuXG4vLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvcihudW0pIHtcbiAgdGhpcy5zaWduID0gdGhpcy5zaWduIHx8IG51bS5zaWduO1xuXG4gIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgdmFyIGE7XG4gIHZhciBiO1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgYSA9IHRoaXM7XG4gICAgYiA9IG51bTtcbiAgfSBlbHNlIHtcbiAgICBhID0gbnVtO1xuICAgIGIgPSB0aGlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcblxuICBpZiAodGhpcyAhPT0gYSlcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblxuICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5cbi8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihudW0pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xufTtcblxuXG4vLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG5CTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4oYml0LCB2YWwpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgd2hpbGUgKHRoaXMubGVuZ3RoIDw9IG9mZilcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblxuICBpZiAodmFsKVxuICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICBlbHNlXG4gICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5cbi8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZChudW0pIHtcbiAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICBpZiAodGhpcy5zaWduICYmICFudW0uc2lnbikge1xuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICAgIHZhciByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgdGhpcy5zaWduID0gIXRoaXMuc2lnbjtcbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gIH0gZWxzZSBpZiAoIXRoaXMuc2lnbiAmJiBudW0uc2lnbikge1xuICAgIG51bS5zaWduID0gZmFsc2U7XG4gICAgdmFyIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICBudW0uc2lnbiA9IHRydWU7XG4gICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gIH1cblxuICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gIHZhciBhO1xuICB2YXIgYjtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgIGEgPSB0aGlzO1xuICAgIGIgPSBudW07XG4gIH0gZWxzZSB7XG4gICAgYSA9IG51bTtcbiAgICBiID0gdGhpcztcbiAgfVxuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gYS53b3Jkc1tpXSArIGIud29yZHNbaV0gKyBjYXJyeTtcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICB9XG4gIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gYS53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgIHRoaXMubGVuZ3RoKys7XG4gIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBBZGQgYG51bWAgdG8gYHRoaXNgXG5CTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG51bSkge1xuICBpZiAobnVtLnNpZ24gJiYgIXRoaXMuc2lnbikge1xuICAgIG51bS5zaWduID0gZmFsc2U7XG4gICAgdmFyIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgbnVtLnNpZ24gPSB0cnVlO1xuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoIW51bS5zaWduICYmIHRoaXMuc2lnbikge1xuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICAgIHZhciByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgIHRoaXMuc2lnbiA9IHRydWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG4gIGVsc2VcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbn07XG5cbi8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIobnVtKSB7XG4gIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gIGlmIChudW0uc2lnbikge1xuICAgIG51bS5zaWduID0gZmFsc2U7XG4gICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICBudW0uc2lnbiA9IHRydWU7XG4gICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gIH0gZWxzZSBpZiAodGhpcy5zaWduKSB7XG4gICAgdGhpcy5zaWduID0gZmFsc2U7XG4gICAgdGhpcy5pYWRkKG51bSk7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBhID4gYlxuICB2YXIgYTtcbiAgdmFyIGI7XG4gIGlmIChjbXAgPiAwKSB7XG4gICAgYSA9IHRoaXM7XG4gICAgYiA9IG51bTtcbiAgfSBlbHNlIHtcbiAgICBhID0gbnVtO1xuICAgIGIgPSB0aGlzO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSBhLndvcmRzW2ldIC0gYi53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgfVxuICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgciA9IGEud29yZHNbaV0gKyBjYXJyeTtcbiAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gIH1cblxuICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcylcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgaWYgKGEgIT09IHRoaXMpXG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbkJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIobnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xufTtcblxuLypcbi8vIE5PVEU6IFRoaXMgY291bGQgYmUgcG90ZW50aW9uYWxseSB1c2VkIHRvIGdlbmVyYXRlIGxvb3AtbGVzcyBtdWx0aXBsaWNhdGlvbnNcbmZ1bmN0aW9uIF9nZW5Db21iTXVsVG8oYWxlbiwgYmxlbikge1xuICB2YXIgbGVuID0gYWxlbiArIGJsZW4gLSAxO1xuICB2YXIgc3JjID0gW1xuICAgICd2YXIgYSA9IHRoaXMud29yZHMsIGIgPSBudW0ud29yZHMsIG8gPSBvdXQud29yZHMsIGMgPSAwLCB3LCAnICtcbiAgICAgICAgJ21hc2sgPSAweDNmZmZmZmYsIHNoaWZ0ID0gMHg0MDAwMDAwOycsXG4gICAgJ291dC5sZW5ndGggPSAnICsgbGVuICsgJzsnXG4gIF07XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICB2YXIgbWluSiA9IE1hdGgubWF4KDAsIGsgLSBhbGVuICsgMSk7XG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBibGVuIC0gMSk7XG5cbiAgICBmb3IgKHZhciBqID0gbWluSjsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICB2YXIgbXVsID0gJ2FbJyArIGkgKyAnXSAqIGJbJyArIGogKyAnXSc7XG5cbiAgICAgIGlmIChqID09PSBtaW5KKSB7XG4gICAgICAgIHNyYy5wdXNoKCd3ID0gJyArIG11bCArICcgKyBjOycpO1xuICAgICAgICBzcmMucHVzaCgnYyA9ICh3IC8gc2hpZnQpIHwgMDsnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5wdXNoKCd3ICs9ICcgKyBtdWwgKyAnOycpO1xuICAgICAgICBzcmMucHVzaCgnYyArPSAodyAvIHNoaWZ0KSB8IDA7Jyk7XG4gICAgICB9XG4gICAgICBzcmMucHVzaCgndyAmPSBtYXNrOycpO1xuICAgIH1cbiAgICBzcmMucHVzaCgnb1snICsgayArICddID0gdzsnKTtcbiAgfVxuICBzcmMucHVzaCgnaWYgKGMgIT09IDApIHsnLFxuICAgICAgICAgICAnICBvWycgKyBrICsgJ10gPSBjOycsXG4gICAgICAgICAgICcgIG91dC5sZW5ndGgrKzsnLFxuICAgICAgICAgICAnfScsXG4gICAgICAgICAgICdyZXR1cm4gb3V0OycpO1xuXG4gIHJldHVybiBzcmMuam9pbignXFxuJyk7XG59XG4qL1xuXG5CTi5wcm90b3R5cGUuX3NtYWxsTXVsVG8gPSBmdW5jdGlvbiBfc21hbGxNdWxUbyhudW0sIG91dCkge1xuICBvdXQuc2lnbiA9IG51bS5zaWduICE9PSB0aGlzLnNpZ247XG4gIG91dC5sZW5ndGggPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHRoaXMubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG4gICAgfVxuICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICB9IGVsc2Uge1xuICAgIG91dC5sZW5ndGgtLTtcbiAgfVxuXG4gIHJldHVybiBvdXQuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fYmlnTXVsVG8gPSBmdW5jdGlvbiBfYmlnTXVsVG8obnVtLCBvdXQpIHtcbiAgb3V0LnNpZ24gPSBudW0uc2lnbiAhPT0gdGhpcy5zaWduO1xuICBvdXQubGVuZ3RoID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBobmNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgaG5jYXJyeSA9IDA7XG4gICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSB0aGlzLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgIH1cbiAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICBuY2FycnkgPSBobmNhcnJ5O1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICB9IGVsc2Uge1xuICAgIG91dC5sZW5ndGgtLTtcbiAgfVxuXG4gIHJldHVybiBvdXQuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvKG51bSwgb3V0KSB7XG4gIHZhciByZXM7XG4gIGlmICh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGggPCA2MylcbiAgICByZXMgPSB0aGlzLl9zbWFsbE11bFRvKG51bSwgb3V0KTtcbiAgZWxzZVxuICAgIHJlcyA9IHRoaXMuX2JpZ011bFRvKG51bSwgb3V0KTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChudW0pIHtcbiAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbn07XG5cbi8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG5CTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwobnVtKSB7XG4gIGlmICh0aGlzLmNtcG4oMCkgPT09IDAgfHwgbnVtLmNtcG4oMCkgPT09IDApIHtcbiAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgdGxlbiA9IHRoaXMubGVuZ3RoO1xuICB2YXIgbmxlbiA9IG51bS5sZW5ndGg7XG5cbiAgdGhpcy5zaWduID0gbnVtLnNpZ24gIT09IHRoaXMuc2lnbjtcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9IDA7XG5cbiAgZm9yICh2YXIgayA9IHRoaXMubGVuZ3RoIC0gMjsgayA+PSAwOyBrLS0pIHtcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYGNhcnJ5YCxcbiAgICAvLyBub3RlIHRoYXQgY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgcndvcmQgPSAwO1xuICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbmxlbiAtIDEpO1xuICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gdGxlbiArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdO1xuICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICBsbyArPSByd29yZDtcbiAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgfVxuICAgIHRoaXMud29yZHNba10gPSByd29yZDtcbiAgICB0aGlzLndvcmRzW2sgKyAxXSArPSBjYXJyeTtcbiAgICBjYXJyeSA9IDA7XG4gIH1cblxuICAvLyBQcm9wYWdhdGUgb3ZlcmZsb3dzXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4obnVtKSB7XG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG5cbiAgLy8gQ2FycnlcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldICogbnVtO1xuICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgY2FycnkgPj49IDI2O1xuICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gIH1cblxuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG59O1xuXG4vLyBgdGhpc2AgKiBgdGhpc2BcbkJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIoKSB7XG4gIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbn07XG5cbi8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyKCkge1xuICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG59O1xuXG4vLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbihiaXRzKSB7XG4gIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgdmFyIHIgPSBiaXRzICUgMjY7XG4gIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuXG4gIGlmIChyICE9PSAwKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICB2YXIgYyA9ICh0aGlzLndvcmRzW2ldIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgfVxuICAgIGlmIChjYXJyeSkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH1cblxuICBpZiAocyAhPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgdGhpcy5sZW5ndGggKz0gcztcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG4vLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4vLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG5CTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybihiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gIHZhciBoO1xuICBpZiAoaGludClcbiAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgZWxzZVxuICAgIGggPSAwO1xuXG4gIHZhciByID0gYml0cyAlIDI2O1xuICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgaCAtPSBzO1xuICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICBpZiAobWFza2VkV29yZHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKylcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICB9XG5cbiAgaWYgKHMgPT09IDApIHtcbiAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfVxuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldO1xuICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gIH1cblxuICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKVxuICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfVxuXG4gIHRoaXMuc3RyaXAoKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFNoaWZ0LWxlZnRcbkJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbihiaXRzKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG59O1xuXG4vLyBTaGlmdC1yaWdodFxuQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbn07XG5cbi8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG5CTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0bihiaXQpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgcmV0dXJuICEhKHcgJiBxKTtcbn07XG5cbi8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG5CTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuKGJpdHMpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgYXNzZXJ0KCF0aGlzLnNpZ24sICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICBpZiAociAhPT0gMClcbiAgICBzKys7XG4gIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gIGlmIChyICE9PSAwKSB7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG5CTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbihiaXRzKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xufTtcblxuLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbkJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuKG51bSkge1xuICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICBpZiAobnVtIDwgMClcbiAgICByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICBpZiAodGhpcy5zaWduKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCBudW0pIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSB0aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5zaWduID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4obnVtKSB7XG4gIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gIC8vIENhcnJ5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpXG4gICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgZWxzZVxuICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgfVxuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbkJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuKG51bSkge1xuICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICBpZiAobnVtIDwgMClcbiAgICByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICBpZiAodGhpcy5zaWduKSB7XG4gICAgdGhpcy5zaWduID0gZmFsc2U7XG4gICAgdGhpcy5pYWRkbihudW0pO1xuICAgIHRoaXMuc2lnbiA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAvLyBDYXJyeVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbihudW0pIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMoKSB7XG4gIHRoaXMuc2lnbiA9IGZhbHNlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicygpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsKG51bSwgbXVsLCBzaGlmdCkge1xuICAvLyBCaWdnZXIgc3RvcmFnZSBpcyBuZWVkZWRcbiAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLndvcmRzLmxlbmd0aCA8IGxlbikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgdFtpXSA9IHRoaXMud29yZHNbaV07XG4gICAgdGhpcy53b3JkcyA9IHQ7XG4gIH0gZWxzZSB7XG4gICAgaSA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgLy8gWmVyb2lmeSByZXN0XG4gIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGxlbik7XG4gIGZvciAoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gMDtcblxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpICsgc2hpZnRdICsgY2Fycnk7XG4gICAgdmFyIHJpZ2h0ID0gbnVtLndvcmRzW2ldICogbXVsO1xuICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gIH1cbiAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaSArIHNoaWZ0XSArIGNhcnJ5O1xuICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICB9XG5cbiAgaWYgKGNhcnJ5ID09PSAwKVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSAtdGhpcy53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgfVxuICB0aGlzLnNpZ24gPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdihudW0sIG1vZGUpIHtcbiAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICB2YXIgYiA9IG51bTtcblxuICAvLyBOb3JtYWxpemVcbiAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXTtcbiAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gIGlmIChzaGlmdCAhPT0gMCkge1xuICAgIGIgPSBiLnNobG4oc2hpZnQpO1xuICAgIGEuaXNobG4oc2hpZnQpO1xuICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICB2YXIgcTtcblxuICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKVxuICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gIH1cblxuICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gIGlmICghZGlmZi5zaWduKSB7XG4gICAgYSA9IGRpZmY7XG4gICAgaWYgKHEpXG4gICAgICBxLndvcmRzW21dID0gMTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICB2YXIgcWogPSBhLndvcmRzW2IubGVuZ3RoICsgal0gKiAweDQwMDAwMDAgKyBhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdO1xuXG4gICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAvLyAoMHg3ZmZmZmZmKVxuICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgd2hpbGUgKGEuc2lnbikge1xuICAgICAgcWotLTtcbiAgICAgIGEuc2lnbiA9IGZhbHNlO1xuICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICBpZiAoYS5jbXBuKDApICE9PSAwKVxuICAgICAgICBhLnNpZ24gPSAhYS5zaWduO1xuICAgIH1cbiAgICBpZiAocSlcbiAgICAgIHEud29yZHNbal0gPSBxajtcbiAgfVxuICBpZiAocSlcbiAgICBxLnN0cmlwKCk7XG4gIGEuc3RyaXAoKTtcblxuICAvLyBEZW5vcm1hbGl6ZVxuICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApXG4gICAgYS5pc2hybihzaGlmdCk7XG4gIHJldHVybiB7IGRpdjogcSA/IHEgOiBudWxsLCBtb2Q6IGEgfTtcbn07XG5cbkJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QobnVtLCBtb2RlKSB7XG4gIGFzc2VydChudW0uY21wbigwKSAhPT0gMCk7XG5cbiAgaWYgKHRoaXMuc2lnbiAmJiAhbnVtLnNpZ24pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcbiAgICB2YXIgZGl2O1xuICAgIHZhciBtb2Q7XG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKVxuICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicpXG4gICAgICBtb2QgPSByZXMubW9kLmNtcG4oMCkgPT09IDAgPyByZXMubW9kIDogbnVtLnN1YihyZXMubW9kKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBkaXYsXG4gICAgICBtb2Q6IG1vZFxuICAgIH07XG4gIH0gZWxzZSBpZiAoIXRoaXMuc2lnbiAmJiBudW0uc2lnbikge1xuICAgIHZhciByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuICAgIHZhciBkaXY7XG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKVxuICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICByZXR1cm4geyBkaXY6IGRpdiwgbW9kOiByZXMubW9kIH07XG4gIH0gZWxzZSBpZiAodGhpcy5zaWduICYmIG51bS5zaWduKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG4gIH1cblxuICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMClcbiAgICByZXR1cm4geyBkaXY6IG5ldyBCTigwKSwgbW9kOiB0aGlzIH07XG5cbiAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAobW9kZSA9PT0gJ2RpdicpXG4gICAgICByZXR1cm4geyBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLCBtb2Q6IG51bGwgfTtcbiAgICBlbHNlIGlmIChtb2RlID09PSAnbW9kJylcbiAgICAgIHJldHVybiB7IGRpdjogbnVsbCwgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbn07XG5cbi8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbkJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYobnVtKSB7XG4gIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnKS5kaXY7XG59O1xuXG4vLyBGaW5kIGB0aGlzYCAlIGBudW1gXG5CTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kKG51bSkge1xuICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJykubW9kO1xufTtcblxuLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbkJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kKG51bSkge1xuICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gIGlmIChkbS5tb2QuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gZG0uZGl2O1xuXG4gIHZhciBtb2QgPSBkbS5kaXYuc2lnbiA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgdmFyIGhhbGYgPSBudW0uc2hybigxKTtcbiAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAvLyBSb3VuZCBkb3duXG4gIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMClcbiAgICByZXR1cm4gZG0uZGl2O1xuXG4gIC8vIFJvdW5kIHVwXG4gIHJldHVybiBkbS5kaXYuc2lnbiA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbn07XG5cbkJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbihudW0pIHtcbiAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICB2YXIgYWNjID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgYWNjID0gKHAgKiBhY2MgKyB0aGlzLndvcmRzW2ldKSAlIG51bTtcblxuICByZXR1cm4gYWNjO1xufTtcblxuLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG5CTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2bihudW0pIHtcbiAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgY2FycnkgPSB3ICUgbnVtO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2bihudW0pIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkKHApIHtcbiAgYXNzZXJ0KCFwLnNpZ24pO1xuICBhc3NlcnQocC5jbXBuKDApICE9PSAwKTtcblxuICB2YXIgeCA9IHRoaXM7XG4gIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gIGlmICh4LnNpZ24pXG4gICAgeCA9IHgubW9kKHApO1xuICBlbHNlXG4gICAgeCA9IHguY2xvbmUoKTtcblxuICAvLyBBICogeCArIEIgKiB5ID0geFxuICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gIHZhciBnID0gMDtcblxuICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgeC5pc2hybigxKTtcbiAgICB5LmlzaHJuKDEpO1xuICAgICsrZztcbiAgfVxuXG4gIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gIHdoaWxlICh4LmNtcG4oMCkgIT09IDApIHtcbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSkge1xuICAgICAgeC5pc2hybigxKTtcbiAgICAgIGlmIChBLmlzRXZlbigpICYmIEIuaXNFdmVuKCkpIHtcbiAgICAgICAgQS5pc2hybigxKTtcbiAgICAgICAgQi5pc2hybigxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEEuaWFkZCh5cCkuaXNocm4oMSk7XG4gICAgICAgIEIuaXN1Yih4cCkuaXNocm4oMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHkuaXNFdmVuKCkpIHtcbiAgICAgIHkuaXNocm4oMSk7XG4gICAgICBpZiAoQy5pc0V2ZW4oKSAmJiBELmlzRXZlbigpKSB7XG4gICAgICAgIEMuaXNocm4oMSk7XG4gICAgICAgIEQuaXNocm4oMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDLmlhZGQoeXApLmlzaHJuKDEpO1xuICAgICAgICBELmlzdWIoeHApLmlzaHJuKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICB4LmlzdWIoeSk7XG4gICAgICBBLmlzdWIoQyk7XG4gICAgICBCLmlzdWIoRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkuaXN1Yih4KTtcbiAgICAgIEMuaXN1YihBKTtcbiAgICAgIEQuaXN1YihCKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGE6IEMsXG4gICAgYjogRCxcbiAgICBnY2Q6IHkuaXNobG4oZylcbiAgfTtcbn07XG5cbi8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4vLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcChwKSB7XG4gIGFzc2VydCghcC5zaWduKTtcbiAgYXNzZXJ0KHAuY21wbigwKSAhPT0gMCk7XG5cbiAgdmFyIGEgPSB0aGlzO1xuICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICBpZiAoYS5zaWduKVxuICAgIGEgPSBhLm1vZChwKTtcbiAgZWxzZVxuICAgIGEgPSBhLmNsb25lKCk7XG5cbiAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgYS5pc2hybigxKTtcbiAgICAgIGlmICh4MS5pc0V2ZW4oKSlcbiAgICAgICAgeDEuaXNocm4oMSk7XG4gICAgICBlbHNlXG4gICAgICAgIHgxLmlhZGQoZGVsdGEpLmlzaHJuKDEpO1xuICAgIH1cbiAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgYi5pc2hybigxKTtcbiAgICAgIGlmICh4Mi5pc0V2ZW4oKSlcbiAgICAgICAgeDIuaXNocm4oMSk7XG4gICAgICBlbHNlXG4gICAgICAgIHgyLmlhZGQoZGVsdGEpLmlzaHJuKDEpO1xuICAgIH1cbiAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgYS5pc3ViKGIpO1xuICAgICAgeDEuaXN1Yih4Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGIuaXN1YihhKTtcbiAgICAgIHgyLmlzdWIoeDEpO1xuICAgIH1cbiAgfVxuICBpZiAoYS5jbXBuKDEpID09PSAwKVxuICAgIHJldHVybiB4MTtcbiAgZWxzZVxuICAgIHJldHVybiB4Mjtcbn07XG5cbkJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QobnVtKSB7XG4gIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpO1xuICBpZiAobnVtLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblxuICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgYS5zaWduID0gZmFsc2U7XG4gIGIuc2lnbiA9IGZhbHNlO1xuXG4gIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgIGEuaXNocm4oMSk7XG4gICAgYi5pc2hybigxKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB3aGlsZSAoYS5pc0V2ZW4oKSlcbiAgICAgIGEuaXNocm4oMSk7XG4gICAgd2hpbGUgKGIuaXNFdmVuKCkpXG4gICAgICBiLmlzaHJuKDEpO1xuXG4gICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICBpZiAociA8IDApIHtcbiAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgdmFyIHQgPSBhO1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdDtcbiAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhLmlzdWIoYik7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBiLmlzaGxuKHNoaWZ0KTtcbn07XG5cbi8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtKG51bSkge1xuICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS5tb2QobnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XG4gIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xufTtcblxuQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xufTtcblxuLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4obnVtKSB7XG4gIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xufTtcblxuLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24oYml0KSB7XG4gIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gIHZhciByID0gYml0ICUgMjY7XG4gIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gIHZhciBxID0gMSA8PCByO1xuXG4gIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoOyBpIDwgcyArIDE7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICB0aGlzLmxlbmd0aCA9IHMgKyAxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgdmFyIGNhcnJ5ID0gcTtcbiAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgIHcgKz0gY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgfVxuICBpZiAoY2FycnkgIT09IDApIHtcbiAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbihudW0pIHtcbiAgdmFyIHNpZ24gPSBudW0gPCAwO1xuICBpZiAoc2lnbilcbiAgICBudW0gPSAtbnVtO1xuXG4gIGlmICh0aGlzLnNpZ24gJiYgIXNpZ24pXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5zaWduICYmIHNpZ24pXG4gICAgcmV0dXJuIDE7XG5cbiAgbnVtICY9IDB4M2ZmZmZmZjtcbiAgdGhpcy5zdHJpcCgpO1xuXG4gIHZhciByZXM7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICByZXMgPSAxO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXTtcbiAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgfVxuICBpZiAodGhpcy5zaWduKVxuICAgIHJlcyA9IC1yZXM7XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4vLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbi8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbi8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbkJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAobnVtKSB7XG4gIGlmICh0aGlzLnNpZ24gJiYgIW51bS5zaWduKVxuICAgIHJldHVybiAtMTtcbiAgZWxzZSBpZiAoIXRoaXMuc2lnbiAmJiBudW0uc2lnbilcbiAgICByZXR1cm4gMTtcblxuICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gIGlmICh0aGlzLnNpZ24pXG4gICAgcmV0dXJuIC1yZXM7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gVW5zaWduZWQgY29tcGFyaXNvblxuQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wKG51bSkge1xuICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gMTtcbiAgZWxzZSBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKVxuICAgIHJldHVybiAtMTtcblxuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IHRoaXMud29yZHNbaV07XG4gICAgdmFyIGIgPSBudW0ud29yZHNbaV07XG5cbiAgICBpZiAoYSA9PT0gYilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChhIDwgYilcbiAgICAgIHJlcyA9IC0xO1xuICAgIGVsc2UgaWYgKGEgPiBiKVxuICAgICAgcmVzID0gMTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuLy9cbi8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4vLyBvbiB0aGUgYG1gIGl0c2VsZi5cbi8vXG5CTi5yZWQgPSBmdW5jdGlvbiByZWQobnVtKSB7XG4gIHJldHVybiBuZXcgUmVkKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZChjdHgpIHtcbiAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgYXNzZXJ0KCF0aGlzLnNpZ24sICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbn07XG5cbkJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCgpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG59O1xuXG5CTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkKGN0eCkge1xuICB0aGlzLnJlZCA9IGN0eDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZChjdHgpIHtcbiAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZChudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobChudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bChudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxcigpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxcigpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xufTtcblxuLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG5CTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQoKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSgpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xufTtcblxuLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZygpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG59O1xuXG4vLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxudmFyIHByaW1lcyA9IHtcbiAgazI1NjogbnVsbCxcbiAgcDIyNDogbnVsbCxcbiAgcDE5MjogbnVsbCxcbiAgcDI1NTE5OiBudWxsXG59O1xuXG4vLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbmZ1bmN0aW9uIE1QcmltZShuYW1lLCBwKSB7XG4gIC8vIFAgPSAyIF4gTiAtIEtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICB0aGlzLmsgPSBuZXcgQk4oMSkuaXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbn1cblxuTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCgpIHtcbiAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICByZXR1cm4gdG1wO1xufTtcblxuTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZShudW0pIHtcbiAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gIHZhciByID0gbnVtO1xuICB2YXIgcmxlbjtcblxuICBkbyB7XG4gICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIHIud29yZHNbMF0gPSAwO1xuICAgIHIubGVuZ3RoID0gMTtcbiAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgci5pc3ViKHRoaXMucCk7XG4gIH0gZWxzZSB7XG4gICAgci5zdHJpcCgpO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG5NUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoaW5wdXQsIG91dCkge1xuICBpbnB1dC5pc2hybih0aGlzLm4sIDAsIG91dCk7XG59O1xuXG5NUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xufTtcblxuZnVuY3Rpb24gSzI1NigpIHtcbiAgTVByaW1lLmNhbGwoXG4gICAgdGhpcyxcbiAgICAnazI1NicsXG4gICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG59XG5pbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG5LMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KGlucHV0LCBvdXRwdXQpIHtcbiAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgZm9yICh2YXIgaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgcHJldiA9IG5leHQ7XG4gIH1cbiAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXYgPj4+IDIyO1xuICBpbnB1dC5sZW5ndGggLT0gOTtcbn07XG5cbksyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgbnVtLmxlbmd0aCArPSAyO1xuXG4gIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gIHZhciBoaTtcbiAgdmFyIGxvID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG51bS53b3Jkc1tpXTtcbiAgICBoaSA9IHcgKiAweDQwO1xuICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICBoaSArPSAobG8gLyAweDQwMDAwMDApIHwgMDtcbiAgICBsbyAmPSAweDNmZmZmZmY7XG5cbiAgICBudW0ud29yZHNbaV0gPSBsbztcblxuICAgIGxvID0gaGk7XG4gIH1cblxuICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICBudW0ubGVuZ3RoLS07XG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApXG4gICAgICBudW0ubGVuZ3RoLS07XG4gIH1cbiAgcmV0dXJuIG51bTtcbn07XG5cbmZ1bmN0aW9uIFAyMjQoKSB7XG4gIE1QcmltZS5jYWxsKFxuICAgIHRoaXMsXG4gICAgJ3AyMjQnLFxuICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xufVxuaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuZnVuY3Rpb24gUDE5MigpIHtcbiAgTVByaW1lLmNhbGwoXG4gICAgdGhpcyxcbiAgICAncDE5MicsXG4gICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG59XG5pbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG5mdW5jdGlvbiBQMjU1MTkoKSB7XG4gIC8vIDIgXiAyNTUgLSAxOVxuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICcyNTUxOScsXG4gICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbn1cbmluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLKG51bSkge1xuICAvLyBLID0gMHgxM1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBoaSA9IG51bS53b3Jkc1tpXSAqIDB4MTMgKyBjYXJyeTtcbiAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICBoaSA+Pj49IDI2O1xuXG4gICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgY2FycnkgPSBoaTtcbiAgfVxuICBpZiAoY2FycnkgIT09IDApXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgcmV0dXJuIG51bTtcbn07XG5cbi8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUobmFtZSkge1xuICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICBpZiAocHJpbWVzW25hbWVdKVxuICAgIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgdmFyIHByaW1lO1xuICBpZiAobmFtZSA9PT0gJ2syNTYnKVxuICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKVxuICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKVxuICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpXG4gICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICByZXR1cm4gcHJpbWU7XG59O1xuXG4vL1xuLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4vL1xuZnVuY3Rpb24gUmVkKG0pIHtcbiAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm0gPSBtO1xuICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICB9XG59XG5cblJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MShhKSB7XG4gIGFzc2VydCghYS5zaWduLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xufTtcblxuUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyKGEsIGIpIHtcbiAgYXNzZXJ0KCFhLnNpZ24gJiYgIWIuc2lnbiwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZChhKSB7XG4gIGlmICh0aGlzLnByaW1lKVxuICAgIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICByZXR1cm4gYS5tb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhhKSB7XG4gIHZhciByID0gYS5jbG9uZSgpO1xuICByLnNpZ24gPSAhci5zaWduO1xuICByZXR1cm4gci5pYWRkKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYSwgYikge1xuICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gIHZhciByZXMgPSBhLmFkZChiKTtcbiAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5SZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICBpZiAocmVzLmNtcG4oMCkgPCAwKVxuICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YihhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgaWYgKHJlcy5jbXBuKDApIDwgMClcbiAgICByZXMuaWFkZCh0aGlzLm0pO1xuICByZXR1cm4gcmVzO1xufTtcblxuUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwoYSwgbnVtKSB7XG4gIHRoaXMuX3ZlcmlmeTEoYSk7XG4gIHJldHVybiB0aGlzLmltb2QoYS5zaGxuKG51bSkpO1xufTtcblxuUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbn07XG5cblJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyKGEpIHtcbiAgcmV0dXJuIHRoaXMuaW11bChhLCBhKTtcbn07XG5cblJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyKGEpIHtcbiAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xufTtcblxuUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydChhKSB7XG4gIGlmIChhLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIGEuY2xvbmUoKTtcblxuICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAvLyBGYXN0IGNhc2VcbiAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLmlzaHJuKDIpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcG93KTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgLy9cbiAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgdmFyIHMgPSAwO1xuICB3aGlsZSAocS5jbXBuKDApICE9PSAwICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICBzKys7XG4gICAgcS5pc2hybigxKTtcbiAgfVxuICBhc3NlcnQocS5jbXBuKDApICE9PSAwKTtcblxuICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pc2hybigxKTtcbiAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcbiAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMClcbiAgICB6LnJlZElBZGQobk9uZSk7XG5cbiAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXNocm4oMSkpO1xuICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICB2YXIgbSA9IHM7XG4gIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgdmFyIHRtcCA9IHQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKVxuICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgIGFzc2VydChpIDwgbSk7XG4gICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICByID0gci5yZWRNdWwoYik7XG4gICAgYyA9IGIucmVkU3FyKCk7XG4gICAgdCA9IHQucmVkTXVsKGMpO1xuICAgIG0gPSBpO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG5SZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtKGEpIHtcbiAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gIGlmIChpbnYuc2lnbikge1xuICAgIGludi5zaWduID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgfVxufTtcblxuUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3coYSwgbnVtKSB7XG4gIHZhciB3ID0gW107XG5cbiAgaWYgKG51bS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgdmFyIHEgPSBudW0uY2xvbmUoKTtcblxuICB3aGlsZSAocS5jbXBuKDApICE9PSAwKSB7XG4gICAgdy5wdXNoKHEuYW5kbG4oMSkpO1xuICAgIHEuaXNocm4oMSk7XG4gIH1cblxuICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gIHZhciByZXMgPSBhO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHRoaXMuc3FyKHJlcykpXG4gICAgaWYgKHdbaV0gIT09IDApXG4gICAgICBicmVhaztcblxuICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBxID0gdGhpcy5zcXIocmVzKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSB0aGlzLnNxcihxKSkge1xuICAgICAgaWYgKHdbaV0gPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCBxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8obnVtKSB7XG4gIHZhciByID0gbnVtLm1vZCh0aGlzLm0pO1xuICBpZiAociA9PT0gbnVtKVxuICAgIHJldHVybiByLmNsb25lKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gcjtcbn07XG5cblJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbShudW0pIHtcbiAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICByZXMucmVkID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vXG4vLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbi8vXG5cbkJOLm1vbnQgPSBmdW5jdGlvbiBtb250KG51bSkge1xuICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbn07XG5cbmZ1bmN0aW9uIE1vbnQobSkge1xuICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKVxuICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgdGhpcy5yID0gbmV3IEJOKDEpLmlzaGxuKHRoaXMuc2hpZnQpO1xuICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gIHRoaXMubWludi5zaWduID0gdHJ1ZTtcbiAgdGhpcy5taW52ID0gdGhpcy5taW52Lm1vZCh0aGlzLnIpO1xufVxuaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvKG51bSkge1xuICByZXR1cm4gdGhpcy5pbW9kKG51bS5zaGxuKHRoaXMuc2hpZnQpKTtcbn07XG5cbk1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20obnVtKSB7XG4gIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gIHIucmVkID0gbnVsbDtcbiAgcmV0dXJuIHI7XG59O1xuXG5Nb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gIGlmIChhLmNtcG4oMCkgPT09IDAgfHwgYi5jbXBuKDApID09PSAwKSB7XG4gICAgYS53b3Jkc1swXSA9IDA7XG4gICAgYS5sZW5ndGggPSAxO1xuICAgIHJldHVybiBhO1xuICB9XG5cbiAgdmFyIHQgPSBhLmltdWwoYik7XG4gIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gIHZhciB1ID0gdC5pc3ViKGMpLmlzaHJuKHRoaXMuc2hpZnQpO1xuICB2YXIgcmVzID0gdTtcbiAgaWYgKHUuY21wKHRoaXMubSkgPj0gMClcbiAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgZWxzZSBpZiAodS5jbXBuKDApIDwgMClcbiAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblxuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cbk1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChhLCBiKSB7XG4gIGlmIChhLmNtcG4oMCkgPT09IDAgfHwgYi5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gIHZhciB0ID0gYS5tdWwoYik7XG4gIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gIHZhciB1ID0gdC5pc3ViKGMpLmlzaHJuKHRoaXMuc2hpZnQpO1xuICB2YXIgcmVzID0gdTtcbiAgaWYgKHUuY21wKHRoaXMubSkgPj0gMClcbiAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgZWxzZSBpZiAodS5jbXBuKDApIDwgMClcbiAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblxuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cbk1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtKGEpIHtcbiAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG5leHBvcnRzLnRhZ0NsYXNzID0ge1xuICAwOiAndW5pdmVyc2FsJyxcbiAgMTogJ2FwcGxpY2F0aW9uJyxcbiAgMjogJ2NvbnRleHQnLFxuICAzOiAncHJpdmF0ZSdcbn07XG5leHBvcnRzLnRhZ0NsYXNzQnlOYW1lID0gY29uc3RhbnRzLl9yZXZlcnNlKGV4cG9ydHMudGFnQ2xhc3MpO1xuXG5leHBvcnRzLnRhZyA9IHtcbiAgMHgwMDogJ2VuZCcsXG4gIDB4MDE6ICdib29sJyxcbiAgMHgwMjogJ2ludCcsXG4gIDB4MDM6ICdiaXRzdHInLFxuICAweDA0OiAnb2N0c3RyJyxcbiAgMHgwNTogJ251bGxfJyxcbiAgMHgwNjogJ29iamlkJyxcbiAgMHgwNzogJ29iakRlc2MnLFxuICAweDA4OiAnZXh0ZXJuYWwnLFxuICAweDA5OiAncmVhbCcsXG4gIDB4MGE6ICdlbnVtJyxcbiAgMHgwYjogJ2VtYmVkJyxcbiAgMHgwYzogJ3V0ZjhzdHInLFxuICAweDBkOiAncmVsYXRpdmVPaWQnLFxuICAweDEwOiAnc2VxJyxcbiAgMHgxMTogJ3NldCcsXG4gIDB4MTI6ICdudW1zdHInLFxuICAweDEzOiAncHJpbnRzdHInLFxuICAweDE0OiAndDYxc3RyJyxcbiAgMHgxNTogJ3ZpZGVvc3RyJyxcbiAgMHgxNjogJ2lhNXN0cicsXG4gIDB4MTc6ICd1dGN0aW1lJyxcbiAgMHgxODogJ2dlbnRpbWUnLFxuICAweDE5OiAnZ3JhcGhzdHInLFxuICAweDFhOiAnaXNvNjQ2c3RyJyxcbiAgMHgxYjogJ2dlbnN0cicsXG4gIDB4MWM6ICd1bmlzdHInLFxuICAweDFkOiAnY2hhcnN0cicsXG4gIDB4MWU6ICdibXBzdHInXG59O1xuZXhwb3J0cy50YWdCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWcpO1xuIiwidmFyIGNvbnN0YW50cyA9IGV4cG9ydHM7XG5cbi8vIEhlbHBlclxuY29uc3RhbnRzLl9yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShtYXApIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAvLyBDb252ZXJ0IGtleSB0byBpbnRlZ2VyIGlmIGl0IGlzIHN0cmluZ2lmaWVkXG4gICAgaWYgKChrZXkgfCAwKSA9PSBrZXkpXG4gICAgICBrZXkgPSBrZXkgfCAwO1xuXG4gICAgdmFyIHZhbHVlID0gbWFwW2tleV07XG4gICAgcmVzW3ZhbHVlXSA9IGtleTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0YW50cy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xudmFyIGJpZ251bSA9IGFzbjEuYmlnbnVtO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRGVjb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkRlY29kZXI7XG5cbkRFUkRlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIGlmICghKGRhdGEgaW5zdGFuY2VvZiBiYXNlLkRlY29kZXJCdWZmZXIpKVxuICAgIGRhdGEgPSBuZXcgYmFzZS5EZWNvZGVyQnVmZmVyKGRhdGEsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLnRyZWUuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9wZWVrVGFnID0gZnVuY3Rpb24gcGVla1RhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIGlmIChidWZmZXIuaXNFbXB0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgc3RhdGUgPSBidWZmZXIuc2F2ZSgpO1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsICdGYWlsZWQgdG8gcGVlayB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuXG4gIHJldHVybiBkZWNvZGVkVGFnLnRhZyA9PT0gdGFnIHx8IGRlY29kZWRUYWcudGFnU3RyID09PSB0YWcgfHwgYW55O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRhZyA9IGZ1bmN0aW9uIGRlY29kZVRhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBkZWNvZGUgdGFnIG9mIFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZFRhZy5wcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgbGVuZ3RoIG9mIFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEZhaWx1cmVcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICBpZiAoIWFueSAmJlxuICAgICAgZGVjb2RlZFRhZy50YWcgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnICE9PSB0YWcpIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdGYWlsZWQgdG8gbWF0Y2ggdGFnOiBcIicgKyB0YWcgKyAnXCInKTtcbiAgfVxuXG4gIGlmIChkZWNvZGVkVGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBJbmRlZmluaXRlIGxlbmd0aC4uLiBmaW5kIEVORCB0YWdcbiAgdmFyIHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcbiAgdmFyIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChcbiAgICAgIGJ1ZmZlcixcbiAgICAgICdGYWlsZWQgdG8gc2tpcCBpbmRlZmluaXRlIGxlbmd0aCBib2R5OiBcIicgKyB0aGlzLnRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGxlbiA9IGJ1ZmZlci5vZmZzZXQgLSBzdGF0ZS5vZmZzZXQ7XG4gIGJ1ZmZlci5yZXN0b3JlKHN0YXRlKTtcbiAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwVW50aWxFbmQgPSBmdW5jdGlvbiBza2lwVW50aWxFbmQoYnVmZmVyLCBmYWlsKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih0YWcpKVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlciwgdGFnLnByaW1pdGl2ZSwgZmFpbCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgICByZXR1cm4gbGVuO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgICByZXMgPSBidWZmZXIuc2tpcChsZW4pXG4gICAgZWxzZVxuICAgICAgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCk7XG5cbiAgICAvLyBGYWlsdXJlXG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgaWYgKHRhZy50YWdTdHIgPT09ICdlbmQnKVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVMaXN0ID0gZnVuY3Rpb24gZGVjb2RlTGlzdChidWZmZXIsIHRhZywgZGVjb2Rlcikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBwb3NzaWJsZUVuZCA9IHRoaXMuX3BlZWtUYWcoYnVmZmVyLCAnZW5kJyk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHBvc3NpYmxlRW5kKSlcbiAgICAgIHJldHVybiBwb3NzaWJsZUVuZDtcblxuICAgIHZhciByZXMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIsICdkZXInKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSAmJiBwb3NzaWJsZUVuZClcbiAgICAgIGJyZWFrO1xuICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVTdHIgPSBmdW5jdGlvbiBkZWNvZGVTdHIoYnVmZmVyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ29jdHN0cicpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICB2YXIgdW51c2VkID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih1bnVzZWQpKVxuICAgICAgcmV0dXJuIHVudXNlZDtcblxuICAgIHJldHVybiB7IHVudXNlZDogdW51c2VkLCBkYXRhOiBidWZmZXIucmF3KCkgfTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpYTVzdHInIHx8IHRhZyA9PT0gJ3V0ZjhzdHInKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArICcgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU9iamlkID0gZnVuY3Rpb24gZGVjb2RlT2JqaWQoYnVmZmVyLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICB2YXIgaWRlbnQgPSAwO1xuICB3aGlsZSAoIWJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICB2YXIgc3ViaWRlbnQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWRlbnQgPDw9IDc7XG4gICAgaWRlbnQgfD0gc3ViaWRlbnQgJiAweDdmO1xuICAgIGlmICgoc3ViaWRlbnQgJiAweDgwKSA9PT0gMCkge1xuICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG4gICAgICBpZGVudCA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChzdWJpZGVudCAmIDB4ODApXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudCk7XG5cbiAgdmFyIGZpcnN0ID0gKGlkZW50aWZpZXJzWzBdIC8gNDApIHwgMDtcbiAgdmFyIHNlY29uZCA9IGlkZW50aWZpZXJzWzBdICUgNDA7XG5cbiAgaWYgKHJlbGF0aXZlKVxuICAgIHJlc3VsdCA9IGlkZW50aWZpZXJzO1xuICBlbHNlXG4gICAgcmVzdWx0ID0gW2ZpcnN0LCBzZWNvbmRdLmNvbmNhdChpZGVudGlmaWVycy5zbGljZSgxKSk7XG5cbiAgaWYgKHZhbHVlcylcbiAgICByZXN1bHQgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJyAnKV07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUaW1lID0gZnVuY3Rpb24gZGVjb2RlVGltZShidWZmZXIsIHRhZykge1xuICB2YXIgc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDQpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMiwgMTQpIHwgMDtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDIpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDIsIDQpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgaWYgKHllYXIgPCA3MClcbiAgICAgIHllYXIgPSAyMDAwICsgeWVhcjtcbiAgICBlbHNlXG4gICAgICB5ZWFyID0gMTkwMCArIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0RlY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiBEYXRlLlVUQyh5ZWFyLCBtb24gLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVOdWxsID0gZnVuY3Rpb24gZGVjb2RlTnVsbChidWZmZXIpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlQm9vbCA9IGZ1bmN0aW9uIGRlY29kZUJvb2woYnVmZmVyKSB7XG4gIHZhciByZXMgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgIHJldHVybiByZXM7XG4gIGVsc2VcbiAgICByZXR1cm4gcmVzICE9PSAwO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChidWZmZXIsIHZhbHVlcykge1xuICAvLyBCaWdpbnQsIHJldHVybiBhcyBpdCBpcyAoYXNzdW1lIGJpZyBlbmRpYW4pXG4gIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gIHZhciByZXMgPSBuZXcgYmlnbnVtKHJhdyk7XG5cbiAgaWYgKHZhbHVlcylcbiAgICByZXMgPSB2YWx1ZXNbcmVzLnRvU3RyaW5nKDEwKV0gfHwgcmVzO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXREZWNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuLy8gVXRpbGl0eSBtZXRob2RzXG5cbmZ1bmN0aW9uIGRlckRlY29kZVRhZyhidWYsIGZhaWwpIHtcbiAgdmFyIHRhZyA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcih0YWcpKVxuICAgIHJldHVybiB0YWc7XG5cbiAgdmFyIGNscyA9IGRlci50YWdDbGFzc1t0YWcgPj4gNl07XG4gIHZhciBwcmltaXRpdmUgPSAodGFnICYgMHgyMCkgPT09IDA7XG5cbiAgLy8gTXVsdGktb2N0ZXQgdGFnIC0gbG9hZFxuICBpZiAoKHRhZyAmIDB4MWYpID09PSAweDFmKSB7XG4gICAgdmFyIG9jdCA9IHRhZztcbiAgICB0YWcgPSAwO1xuICAgIHdoaWxlICgob2N0ICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICAgIG9jdCA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgICBpZiAoYnVmLmlzRXJyb3Iob2N0KSlcbiAgICAgICAgcmV0dXJuIG9jdDtcblxuICAgICAgdGFnIDw8PSA3O1xuICAgICAgdGFnIHw9IG9jdCAmIDB4N2Y7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhZyAmPSAweDFmO1xuICB9XG4gIHZhciB0YWdTdHIgPSBkZXIudGFnW3RhZ107XG5cbiAgcmV0dXJuIHtcbiAgICBjbHM6IGNscyxcbiAgICBwcmltaXRpdmU6IHByaW1pdGl2ZSxcbiAgICB0YWc6IHRhZyxcbiAgICB0YWdTdHI6IHRhZ1N0clxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXJEZWNvZGVMZW4oYnVmLCBwcmltaXRpdmUsIGZhaWwpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gIGlmIChidWYuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgLy8gSW5kZWZpbml0ZSBmb3JtXG4gIGlmICghcHJpbWl0aXZlICYmIGxlbiA9PT0gMHg4MClcbiAgICByZXR1cm4gbnVsbDtcblxuICAvLyBEZWZpbml0ZSBmb3JtXG4gIGlmICgobGVuICYgMHg4MCkgPT09IDApIHtcbiAgICAvLyBTaG9ydCBmb3JtXG4gICAgcmV0dXJuIGxlbjtcbiAgfVxuXG4gIC8vIExvbmcgZm9ybVxuICB2YXIgbnVtID0gbGVuICYgMHg3ZjtcbiAgaWYgKG51bSA+PSA0KVxuICAgIHJldHVybiBidWYuZXJyb3IoJ2xlbmd0aCBvY3RlY3QgaXMgdG9vIGxvbmcnKTtcblxuICBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgbGVuIDw8PSA4O1xuICAgIHZhciBqID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICBpZiAoYnVmLmlzRXJyb3IoaikpXG4gICAgICByZXR1cm4gajtcbiAgICBsZW4gfD0gajtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59XG4iLCJ2YXIgZGVjb2RlcnMgPSBleHBvcnRzO1xuXG5kZWNvZGVycy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuZGVjb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vYXNuMScpO1xudmFyIERFUkRlY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1EZWNvZGVyKGVudGl0eSkge1xuICBERVJEZWNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1EZWNvZGVyLCBERVJEZWNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRGVjb2RlcjtcblxuUEVNRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cbiAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciByZSA9IC9eLS0tLS0oQkVHSU58RU5EKSAoW14tXSspLS0tLS0kLztcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKHJlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0JFR0lOJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0VORCcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xuXG4gIHZhciBiYXNlNjQgPSBsaW5lcy5zbGljZShzdGFydCArIDEsIGVuZCkuam9pbignJyk7XG4gIC8vIFJlbW92ZSBleGNlc3NpdmUgc3ltYm9sc1xuICBiYXNlNjQucmVwbGFjZSgvW15hLXowLTlcXCtcXC89XSsvZ2ksICcnKTtcblxuICB2YXIgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgaW5wdXQsIG9wdGlvbnMpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJFbmNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRW5jb2RlcjtcblxuREVSRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIHJldHVybiB0aGlzLnRyZWUuX2VuY29kZShkYXRhLCByZXBvcnRlcikuam9pbigpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uIGVuY29kZUNvbXBvc2l0ZSh0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50KSB7XG4gIHZhciBlbmNvZGVkVGFnID0gZW5jb2RlVGFnKHRhZywgcHJpbWl0aXZlLCBjbHMsIHRoaXMucmVwb3J0ZXIpO1xuXG4gIC8vIFNob3J0IGZvcm1cbiAgaWYgKGNvbnRlbnQubGVuZ3RoIDwgMHg4MCkge1xuICAgIHZhciBoZWFkZXIgPSBuZXcgQnVmZmVyKDIpO1xuICAgIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gICAgaGVhZGVyWzFdID0gY29udGVudC5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWyBoZWFkZXIsIGNvbnRlbnQgXSk7XG4gIH1cblxuICAvLyBMb25nIGZvcm1cbiAgLy8gQ291bnQgb2N0ZXRzIHJlcXVpcmVkIHRvIHN0b3JlIGxlbmd0aFxuICB2YXIgbGVuT2N0ZXRzID0gMTtcbiAgZm9yICh2YXIgaSA9IGNvbnRlbnQubGVuZ3RoOyBpID49IDB4MTAwOyBpID4+PSA4KVxuICAgIGxlbk9jdGV0cysrO1xuXG4gIHZhciBoZWFkZXIgPSBuZXcgQnVmZmVyKDEgKyAxICsgbGVuT2N0ZXRzKTtcbiAgaGVhZGVyWzBdID0gZW5jb2RlZFRhZztcbiAgaGVhZGVyWzFdID0gMHg4MCB8IGxlbk9jdGV0cztcblxuICBmb3IgKHZhciBpID0gMSArIGxlbk9jdGV0cywgaiA9IGNvbnRlbnQubGVuZ3RoOyBqID4gMDsgaS0tLCBqID4+PSA4KVxuICAgIGhlYWRlcltpXSA9IGogJiAweGZmO1xuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZVN0ciA9IGZ1bmN0aW9uIGVuY29kZVN0cihzdHIsIHRhZykge1xuICBpZiAodGFnID09PSAnb2N0c3RyJylcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICBlbHNlIGlmICh0YWcgPT09ICdiaXRzdHInKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgc3RyLnVudXNlZCB8IDAsIHN0ci5kYXRhIF0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdpYTVzdHInIHx8IHRhZyA9PT0gJ3V0ZjhzdHInKVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgdW5zdXBwb3J0ZWQnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKG51bS5zaWduID09PSBmYWxzZSAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiIsInZhciBlbmNvZGVycyA9IGV4cG9ydHM7XG5cbmVuY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5lbmNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGFzbjEgPSByZXF1aXJlKCcuLi9hc24xJyk7XG52YXIgREVSRW5jb2RlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5cbmZ1bmN0aW9uIFBFTUVuY29kZXIoZW50aXR5KSB7XG4gIERFUkVuY29kZXIuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICB0aGlzLmVuYyA9ICdwZW0nO1xufTtcbmluaGVyaXRzKFBFTUVuY29kZXIsIERFUkVuY29kZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBQRU1FbmNvZGVyO1xuXG5QRU1FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYnVmID0gREVSRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlLmNhbGwodGhpcywgZGF0YSk7XG5cbiAgdmFyIHAgPSBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB2YXIgb3V0ID0gWyAnLS0tLS1CRUdJTiAnICsgb3B0aW9ucy5sYWJlbCArICctLS0tLScgXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSA2NClcbiAgICBvdXQucHVzaChwLnNsaWNlKGksIGkgKyA2NCkpO1xuICBvdXQucHVzaCgnLS0tLS1FTkQgJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nKTtcbiAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcbn07XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGFzbjEgPSByZXF1aXJlKCcuL2FzbjEvYXNuMScpO1xudmFyIEJOID0gcmVxdWlyZSgnLi9hc24xL2JpZ251bS9ibicpO1xuXG52YXIgRUNQcml2YXRlS2V5QVNOID0gYXNuMS5kZWZpbmUoJ0VDUHJpdmF0ZUtleScsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VxKCkub2JqKFxuICAgICAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgICAgICB0aGlzLmtleSgncHJpdmF0ZUtleScpLm9jdHN0cigpLFxuICAgICAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLmV4cGxpY2l0KDApLm9iamlkKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLmV4cGxpY2l0KDEpLmJpdHN0cigpLm9wdGlvbmFsKClcbiAgICApXG59KVxuXG52YXIgU3ViamVjdFB1YmxpY0tleUluZm9BU04gPSBhc24xLmRlZmluZSgnU3ViamVjdFB1YmxpY0tleUluZm8nLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNlcSgpLm9iaihcbiAgICAgICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnNlcSgpLm9iaihcbiAgICAgICAgICAgIHRoaXMua2V5KFwiaWRcIikub2JqaWQoKSxcbiAgICAgICAgICAgIHRoaXMua2V5KFwiY3VydmVcIikub2JqaWQoKVxuICAgICAgICApLFxuICAgICAgICB0aGlzLmtleSgncHViJykuYml0c3RyKClcbiAgICApXG59KVxuXG52YXIgY3VydmVzID0ge1xuICAgIHNlY3AyNTZrMToge1xuICAgICAgICBjdXJ2ZVBhcmFtZXRlcnM6IFsxLCAzLCAxMzIsIDAsIDEwXSxcbiAgICAgICAgcHJpdmF0ZVBFTU9wdGlvbnM6IHtsYWJlbDogJ0VDIFBSSVZBVEUgS0VZJ30sXG4gICAgICAgIHB1YmxpY1BFTU9wdGlvbnM6IHtsYWJlbDogJ1BVQkxJQyBLRVknfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBLZXlFbmNvZGVyKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFzc2VydChjdXJ2ZXMuaGFzT3duUHJvcGVydHkob3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucyA9IGN1cnZlc1tvcHRpb25zXVxuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuYWxnb3JpdGhtSUQgPSBbMSwgMiwgODQwLCAxMDA0NSwgMiwgMV1cbn1cblxuS2V5RW5jb2Rlci5FQ1ByaXZhdGVLZXlBU04gPSBFQ1ByaXZhdGVLZXlBU047XG5LZXlFbmNvZGVyLlN1YmplY3RQdWJsaWNLZXlJbmZvQVNOID0gU3ViamVjdFB1YmxpY0tleUluZm9BU047XG5cbktleUVuY29kZXIucHJvdG90eXBlLnByaXZhdGVLZXlPYmplY3QgPSBmdW5jdGlvbihyYXdQcml2YXRlS2V5LCByYXdQdWJsaWNLZXkpIHtcbiAgICB2YXIgcHJpdmF0ZUtleU9iamVjdCA9IHtcbiAgICAgICAgdmVyc2lvbjogbmV3IEJOKDEpLFxuICAgICAgICBwcml2YXRlS2V5OiBuZXcgQnVmZmVyKHJhd1ByaXZhdGVLZXksICdoZXgnKSxcbiAgICAgICAgcGFyYW1ldGVyczogdGhpcy5vcHRpb25zLmN1cnZlUGFyYW1ldGVycyxcbiAgICAgICAgcGVtT3B0aW9uczoge2xhYmVsOlwiRUMgUFJJVkFURSBLRVlcIn1cbiAgICB9O1xuXG4gICAgaWYgKHJhd1B1YmxpY0tleSkge1xuICAgICAgICBwcml2YXRlS2V5T2JqZWN0LnB1YmxpY0tleSA9IHtcbiAgICAgICAgICAgIHVudXNlZDogMCxcbiAgICAgICAgICAgIGRhdGE6IG5ldyBCdWZmZXIocmF3UHVibGljS2V5LCAnaGV4JylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcml2YXRlS2V5T2JqZWN0XG59O1xuXG5LZXlFbmNvZGVyLnByb3RvdHlwZS5wdWJsaWNLZXlPYmplY3QgPSBmdW5jdGlvbihyYXdQdWJsaWNLZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbGdvcml0aG06IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmFsZ29yaXRobUlELFxuICAgICAgICAgICAgY3VydmU6IHRoaXMub3B0aW9ucy5jdXJ2ZVBhcmFtZXRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgcHViOiB7XG4gICAgICAgICAgICB1bnVzZWQ6IDAsXG4gICAgICAgICAgICBkYXRhOiBuZXcgQnVmZmVyKHJhd1B1YmxpY0tleSwgJ2hleCcpXG4gICAgICAgIH0sXG4gICAgICAgIHBlbU9wdGlvbnM6IHsgbGFiZWwgOlwiUFVCTElDIEtFWVwifVxuICAgIH1cbn1cblxuS2V5RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlUHJpdmF0ZSA9IGZ1bmN0aW9uKHByaXZhdGVLZXksIG9yaWdpbmFsRm9ybWF0LCBkZXN0aW5hdGlvbkZvcm1hdCkge1xuICAgIHZhciBwcml2YXRlS2V5T2JqZWN0XG5cbiAgICAvKiBQYXJzZSB0aGUgaW5jb21pbmcgcHJpdmF0ZSBrZXkgYW5kIGNvbnZlcnQgaXQgdG8gYSBwcml2YXRlIGtleSBvYmplY3QgKi9cbiAgICBpZiAob3JpZ2luYWxGb3JtYXQgPT09ICdyYXcnKSB7XG4gICAgICAgIGlmICghdHlwZW9mIHByaXZhdGVLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyAncHJpdmF0ZSBrZXkgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJpdmF0ZUtleU9iamVjdCA9IHRoaXMub3B0aW9ucy5jdXJ2ZS5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5LCAnaGV4JyksXG4gICAgICAgICAgICByYXdQdWJsaWNLZXkgPSBwcml2YXRlS2V5T2JqZWN0LmdldFB1YmxpYygnaGV4JylcbiAgICAgICAgcHJpdmF0ZUtleU9iamVjdCA9IHRoaXMucHJpdmF0ZUtleU9iamVjdChwcml2YXRlS2V5LCByYXdQdWJsaWNLZXkpXG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbEZvcm1hdCA9PT0gJ2RlcicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcml2YXRlS2V5ID09PSAnYnVmZmVyJykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcml2YXRlS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcHJpdmF0ZUtleSA9IG5ldyBCdWZmZXIocHJpdmF0ZUtleSwgJ2hleCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAncHJpdmF0ZSBrZXkgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZydcbiAgICAgICAgfVxuICAgICAgICBwcml2YXRlS2V5T2JqZWN0ID0gRUNQcml2YXRlS2V5QVNOLmRlY29kZShwcml2YXRlS2V5LCAnZGVyJylcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRm9ybWF0ID09PSAncGVtJykge1xuICAgICAgICBpZiAoIXR5cGVvZiBwcml2YXRlS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgJ3ByaXZhdGUga2V5IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgICAgcHJpdmF0ZUtleU9iamVjdCA9IEVDUHJpdmF0ZUtleUFTTi5kZWNvZGUocHJpdmF0ZUtleSwgJ3BlbScsIHRoaXMub3B0aW9ucy5wcml2YXRlUEVNT3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAnaW52YWxpZCBwcml2YXRlIGtleSBmb3JtYXQnXG4gICAgfVxuXG4gICAgLyogRXhwb3J0IHRoZSBwcml2YXRlIGtleSBvYmplY3QgdG8gdGhlIGRlc2lyZWQgZm9ybWF0ICovXG4gICAgaWYgKGRlc3RpbmF0aW9uRm9ybWF0ID09PSAncmF3Jykge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZUtleU9iamVjdC5wcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKVxuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb25Gb3JtYXQgPT09ICdkZXInKSB7XG4gICAgICAgIHJldHVybiBFQ1ByaXZhdGVLZXlBU04uZW5jb2RlKHByaXZhdGVLZXlPYmplY3QsICdkZXInKS50b1N0cmluZygnaGV4JylcbiAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uRm9ybWF0ID09PSAncGVtJykge1xuICAgICAgICByZXR1cm4gRUNQcml2YXRlS2V5QVNOLmVuY29kZShwcml2YXRlS2V5T2JqZWN0LCAncGVtJywgdGhpcy5vcHRpb25zLnByaXZhdGVQRU1PcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdpbnZhbGlkIGRlc3RpbmF0aW9uIGZvcm1hdCBmb3IgcHJpdmF0ZSBrZXknXG4gICAgfVxufVxuXG5LZXlFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGVQdWJsaWMgPSBmdW5jdGlvbihwdWJsaWNLZXksIG9yaWdpbmFsRm9ybWF0LCBkZXN0aW5hdGlvbkZvcm1hdCkge1xuICAgIHZhciBwdWJsaWNLZXlPYmplY3RcblxuICAgIC8qIFBhcnNlIHRoZSBpbmNvbWluZyBwdWJsaWMga2V5IGFuZCBjb252ZXJ0IGl0IHRvIGEgcHVibGljIGtleSBvYmplY3QgKi9cbiAgICBpZiAob3JpZ2luYWxGb3JtYXQgPT09ICdyYXcnKSB7XG4gICAgICAgIGlmICghdHlwZW9mIHB1YmxpY0tleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93ICdwdWJsaWMga2V5IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgICAgcHVibGljS2V5T2JqZWN0ID0gdGhpcy5wdWJsaWNLZXlPYmplY3QocHVibGljS2V5KVxuICAgIH0gZWxzZSBpZiAob3JpZ2luYWxGb3JtYXQgPT09ICdkZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHVibGljS2V5ID09PSAnYnVmZmVyJykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwdWJsaWNLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwdWJsaWNLZXkgPSBuZXcgQnVmZmVyKHB1YmxpY0tleSwgJ2hleCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAncHVibGljIGtleSBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nJ1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY0tleU9iamVjdCA9IFN1YmplY3RQdWJsaWNLZXlJbmZvQVNOLmRlY29kZShwdWJsaWNLZXksICdkZXInKVxuICAgIH0gZWxzZSBpZiAob3JpZ2luYWxGb3JtYXQgPT09ICdwZW0nKSB7XG4gICAgICAgIGlmICghdHlwZW9mIHB1YmxpY0tleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93ICdwdWJsaWMga2V5IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgICAgcHVibGljS2V5T2JqZWN0ID0gU3ViamVjdFB1YmxpY0tleUluZm9BU04uZGVjb2RlKHB1YmxpY0tleSwgJ3BlbScsIHRoaXMub3B0aW9ucy5wdWJsaWNQRU1PcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdpbnZhbGlkIHB1YmxpYyBrZXkgZm9ybWF0J1xuICAgIH1cblxuICAgIC8qIEV4cG9ydCB0aGUgcHJpdmF0ZSBrZXkgb2JqZWN0IHRvIHRoZSBkZXNpcmVkIGZvcm1hdCAqL1xuICAgIGlmIChkZXN0aW5hdGlvbkZvcm1hdCA9PT0gJ3JhdycpIHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleU9iamVjdC5wdWIuZGF0YS50b1N0cmluZygnaGV4JylcbiAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uRm9ybWF0ID09PSAnZGVyJykge1xuICAgICAgICByZXR1cm4gU3ViamVjdFB1YmxpY0tleUluZm9BU04uZW5jb2RlKHB1YmxpY0tleU9iamVjdCwgJ2RlcicpLnRvU3RyaW5nKCdoZXgnKVxuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb25Gb3JtYXQgPT09ICdwZW0nKSB7XG4gICAgICAgIHJldHVybiBTdWJqZWN0UHVibGljS2V5SW5mb0FTTi5lbmNvZGUocHVibGljS2V5T2JqZWN0LCAncGVtJywgdGhpcy5vcHRpb25zLnB1YmxpY1BFTU9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgZGVzdGluYXRpb24gZm9ybWF0IGZvciBwdWJsaWMga2V5J1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFbmNvZGVyOyIsImNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHlhemwgPSByZXF1aXJlKFwieWF6bFwiKTtcbmNvbnN0IHlhdXpsID0gcmVxdWlyZShcInlhdXpsXCIpO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKFwiLi91dGlscy9EdXBsZXhTdHJlYW1cIik7XG5jb25zdCBQYXNzVGhyb3VnaFN0cmVhbSA9IHJlcXVpcmUoXCIuL3V0aWxzL1Bhc3NUaHJvdWdoU3RyZWFtXCIpO1xuY29uc3QgaXNTdHJlYW0gPSByZXF1aXJlKFwiLi91dGlscy9pc1N0cmVhbVwiKTtcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmNvbnN0IGNvdW50RmlsZXMgPSByZXF1aXJlKCcuL3V0aWxzL2NvdW50RmlsZXMnKTtcblxuZnVuY3Rpb24gUHNrQXJjaGl2ZXIoKSB7XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgdGhpcy5vbiA9IGV2ZW50Lm9uO1xuICAgIHRoaXMub2ZmID0gZXZlbnQub2ZmO1xuICAgIHRoaXMuZW1pdCA9IGV2ZW50LmVtaXQ7XG5cbiAgICB0aGlzLnppcFN0cmVhbSA9IGZ1bmN0aW9uIChpbnB1dFBhdGgsIG91dHB1dCwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGV4dCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHppcEZpbGUgPSBuZXcgeWF6bC5aaXBGaWxlKCk7XG4gICAgICAgIGNvbnN0IHB0U3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKCk7XG5cbiAgICAgICAgY291bnRGaWxlcy5jb21wdXRlU2l6ZShpbnB1dFBhdGgsIChlcnIsIHRvdGFsU2l6ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX2FkZFRvQXJjaGl2ZVJlY3Vyc2l2ZWx5KHppcEZpbGUsIGlucHV0UGF0aCwgXCJcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgemlwRmlsZS5lbmQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoaW5wdXRQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdEZpbGVuYW1lID0gZmlsZW5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdEZpbGVuYW1lLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dCA9IFwiLlwiICsgc3BsaXRGaWxlbmFtZVtzcGxpdEZpbGVuYW1lLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBteVN0cmVhbSA9IHppcEZpbGUub3V0cHV0U3RyZWFtLnBpcGUocHRTdHJlYW0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVE9ETyByZXZpZXcgdGhpc1xuICAgICAgICAgICAgICAgICAqIEluIGJyb3dzZXIsIHBpcGluZyB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIGFuZCB0aGUgc3RhY2sgcXVldWUgaXMgbm90IGNhbGxlZC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBteVN0cmVhbS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc0xlbmd0aCA+IDMwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlTdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15U3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFByb2dyZXNzKHRvdGFsU2l6ZSwgdG90YWxMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG15U3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRQcm9ncmVzcyh0b3RhbFNpemUsIHRvdGFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRUb3RhbFNpemUodG90YWxTaXplKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJlYW0uaXNXcml0YWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG15U3RyZWFtLnBpcGUob3V0cHV0KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgZnMubWtkaXIob3V0cHV0LCB7cmVjdXJzaXZlOiB0cnVlfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25QYXRoID0gcGF0aC5qb2luKG91dHB1dCwgcGF0aC5iYXNlbmFtZShpbnB1dFBhdGgsIGV4dCkgKyBcIi56aXBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBteVN0cmVhbS5waXBlKGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRlc3RpbmF0aW9uUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gX19hZGRUb0FyY2hpdmVSZWN1cnNpdmVseSh6aXBGaWxlLCBpbnB1dFBhdGgsIHJvb3QgPSAnJywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdCB8fCAnJztcbiAgICAgICAgICAgICAgICBmcy5zdGF0KGlucHV0UGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6aXBGaWxlLmFkZEZpbGUoaW5wdXRQYXRoLCBwYXRoLmpvaW4ocm9vdCwgcGF0aC5iYXNlbmFtZShpbnB1dFBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMucmVhZGRpcihpbnB1dFBhdGgsIChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZl9sZW5ndGggPSBmaWxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZfYWRkX2luZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrU3RhdHVzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZl9sZW5ndGggPT09IGZfYWRkX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1N0YXR1cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wUGF0aCA9IHBhdGguam9pbihpbnB1dFBhdGgsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19hZGRUb0FyY2hpdmVSZWN1cnNpdmVseSh6aXBGaWxlLCB0ZW1wUGF0aCwgcGF0aC5qb2luKHJvb3QsIHBhdGguYmFzZW5hbWUoaW5wdXRQYXRoKSksIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmX2FkZF9pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy51bnppcFN0cmVhbSA9IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0UGF0aCwgY2FsbGJhY2spIHtcblxuICAgICAgICBsZXQgc2l6ZSA9IDA7XG5cbiAgICAgICAgZnMuc3RhdChpbnB1dCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IHN0YXRzLnNpemU7XG5cblxuICAgICAgICAgICAgeWF1emwub3BlbihpbnB1dCwge2xhenlFbnRyaWVzOiB0cnVlfSwgKGVyciwgemlwRmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWVzID0gW107XG4gICAgICAgICAgICAgICAgemlwRmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgICAgICAgICB6aXBGaWxlLm9uY2UoXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbWl0UHJvZ3Jlc3ModG90YWxTaXplLCB0b3RhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlTmFtZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHppcEZpbGUub24oXCJlbnRyeVwiLCAoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lLmVuZHNXaXRoKHBhdGguc2VwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgemlwRmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZXIgPSBwYXRoLmRpcm5hbWUoZW50cnkuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMubWtkaXIocGF0aC5qb2luKG91dHB1dFBhdGgsIGZvbGRlciksIHtyZWN1cnNpdmU6IHRydWV9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgemlwRmlsZS5vcGVuUmVhZFN0cmVhbShlbnRyeSwgKGVyciwgcmVhZFN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUT0RPIHJldmlldyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEluIGJyb3dzZXIsIHBpcGluZyB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIGFuZCB0aGUgc3RhY2sgcXVldWUgaXMgbm90IGNhbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0xlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc0xlbmd0aCA+IDMwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRQcm9ncmVzcyh0b3RhbFNpemUsIHRvdGFsTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemlwRmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB0U3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IHBhdGguam9pbihvdXRwdXRQYXRoLCBlbnRyeS5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZXIgPSBwYXRoLmRpcm5hbWUoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3RyZWFtID0gcmVhZFN0cmVhbS5waXBlKHB0U3RyZWFtKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy5ta2Rpcihmb2xkZXIsIHtyZWN1cnNpdmU6IHRydWV9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgKz0gcHRTdHJlYW0uZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTdHJlYW0ucGlwZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICB0aGlzLnppcEluTWVtb3J5ID0gZnVuY3Rpb24gKGlucHV0T2JqLCBkZXB0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgemlwRmlsZSA9IG5ldyB5YXpsLlppcEZpbGUoKTtcbiAgICAgICAgY29uc3QgZHMgPSBuZXcgRHVwbGV4U3RyZWFtKCk7XG4gICAgICAgIHppcFJlY3Vyc2l2ZWx5KHppcEZpbGUsIGlucHV0T2JqLCBcIlwiLCBkZXB0aCwgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgemlwRmlsZS5lbmQoKTtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgICAgICBkcy5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgY2h1bmtdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB6aXBGaWxlLm91dHB1dFN0cmVhbS5waXBlKGRzKS5vbihcImZpbmlzaFwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH07XG5cbiAgICB0aGlzLnVuemlwSW5NZW1vcnkgPSBmdW5jdGlvbiAoaW5wdXRaaXAsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gdW56aXBJbnB1dCh6aXBGaWxlKSB7XG4gICAgICAgICAgICB6aXBGaWxlLnJlYWRFbnRyeSgpO1xuICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgICB6aXBGaWxlLm9uY2UoXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG9iaik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgemlwRmlsZS5vbihcImVudHJ5XCIsIChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgIHppcEZpbGUub3BlblJlYWRTdHJlYW0oZW50cnksIChlcnIsIHJlYWRTdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHMgPSBuZXcgRHVwbGV4U3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6aXBGaWxlLnJlYWRFbnRyeSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZHMub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNodW5rLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucGlwZShkcykub24oXCJmaW5pc2hcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRFbnRyeSA9IGVudHJ5LmZpbGVOYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzcGxpdEVudHJ5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUHJvcHNSZWN1cnNpdmVseShvYmosIHNwbGl0RW50cnksIHR5cGUsIG5ldyBCdWZmZXIoc3RyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dFppcCkpIHtcbiAgICAgICAgICAgIHlhdXpsLmZyb21CdWZmZXIoaW5wdXRaaXAsIHtsYXp5RW50cmllczogdHJ1ZX0sIChlcnIsIHppcEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bnppcElucHV0KHppcEZpbGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgYSBidWZmZXJcIikpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gemlwUmVjdXJzaXZlbHkoemlwRmlsZSwgb2JqLCByb290LCBkZXB0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICB6aXBGaWxlLmFkZEJ1ZmZlcihuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KG9iaikpLCByb290ICsgXCIvc3RyaW5naWZ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB6aXBGaWxlLmFkZEJ1ZmZlcihCdWZmZXIuYWxsb2MoMCksIHJvb3QgKyBcIi91bmRlZmluZWRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKG5ldyBCdWZmZXIob2JqLnRvU3RyaW5nKCkpLCByb290ICsgXCIvbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB6aXBGaWxlLmFkZEJ1ZmZlcihuZXcgQnVmZmVyKG9iaiksIHJvb3QgKyBcIi9zdHJpbmdcIilcbiAgICAgICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKEJ1ZmZlci5hbGxvYygwKSwgcm9vdCArIFwiL251bGxcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKG9iaiwgcm9vdCArIFwiL2J1ZmZlclwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmVhbS5pc1JlYWRhYmxlKG9iaikpIHtcbiAgICAgICAgICAgIHppcEZpbGUuYWRkUmVhZFN0cmVhbShvYmosIHJvb3QgKyBcIi9zdHJlYW1cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHppcEZpbGUuYWRkQnVmZmVyKEJ1ZmZlci5hbGxvYygwKSwgcm9vdCArIFwiL2FycmF5XCIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgemlwUmVjdXJzaXZlbHkoemlwRmlsZSwgb2JqW2ldLCByb290ICsgXCIvYXJyYXkvXCIgKyBpLCBkZXB0aCwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB6aXBGaWxlLmFkZEJ1ZmZlcihCdWZmZXIuYWxsb2MoMCksIHJvb3QgKyBcIi9vYmplY3RcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWRPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhvYmopLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkT2JqW2VuY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9iaiA9IGVuY29kZWRPYmo7XG4gICAgICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbnRyeU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUgPSByb290ICsgXCIvXCIgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgemlwUmVjdXJzaXZlbHkoemlwRmlsZSwgb2JqW2tleV0sIGVudHJ5TmFtZSwgZGVwdGggLSAxLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgcmVhY2ggdGhpcycpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFByb3BzUmVjdXJzaXZlbHkob2JqLCBzcGxpdE5hbWUsIHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHNwbGl0TmFtZS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IGRlY29kZVVSSUNvbXBvbmVudChzcGxpdE5hbWUuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgIGlmIChzcGxpdE5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBwYXJzZUludChkYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IGJ1ZmZlclRvU3RyZWFtKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmdpZnknOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gSlNPTi5wYXJzZShkYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciByZWFjaCB0aGlzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXROYW1lWzBdID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGxpdE5hbWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkUHJvcHNSZWN1cnNpdmVseShvYmpbcHJvcF0sIHNwbGl0TmFtZSwgdHlwZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkZFByb3BzUmVjdXJzaXZlbHkob2JqW3Byb3BdLCBzcGxpdE5hbWUsIHR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVmZmVyVG9TdHJlYW0oYnVmZmVyKSB7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGUoKTtcbiAgICAgICAgc3RyZWFtLnB1c2goYnVmZmVyKTtcbiAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFByb2dyZXNzKHRvdGFsLCBwcm9jZXNzZWQpIHtcblxuXG4gICAgICAgIGlmIChwcm9jZXNzZWQgPiB0b3RhbCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkID0gdG90YWw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9ICgxMDAgKiBwcm9jZXNzZWQpIC8gdG90YWw7XG4gICAgICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFRvdGFsU2l6ZSh0b3RhbCkge1xuICAgICAgICBzZWxmLmVtaXQoJ3RvdGFsJywgdG90YWwpO1xuICAgIH1cblxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHNrQXJjaGl2ZXI7IiwiY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBEdXBsZXggPSBzdHJlYW0uRHVwbGV4O1xuXG5mdW5jdGlvbiBEdXBsZXhTdHJlYW0ob3B0aW9ucykge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4U3RyZWFtKSkge1xuXHRcdHJldHVybiBuZXcgRHVwbGV4U3RyZWFtKG9wdGlvbnMpO1xuXHR9XG5cdER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxudXRpbC5pbmhlcml0cyhEdXBsZXhTdHJlYW0sIER1cGxleCk7XG5cbkR1cGxleFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmMsIGNiKSB7XG5cdHRoaXMucHVzaChjaHVuayk7XG5cdGNiKCk7XG59O1xuXG5cbkR1cGxleFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleFN0cmVhbTsiLCJjb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IFBhc3NUaHJvdWdoID0gc3RyZWFtLlBhc3NUaHJvdWdoO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaFN0cmVhbShvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoU3RyZWFtKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKG9wdGlvbnMpO1xuICAgIH1cbiAgICBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgbGV0IHNpemUgPSAwO1xuXG4gICAgdGhpcy5hZGRUb1NpemUgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIHNpemUgKz0gYW1vdW50O1xuICAgIH07XG5cbiAgICB0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbn1cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaFN0cmVhbSwgUGFzc1Rocm91Z2gpO1xuXG5QYXNzVGhyb3VnaFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmMsIGNiKSB7XG4gICAgdGhpcy5hZGRUb1NpemUoY2h1bmsubGVuZ3RoKTtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xuICAgIGNiKCk7XG59O1xuXG5cblBhc3NUaHJvdWdoU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2hTdHJlYW07IiwiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHlhdXpsID0gcmVxdWlyZSgneWF1emwnKTtcblxuZnVuY3Rpb24gY291bnRGaWxlcyhpbnB1dFBhdGgsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcblxuICAgIGZzLnN0YXQoaW5wdXRQYXRoLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHVuZGVmaW5lZCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmcy5yZWFkZGlyKGlucHV0UGF0aCwgKGVyciwgZmlsZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0b3RhbCA9IGZpbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IGZpbGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHRvdGFsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHVuZGVmaW5lZCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgZnMuc3RhdChwYXRoLmpvaW4oaW5wdXRQYXRoLCBmaWxlKSwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS10b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50RmlsZXMocGF0aC5qb2luKGlucHV0UGF0aCwgZmlsZSksIChlcnIsIGZpbGVzTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSBmaWxlc051bWJlcjtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS10b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvdW50WmlwRW50cmllcyhpbnB1dFBhdGgsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHByb2Nlc3NlZCA9IDA7XG5cbiAgICB5YXV6bC5vcGVuKGlucHV0UGF0aCwge2xhenlFbnRyaWVzOiB0cnVlfSwgKGVyciwgemlwRmlsZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHppcEZpbGUucmVhZEVudHJ5KCk7XG4gICAgICAgIHppcEZpbGUub25jZShcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBwcm9jZXNzZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6aXBGaWxlLm9uKFwiZW50cnlcIiwgKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICArK3Byb2Nlc3NlZDtcblxuICAgICAgICAgICAgemlwRmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTaXplKGlucHV0UGF0aCwgY2FsbGJhY2spIHtcbiAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICBmcy5zdGF0KGlucHV0UGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh1bmRlZmluZWQsIHN0YXRzLnNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnMucmVhZGRpcihpbnB1dFBhdGgsIChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgbGV0IGNvdW50ID0gZmlsZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICBmcy5zdGF0KHBhdGguam9pbihpbnB1dFBhdGgsIGZpbGUpLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2l6ZShwYXRoLmpvaW4oaW5wdXRQYXRoLCBmaWxlKSwgKGVyciwgZmlsZXNTaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gZmlsZXNTaXplO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB0b3RhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gc3RhdHMuc2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHRvdGFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb3VudEZpbGVzLFxuICAgIGNvdW50WmlwRW50cmllcyxcbiAgICBjb21wdXRlU2l6ZVxufTtcbiIsImNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG5jb25zdCBhbGdvcml0aG0gPSAnYWVzLTI1Ni1nY20nO1xuXG5cbmNvbnN0IGl0ZXJhdGlvbnNfbnVtYmVyID0gMTAwMDtcblxuZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlcikge1xuXHRyZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKVxuXHRcdC5yZXBsYWNlKC9cXCsvZywgJycpXG5cdFx0LnJlcGxhY2UoL1xcLy9nLCAnJylcblx0XHQucmVwbGFjZSgvPSskLywgJycpO1xufVxuXG5mdW5jdGlvbiBkZWxldGVSZWN1cnNpdmVseShpbnB1dFBhdGgsIGNhbGxiYWNrKSB7XG5cblx0ZnMuc3RhdChpbnB1dFBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXRzKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0Y2FsbGJhY2soZXJyLCBzdGF0cyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuXHRcdFx0ZnMudW5saW5rKGlucHV0UGF0aCwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyLCBudWxsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG5cdFx0XHRmcy5yZWFkZGlyKGlucHV0UGF0aCwgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVyciwgbnVsbCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGZfbGVuZ3RoID0gZmlsZXMubGVuZ3RoO1xuXHRcdFx0XHRsZXQgZl9kZWxldGVfaW5kZXggPSAwO1xuXG5cdFx0XHRcdGNvbnN0IGNoZWNrU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChmX2xlbmd0aCA9PT0gZl9kZWxldGVfaW5kZXgpIHtcblx0XHRcdFx0XHRcdGZzLnJtZGlyKGlucHV0UGF0aCwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXJyLCBudWxsKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIWNoZWNrU3RhdHVzKCkpIHtcblx0XHRcdFx0XHRmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZW1wUGF0aCA9IHBhdGguam9pbihpbnB1dFBhdGgsIGZpbGUpO1xuXHRcdFx0XHRcdFx0ZGVsZXRlUmVjdXJzaXZlbHkodGVtcFBhdGgsIGZ1bmN0aW9uIHJlbW92ZVJlY3Vyc2l2ZUNCKGVyciwgc3RhdHVzKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zl9kZWxldGVfaW5kZXgrKztcblx0XHRcdFx0XHRcdFx0XHRjaGVja1N0YXR1cygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGVyciwgbnVsbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufVxuXG5cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBza0hhc2goZGF0YSkge1xuXHRjb25zdCBwc2tIYXNoID0gbmV3IFBza0hhc2goKTtcblx0cHNrSGFzaC51cGRhdGUoZGF0YSk7XG5cdHJldHVybiBwc2tIYXNoLmRpZ2VzdCgpO1xufVxuXG5mdW5jdGlvbiBQc2tIYXNoKCkge1xuXHRjb25zdCBzaGE1MTIgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhNTEyJyk7XG5cdGNvbnN0IHNoYTI1NiA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcblxuXHRmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuXHRcdHNoYTUxMi51cGRhdGUoZGF0YSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkaWdlc3QoKSB7XG5cdFx0c2hhMjU2LnVwZGF0ZShzaGE1MTIuZGlnZXN0KCkpO1xuXHRcdHJldHVybiBzaGEyNTYuZGlnZXN0KCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHVwZGF0ZSxcblx0XHRkaWdlc3Rcblx0fVxufVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2FsdChpbnB1dERhdGEsIHNhbHRMZW4pIHtcblx0Y29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGE1MTInKTtcblx0aGFzaC51cGRhdGUoaW5wdXREYXRhKTtcblx0Y29uc3QgZGlnZXN0ID0gQnVmZmVyLmZyb20oaGFzaC5kaWdlc3QoJ2hleCcpLCAnYmluYXJ5Jyk7XG5cblx0cmV0dXJuIGRpZ2VzdC5zbGljZSgwLCBzYWx0TGVuKTtcbn1cblxuZnVuY3Rpb24gZW5jcnlwdChkYXRhLCBwYXNzd29yZCkge1xuXHRjb25zdCBrZXlTYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKTtcblx0Y29uc3Qga2V5ID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIGtleVNhbHQsIGl0ZXJhdGlvbnNfbnVtYmVyLCAzMiwgJ3NoYTUxMicpO1xuXG5cdGNvbnN0IGFhZFNhbHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xuXHRjb25zdCBhYWQgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgYWFkU2FsdCwgaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XG5cblx0Y29uc3Qgc2FsdCA9IEJ1ZmZlci5jb25jYXQoW2tleVNhbHQsIGFhZFNhbHRdKTtcblx0Y29uc3QgaXYgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9uc19udW1iZXIsIDEyLCAnc2hhNTEyJyk7XG5cblx0Y29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGFsZ29yaXRobSwga2V5LCBpdik7XG5cdGNpcGhlci5zZXRBQUQoYWFkKTtcblx0bGV0IGVuY3J5cHRlZFRleHQgPSBjaXBoZXIudXBkYXRlKGRhdGEsICdiaW5hcnknKTtcblx0Y29uc3QgZmluYWwgPSBCdWZmZXIuZnJvbShjaXBoZXIuZmluYWwoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG5cdGNvbnN0IHRhZyA9IGNpcGhlci5nZXRBdXRoVGFnKCk7XG5cblx0ZW5jcnlwdGVkVGV4dCA9IEJ1ZmZlci5jb25jYXQoW2VuY3J5cHRlZFRleHQsIGZpbmFsXSk7XG5cblx0cmV0dXJuIEJ1ZmZlci5jb25jYXQoW3NhbHQsIGVuY3J5cHRlZFRleHQsIHRhZ10pO1xufVxuXG5mdW5jdGlvbiBkZWNyeXB0KGVuY3J5cHRlZERhdGEsIHBhc3N3b3JkKSB7XG5cdGNvbnN0IHNhbHQgPSBlbmNyeXB0ZWREYXRhLnNsaWNlKDAsIDY0KTtcblx0Y29uc3Qga2V5U2FsdCA9IHNhbHQuc2xpY2UoMCwgMzIpO1xuXHRjb25zdCBhYWRTYWx0ID0gc2FsdC5zbGljZSgtMzIpO1xuXG5cdGNvbnN0IGl2ID0gY3J5cHRvLnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnNfbnVtYmVyLCAxMiwgJ3NoYTUxMicpO1xuXHRjb25zdCBrZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwga2V5U2FsdCwgaXRlcmF0aW9uc19udW1iZXIsIDMyLCAnc2hhNTEyJyk7XG5cdGNvbnN0IGFhZCA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBhYWRTYWx0LCBpdGVyYXRpb25zX251bWJlciwgMzIsICdzaGE1MTInKTtcblxuXHRjb25zdCBjaXBoZXJ0ZXh0ID0gZW5jcnlwdGVkRGF0YS5zbGljZSg2NCwgZW5jcnlwdGVkRGF0YS5sZW5ndGggLSAxNik7XG5cdGNvbnN0IHRhZyA9IGVuY3J5cHRlZERhdGEuc2xpY2UoLTE2KTtcblxuXHRjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGFsZ29yaXRobSwga2V5LCBpdik7XG5cdGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcblx0ZGVjaXBoZXIuc2V0QUFEKGFhZCk7XG5cblx0bGV0IHBsYWludGV4dCA9IEJ1ZmZlci5mcm9tKGRlY2lwaGVyLnVwZGF0ZShjaXBoZXJ0ZXh0LCAnYmluYXJ5JyksICdiaW5hcnknKTtcblx0Y29uc3QgZmluYWwgPSBCdWZmZXIuZnJvbShkZWNpcGhlci5maW5hbCgnYmluYXJ5JyksICdiaW5hcnknKTtcblx0cGxhaW50ZXh0ID0gQnVmZmVyLmNvbmNhdChbcGxhaW50ZXh0LCBmaW5hbF0pO1xuXHRyZXR1cm4gcGxhaW50ZXh0O1xufVxuXG5mdW5jdGlvbiBlbmNyeXB0T2JqZWN0SW5NZW1vcnkoaW5wdXRPYmosIHBhc3N3b3JkLCBkZXB0aCwgY2FsbGJhY2spIHtcblx0Y29uc3QgUHNrQXJjaGl2ZXIgPSByZXF1aXJlKFwiLi4vcHNrLWFyY2hpdmVyXCIpO1xuXHRjb25zdCBhcmNoaXZlciA9IG5ldyBQc2tBcmNoaXZlcigpO1xuXG5cdGFyY2hpdmVyLnppcEluTWVtb3J5KGlucHV0T2JqLCBkZXB0aCwgZnVuY3Rpb24gKGVyciwgemlwcGVkT2JqKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XG5cdFx0fVxuXHRcdGNvbnN0IGNpcGhlclRleHQgPSBlbmNyeXB0KHppcHBlZE9iaiwgcGFzc3dvcmQpO1xuXHRcdGNhbGxiYWNrKG51bGwsIGNpcGhlclRleHQpO1xuXHR9KVxufVxuXG5mdW5jdGlvbiBkZWNyeXB0T2JqZWN0SW5NZW1vcnkoZW5jcnlwdGVkT2JqZWN0LCBwYXNzd29yZCwgY2FsbGJhY2spIHtcblx0Y29uc3QgYXJjaGl2ZXIgPSBuZXcgUHNrQXJjaGl2ZXIoKTtcblxuXHRjb25zdCB6aXBwZWRPYmplY3QgPSBkZWNyeXB0KGVuY3J5cHRlZE9iamVjdCwgcGFzc3dvcmQpO1xuXHRhcmNoaXZlci51bnppcEluTWVtb3J5KHppcHBlZE9iamVjdCwgZnVuY3Rpb24gKGVyciwgb2JqKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XG5cdFx0fVxuXHRcdGNhbGxiYWNrKG51bGwsIG9iaik7XG5cdH0pXG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZVBza0hhc2gsXG5cdGVuY3J5cHQsXG5cdGVuY3J5cHRPYmplY3RJbk1lbW9yeSxcblx0ZGVjcnlwdCxcblx0ZGVjcnlwdE9iamVjdEluTWVtb3J5LFxuXHRkZWxldGVSZWN1cnNpdmVseSxcblx0ZW5jb2RlLFxuXHRnZW5lcmF0ZVNhbHQsXG5cdGl0ZXJhdGlvbnNfbnVtYmVyLFxuXHRhbGdvcml0aG0sXG5cdFBza0hhc2hcbn07XG5cbiIsImNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5cbmZ1bmN0aW9uIGlzU3RyZWFtIChvYmopIHtcblx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIHN0cmVhbS5TdHJlYW0gfHwgb2JqIGluc3RhbmNlb2Ygc3RyZWFtLkR1cGxleDtcbn1cblxuXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChvYmopIHtcblx0cmV0dXJuIGlzU3RyZWFtKG9iaikgJiYgdHlwZW9mIG9iai5fcmVhZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLl9yZWFkYWJsZVN0YXRlID09PSAnb2JqZWN0J1xufVxuXG5cbmZ1bmN0aW9uIGlzV3JpdGFibGUgKG9iaikge1xuXHRyZXR1cm4gaXNTdHJlYW0ob2JqKSAmJiB0eXBlb2Ygb2JqLl93cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLl93cml0YWJsZVN0YXRlID09PSAnb2JqZWN0J1xufVxuXG5cbmZ1bmN0aW9uIGlzRHVwbGV4IChvYmopIHtcblx0cmV0dXJuIGlzUmVhZGFibGUob2JqKSAmJiBpc1dyaXRhYmxlKG9iailcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyAgICAgICAgICAgID0gaXNTdHJlYW07XG5tb2R1bGUuZXhwb3J0cy5pc1JlYWRhYmxlID0gaXNSZWFkYWJsZTtcbm1vZHVsZS5leHBvcnRzLmlzV3JpdGFibGUgPSBpc1dyaXRhYmxlO1xubW9kdWxlLmV4cG9ydHMuaXNEdXBsZXggICA9IGlzRHVwbGV4OyIsIi8qXG4gU2lnblNlbnMgaGVscGVyIGZ1bmN0aW9uc1xuICovXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuZXhwb3J0cy53aXBlT3V0c2lkZVBheWxvYWQgPSBmdW5jdGlvbiB3aXBlT3V0c2lkZVBheWxvYWQoaGFzaFN0cmluZ0hleGEsIHBvcywgc2l6ZSl7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgc3ogPSBoYXNoU3RyaW5nSGV4YS5sZW5ndGg7XG5cbiAgICB2YXIgZW5kID0gKHBvcyArIHNpemUpICUgc3o7XG5cbiAgICBpZihwb3MgPCBlbmQpe1xuICAgICAgICByZXN1bHQgPSAnMCcucmVwZWF0KHBvcykgKyAgaGFzaFN0cmluZ0hleGEuc3Vic3RyaW5nKHBvcywgZW5kKSArICcwJy5yZXBlYXQoc3ogLSBlbmQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gaGFzaFN0cmluZ0hleGEuc3Vic3RyaW5nKDAsIGVuZCkgKyAnMCcucmVwZWF0KHBvcyAtIGVuZCkgKyBoYXNoU3RyaW5nSGV4YS5zdWJzdHJpbmcocG9zLCBzeik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuXG5leHBvcnRzLmV4dHJhY3RQYXlsb2FkID0gZnVuY3Rpb24gZXh0cmFjdFBheWxvYWQoaGFzaFN0cmluZ0hleGEsIHBvcywgc2l6ZSl7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHZhciBzeiA9IGhhc2hTdHJpbmdIZXhhLmxlbmd0aDtcbiAgICB2YXIgZW5kID0gKHBvcyArIHNpemUpICUgc3o7XG5cbiAgICBpZiggcG9zIDwgZW5kKXtcbiAgICAgICAgcmVzdWx0ID0gaGFzaFN0cmluZ0hleGEuc3Vic3RyaW5nKHBvcywgcG9zICsgc2l6ZSk7XG4gICAgfSBlbHNle1xuXG4gICAgICAgIGlmKDAgIT0gZW5kKXtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhc2hTdHJpbmdIZXhhLnN1YnN0cmluZygwLCBlbmQpXG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gaGFzaFN0cmluZ0hleGEuc3Vic3RyaW5nKHBvcywgc3opO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cblxuZXhwb3J0cy5maWxsUGF5bG9hZCA9IGZ1bmN0aW9uIGZpbGxQYXlsb2FkKHBheWxvYWQsIHBvcywgc2l6ZSl7XG4gICAgdmFyIHN6ID0gNjQ7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICB2YXIgZW5kID0gKHBvcyArIHNpemUpICUgc3o7XG5cbiAgICBpZiggcG9zIDwgZW5kKXtcbiAgICAgICAgcmVzdWx0ID0gJzAnLnJlcGVhdChwb3MpICsgcGF5bG9hZCArICcwJy5yZXBlYXQoc3ogLSBlbmQpO1xuICAgIH0gZWxzZXtcbiAgICAgICAgcmVzdWx0ID0gcGF5bG9hZC5zdWJzdHJpbmcoMCxlbmQpO1xuICAgICAgICByZXN1bHQgKz0gJzAnLnJlcGVhdChwb3MgLSBlbmQpO1xuICAgICAgICByZXN1bHQgKz0gcGF5bG9hZC5zdWJzdHJpbmcoZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5cbmV4cG9ydHMuZ2VuZXJhdGVQb3NIYXNoWFRpbWVzID0gZnVuY3Rpb24gZ2VuZXJhdGVQb3NIYXNoWFRpbWVzKGJ1ZmZlciwgcG9zLCBzaXplLCBjb3VudCl7IC8vZ2VuZXJhdGUgcG9zaXRpb25hbCBoYXNoXG4gICAgdmFyIHJlc3VsdCAgPSBidWZmZXIudG9TdHJpbmcoXCJoZXhcIik7XG5cbiAgICAvKmlmKHBvcyAhPSAtMSApXG4gICAgICAgIHJlc3VsdFtwb3NdID0gMDsgKi9cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKXtcbiAgICAgICAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gICAgICAgIHJlc3VsdCA9IGV4cG9ydHMud2lwZU91dHNpZGVQYXlsb2FkKHJlc3VsdCwgcG9zLCBzaXplKTtcbiAgICAgICAgaGFzaC51cGRhdGUocmVzdWx0KTtcbiAgICAgICAgcmVzdWx0ID0gaGFzaC5kaWdlc3QoJ2hleCcpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy53aXBlT3V0c2lkZVBheWxvYWQocmVzdWx0LCBwb3MsIHNpemUpO1xufVxuXG5leHBvcnRzLmhhc2hTdHJpbmdBcnJheSA9IGZ1bmN0aW9uIChjb3VudGVyLCBhcnIsIHBheWxvYWRTaXplKXtcblxuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gICAgdmFyIHJlc3VsdCA9IGNvdW50ZXIudG9TdHJpbmcoMTYpO1xuXG4gICAgZm9yKHZhciBpID0gMCA7IGkgPCA2NDsgaSsrKXtcbiAgICAgICAgcmVzdWx0ICs9IGV4cG9ydHMuZXh0cmFjdFBheWxvYWQoYXJyW2ldLGksIHBheWxvYWRTaXplKTtcbiAgICB9XG5cbiAgICBoYXNoLnVwZGF0ZShyZXN1bHQpO1xuICAgIHZhciByZXN1bHQgPSBoYXNoLmRpZ2VzdCgnaGV4Jyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGR1bXBNZW1iZXIob2JqKXtcbiAgICB2YXIgdHlwZSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBvYmo7XG4gICAgaWYob2JqID09PSBudWxsKXtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZihvYmogPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cblxuICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6cmV0dXJuIG9iai50b1N0cmluZygpOyBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiByZXR1cm4gZXhwb3J0cy5kdW1wT2JqZWN0Rm9ySGFzaGluZyhvYmopOyBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuICBvYmo/IFwidHJ1ZVwiOiBcImZhbHNlXCI7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBvYmoubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBleHBvcnRzLmR1bXBPYmplY3RGb3JIYXNoaW5nKG9ialtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIFwiICsgIHR5cGUgKyBcIiBjYW5ub3QgYmUgY3J5cHRvZ3JhcGhpY2FsbHkgZGlnZXN0ZWRcIik7XG4gICAgfVxuXG59XG5cblxuZXhwb3J0cy5kdW1wT2JqZWN0Rm9ySGFzaGluZyA9IGZ1bmN0aW9uKG9iail7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICBpZihvYmogPT09IG51bGwpe1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmKG9iaiA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgfVxuXG4gICAgdmFyIGJhc2ljVHlwZXMgPSB7XG4gICAgICAgIFwiYXJyYXlcIiAgICAgOiB0cnVlLFxuICAgICAgICBcIm51bWJlclwiICAgIDogdHJ1ZSxcbiAgICAgICAgXCJib29sZWFuXCIgICA6IHRydWUsXG4gICAgICAgIFwic3RyaW5nXCIgICAgOiB0cnVlLFxuICAgICAgICBcIm9iamVjdFwiICAgIDogZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBvYmo7XG4gICAgaWYoIGJhc2ljVHlwZXNbdHlwZV0pe1xuICAgICAgICByZXR1cm4gZHVtcE1lbWJlcihvYmopO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBrZXlzLnNvcnQoKTtcblxuXG4gICAgZm9yKHZhciBpPTA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmVzdWx0ICs9IGR1bXBNZW1iZXIoa2V5c1tpXSk7XG4gICAgICAgIHJlc3VsdCArPSBkdW1wTWVtYmVyKG9ialtrZXlzW2ldXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5leHBvcnRzLmhhc2hWYWx1ZXMgID0gZnVuY3Rpb24gKHZhbHVlcyl7XG4gICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICB2YXIgcmVzdWx0ID0gZXhwb3J0cy5kdW1wT2JqZWN0Rm9ySGFzaGluZyh2YWx1ZXMpO1xuICAgIGhhc2gudXBkYXRlKHJlc3VsdCk7XG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCdoZXgnKTtcbn07XG5cbmV4cG9ydHMuZ2V0SlNPTkZyb21TaWduYXR1cmUgPSBmdW5jdGlvbiBnZXRKU09ORnJvbVNpZ25hdHVyZShzaWduYXR1cmUsIHNpemUpe1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHByb29mOltdXG4gICAgfTtcbiAgICB2YXIgYSA9IHNpZ25hdHVyZS5zcGxpdChcIjpcIik7XG4gICAgcmVzdWx0LmFnZW50ICAgICAgICA9IGFbMF07XG4gICAgcmVzdWx0LmNvdW50ZXIgICAgICA9ICBwYXJzZUludChhWzFdLCBcImhleFwiKTtcbiAgICByZXN1bHQubmV4dFB1YmxpYyAgID0gIGFbMl07XG5cbiAgICB2YXIgcHJvb2YgPSBhWzNdXG5cblxuICAgIGlmKHByb29mLmxlbmd0aC9zaXplICE9IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlIFwiICsgcHJvb2YpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKXtcbiAgICAgICAgcmVzdWx0LnByb29mLnB1c2goZXhwb3J0cy5maWxsUGF5bG9hZChwcm9vZi5zdWJzdHJpbmcoaSAqIHNpemUsKGkrMSkgKiBzaXplICksIGksIHNpemUpKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlU2lnbmF0dXJlID0gZnVuY3Rpb24gKGFnZW50LGNvdW50ZXIsIG5leHRQdWJsaWMsIGFyciwgc2l6ZSl7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmVzdWx0ICs9IGV4cG9ydHMuZXh0cmFjdFBheWxvYWQoYXJyW2ldLCBpICwgc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFnZW50ICsgXCI6XCIgKyBjb3VudGVyICsgXCI6XCIgKyBuZXh0UHVibGljICsgXCI6XCIgKyByZXN1bHQ7XG59IiwiY29uc3QgTG9nRmFjdG9yeSA9IHJlcXVpcmUoJy4vTG9nRmFjdG9yeScpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1RyYW5zcG9ydEludGVyZmFjZX0gbWVzc2FnZVB1Ymxpc2hlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdlbmVyaWNMb2dnZXJDbGllbnQobWVzc2FnZVB1Ymxpc2hlcikge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdG8gYmUgdXNlZCB0byBzZW5kIG5vcm1hbCBsb2dzLiBUaGV5IHdpbGwgYmUgcHVibGlzaGVkIGluIGEgc3ViY2hhbm5lbCBvZiB0aGUgXCJsb2dzXCIgY2hhbm5lbC5cbiAgICAgKiBJdCBpcyBlYXNpZXIgdG8gdHJhY2Ugb25seSB1c2VyIGFuZCBwbGF0Zm9ybSBsb2dzIGlmIHRoZXkgYXJlIHNlcGFyYXRlZCBpbiB0aGlzIGNoYW5uZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e2NvZGU6IE51bWJlciwgbmFtZTogc3RyaW5nfX0gbG9nTGV2ZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3tsZXZlbCwgbWV0YSwgdGltZSwgbXNUaW1lLCBtZXNzYWdlc319XG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9nKGxvZ0xldmVsLCBtZXRhLCBtZXNzYWdlcykge1xuICAgICAgICBjb25zdCBsb2cgPSBMb2dGYWN0b3J5LmNyZWF0ZUxvZyhsb2dMZXZlbCwgbWV0YSwgbWVzc2FnZXMpO1xuXG4gICAgICAgIGNvbnN0IGxvZ0NoYW5uZWwgPSBgbG9ncy4ke2xvZ0xldmVsLm5hbWV9YDtcbiAgICAgICAgbWVzc2FnZVB1Ymxpc2hlci5zZW5kKGxvZ0NoYW5uZWwsIGxvZyk7XG5cbiAgICAgICAgcmV0dXJuIGxvZztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdG8gYmUgdXNlZCBmb3Igc2VuZGluZyBjdXN0b20gZXZlbnRzIHdoZW4gbWVzc2FnZXMgZG9uJ3QgaGFwcGVuIGluIHRoZSBub3JtYWwgZmxvdyBvZiB0aGUgcGxhdGZvcm1cbiAgICAgKiBvciB0aGV5IHNob3VsZG4ndCBpbnRlcmZlcmUgd2l0aCB0aGUgdHJhY2luZyBvZiBsb2dzXG4gICAgICogRm9yIGV4YW1wbGUsIHNlbmRpbmcgc3RhdGlzdGljcyBhYm91dCBhIG5vZGUgb3IgYSBzYW5kYm94IGlzIGhhcHBlbmluZyBwZXJpb2RpY2FsbHkgYW5kIG5vdCBhcyBhIHJlc3VsdCBvZlxuICAgICAqIHVzZXJzJyBydW5uaW5nIGNvZGUsIHRoZXJlZm9yZSB0aGlzIHNob3VsZCBub3QgYmUgbWVyZ2VkIHdpdGggbG9nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbWVzc2FnZXNcbiAgICAgKiBAcmV0dXJuIHt7bWV0YSwgbWVzc2FnZXMsIHRpbWV9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZW50KGNoYW5uZWwsIG1ldGEsIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gTG9nRmFjdG9yeS5jcmVhdGVFdmVudChtZXRhLCBtZXNzYWdlcyk7XG5cbiAgICAgICAgY29uc3QgbG9nQ2hhbm5lbCA9IGBldmVudHMuJHtjaGFubmVsfWA7XG4gICAgICAgIG1lc3NhZ2VQdWJsaXNoZXIuc2VuZChsb2dDaGFubmVsLCBldmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2goY2hhbm5lbCwgbWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlUHVibGlzaGVyLnNlbmQoY2hhbm5lbCwgbWVzc2FnZSk7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudCAgPSBldmVudDtcbiAgICB0aGlzLmxvZyAgICA9IGxvZztcbiAgICB0aGlzLnB1Ymxpc2ggPSBwdWJsaXNoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNMb2dnZXJDbGllbnQ7XG4iLCJmdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIGlmKHByb2Nlc3MuZW52LmNvbnRleHQgPT09ICdzYW5kYm94Jykge1xuXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qge3BlcmZvcm1hbmNlfSA9IHJlcXVpcmUoJ3BlcmZfaG9va3MnKTtcblxuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCkgKyBwZXJmb3JtYW5jZS50aW1lT3JpZ2luO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVMb2cobG9nTGV2ZWwsIG1ldGEsIG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgIHRpbWU6IGdldFRpbWUoKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQobWV0YSwgbWVzc2FnZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgbWV0YSxcbiAgICAgICAgdGltZTogZ2V0VGltZSgpXG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlTG9nLFxuICAgIGNyZWF0ZUV2ZW50XG59O1xuIiwiY29uc3QgR2VuZXJpY0xvZ2dlckNsaWVudCA9IHJlcXVpcmUoJy4vR2VuZXJpY0xvZ2dlckNsaWVudCcpO1xuY29uc3QgTG9nTGV2ZWwgPSByZXF1aXJlKCcuLi91dGlscy9Mb2dMZXZlbCcpO1xuY29uc3QgTG9nZ2VySW50ZXJmYWNlID0gcmVxdWlyZSgnLi9Mb2dnZXJJbnRlcmZhY2UnKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtUcmFuc3BvcnRJbnRlcmZhY2V9IG1lc3NhZ2VQdWJsaXNoZXJcbiAqIEBpbXBsZW1lbnRzIExvZ2dlckludGVyZmFjZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvZ2dlckNsaWVudChtZXNzYWdlUHVibGlzaGVyKSB7XG4gICAgTG9nZ2VySW50ZXJmYWNlLmNhbGwodGhpcyk7XG5cbiAgICBjb25zdCBnZW5lcmljTG9nZ2VyQ2xpZW50ID0gbmV3IEdlbmVyaWNMb2dnZXJDbGllbnQobWVzc2FnZVB1Ymxpc2hlcik7XG5cblxuICAgIC8qKioqKioqKioqKioqIFBVQkxJQyBNRVRIT0RTICoqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBkZWJ1ZyhtZXRhID0ge30sIC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBsb2dMZXZlbCA9IF9nZXRMb2dMZXZlbChMb2dMZXZlbC5kZWJ1Zyk7XG5cbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQubG9nKGxvZ0xldmVsLCBtZXRhLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKG1ldGEgPSB7fSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGxvZ0xldmVsID0gX2dldExvZ0xldmVsKExvZ0xldmVsLmVycm9yKTtcblxuICAgICAgICByZXR1cm4gZ2VuZXJpY0xvZ2dlckNsaWVudC5sb2cobG9nTGV2ZWwsIG1ldGEsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5mbyhtZXRhID0ge30sIC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBsb2dMZXZlbCA9IF9nZXRMb2dMZXZlbChMb2dMZXZlbC5pbmZvKTtcblxuICAgICAgICByZXR1cm4gZ2VuZXJpY0xvZ2dlckNsaWVudC5sb2cobG9nTGV2ZWwsIG1ldGEsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nKG1ldGEgPSB7fSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGxvZ0xldmVsID0gX2dldExvZ0xldmVsKExvZ0xldmVsLmxvZyk7XG5cbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQubG9nKGxvZ0xldmVsLCBtZXRhLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obWV0YSA9IHt9LCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSBfZ2V0TG9nTGV2ZWwoTG9nTGV2ZWwud2Fybik7XG5cbiAgICAgICAgcmV0dXJuIGdlbmVyaWNMb2dnZXJDbGllbnQubG9nKGxvZ0xldmVsLCBtZXRhLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV2ZW50KGNoYW5uZWwsIG1ldGEgPSB7fSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmljTG9nZ2VyQ2xpZW50LmV2ZW50KGNoYW5uZWwsIG1ldGEsIC4uLnBhcmFtcyk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHJlZGlyZWN0KGNoYW5uZWwsIGxvZ09iamVjdCkge1xuICAgICAgICByZXR1cm4gZ2VuZXJpY0xvZ2dlckNsaWVudC5wdWJsaXNoKGNoYW5uZWwsIGxvZ09iamVjdClcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqIFBSSVZBVEUgTUVUSE9EUyAqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gX2dldExvZ0xldmVsKGxldmVsQ29kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogbGV2ZWxDb2RlLFxuICAgICAgICAgICAgbmFtZTogTG9nTGV2ZWxbbGV2ZWxDb2RlXVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLyoqKioqKioqKioqKiogRVhQT1JUUyAqKioqKioqKioqKioqL1xuXG4gICAgdGhpcy5kZWJ1ZyAgICA9IGRlYnVnO1xuICAgIHRoaXMuZXJyb3IgICAgPSBlcnJvcjtcbiAgICB0aGlzLmV2ZW50ICAgID0gZXZlbnQ7XG4gICAgdGhpcy5pbmZvICAgICA9IGluZm87XG4gICAgdGhpcy5sb2cgICAgICA9IGxvZztcbiAgICB0aGlzLnJlZGlyZWN0ID0gcmVkaXJlY3Q7XG4gICAgdGhpcy53YXJuICAgICA9IHdhcm47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyQ2xpZW50O1xuIiwiLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmZ1bmN0aW9uIExvZ2dlckludGVyZmFjZSgpIHtcbiAgICBmdW5jdGlvbiBnZW5lcmljTWV0aG9kKGNoYW5uZWwsIGxvZ09iamVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuZGVidWcgICAgPSBnZW5lcmljTWV0aG9kO1xuICAgIHRoaXMuZXJyb3IgICAgPSBnZW5lcmljTWV0aG9kO1xuICAgIHRoaXMuZXZlbnQgICAgPSBnZW5lcmljTWV0aG9kO1xuICAgIHRoaXMuaW5mbyAgICAgPSBnZW5lcmljTWV0aG9kO1xuICAgIHRoaXMubG9nICAgICAgPSBnZW5lcmljTWV0aG9kO1xuICAgIHRoaXMucmVkaXJlY3QgPSBnZW5lcmljTWV0aG9kO1xuICAgIHRoaXMud2FybiAgICAgPSBnZW5lcmljTWV0aG9kO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ2dlckludGVyZmFjZTtcbiIsImNvbnN0IEdlbmVyaWNMb2dnZXJDbGllbnQgPSByZXF1aXJlKCcuL0dlbmVyaWNMb2dnZXJDbGllbnQnKTtcbmNvbnN0IExvZ0ZhY3RvcnkgICAgICAgICAgPSByZXF1aXJlKCcuL0xvZ0ZhY3RvcnknKTtcbmNvbnN0IExvZ2dlckNsaWVudCAgICAgICAgPSByZXF1aXJlKCcuL0xvZ2dlckNsaWVudCcpO1xuY29uc3QgTG9nZ2VySW50ZXJmYWNlICAgICA9IHJlcXVpcmUoJy4vTG9nZ2VySW50ZXJmYWNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgR2VuZXJpY0xvZ2dlckNsaWVudCxcbiAgICBMb2dGYWN0b3J5LFxuICAgIExvZ2dlckNsaWVudCxcbiAgICBMb2dnZXJJbnRlcmZhY2Vcbn07XG4iLCJjb25zdCBUcmFuc3BvcnRJbnRlcmZhY2UgPSByZXF1aXJlKCcuL1RyYW5zcG9ydEludGVyZmFjZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgemVyb01RID0gcmVxdWlyZSgnemVyb21xJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgWmVyb01RIFB1Ymxpc2hlciBTb2NrZXQgYW5kIGNvbm5lY3RzIHRvIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBmb3IgYSBaZXJvTVEgU3Vic2NyaWJlclxuICogQHBhcmFtIHtzdHJpbmchfSBhZGRyZXNzIC0gQmFzZSBhZGRyZXNzIGluY2x1ZGluZyBwcm90b2NvbCBhbmQgcG9ydCAoZXg6IHRjcDovLzEyNy4wLjAuMTo4MDgwKVxuICogQGltcGxlbWVudHMgVHJhbnNwb3J0SW50ZXJmYWNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZVB1Ymxpc2hlcihhZGRyZXNzKSB7XG4gICAgVHJhbnNwb3J0SW50ZXJmYWNlLmNhbGwodGhpcyk7XG5cbiAgICBjb25zdCB6bXFTb2NrZXQgPSB6ZXJvTVEuY3JlYXRlU29ja2V0KCdwdWInKTtcblxuICAgIC8vIHVuY29tbWVudCBuZXh0IGxpbmUgaWYgbWVzc2FnZXMgYXJlIGxvc3RcbiAgICAvLyB6bXFTb2NrZXQuc2V0c29ja29wdCh6ZXJvTVEuWk1RX1NOREhXTSwgMCk7XG4gICAgY29uc3Qgc29ja2V0ID0gbmV3IHV0aWxzLkJ1ZmZlcmVkU29ja2V0KHptcVNvY2tldCwgdXRpbHMuU29ja2V0VHlwZS5jb25uZWN0YWJsZSk7XG5cblxuICAgIC8qKioqKioqKioqKioqIFBVQkxJQyBNRVRIT0RTICoqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ09iamVjdFxuICAgICAqL1xuICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uIChjaGFubmVsLCBsb2dPYmplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRMb2cgPSBKU09OLnN0cmluZ2lmeShsb2dPYmplY3QpO1xuXG4gICAgICAgICAgICBzb2NrZXQuc2VuZChbY2hhbm5lbCwgc2VyaWFsaXplZExvZ10pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZSgnRXJyb3Igd2hpbGUgc2VuZGluZyBvciBzZXJpYWxpemluZyBtZXNzYWdlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKioqKioqKioqKioqKiBNT05JVE9SIFNPQ0tFVCAqKioqKioqKioqKioqL1xuXG4gICAgem1xU29ja2V0LmNvbm5lY3QoYWRkcmVzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZVB1Ymxpc2hlcjtcbiIsImNvbnN0IFRyYW5zcG9ydEludGVyZmFjZSA9IHJlcXVpcmUoJy4vVHJhbnNwb3J0SW50ZXJmYWNlJyk7XG5cbi8qKlxuICogVGhpcyBhc3N1bWVzIGl0IGlzIGV4ZWN1dGVkIGluc2lkZSBhIHNhbmRib3ggYW5kIHRoYXQgZXhpc3RzIGFuIG9iamVjdCBcImxvZ2dlclwiIG9uIFwiZ2xvYmFsXCIgd2l0aCBhIG1ldGhvZCBcInNlbmRcIi5cbiAqIFNhbmRib3hlcyBjYW4ndCBjb25uZWN0IGRpcmVjdGx5IHRvIFplcm9NUSB0aGVyZWZvcmUgdGhpcyBqdXN0IHJlbGF5cyB0aGUgbWVzc2FnZSBvdXRzaWRlIHRoZSBzYW5kYm94LlxuICpcbiAqIEBpbXBsZW1lbnRzIFRyYW5zcG9ydEludGVyZmFjZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2VQdWJsaXNoZXJGb3JTYW5kYm94KCkge1xuXG4gICAgVHJhbnNwb3J0SW50ZXJmYWNlLmNhbGwodGhpcyk7XG5cbiAgICAvKioqKioqKioqKioqKiBQVUJMSUMgTUVUSE9EUyAqKioqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiAoY2hhbm5lbCwgbG9nT2JqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnbG9iYWwubG9nZ2VyLnNlbmQoW2NoYW5uZWwsIGxvZ09iamVjdF0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aGlsZSBzZW5kaW5nIG9yIHNlcmlhbGl6aW5nIG1lc3NhZ2UnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlUHVibGlzaGVyRm9yU2FuZGJveDtcbiIsIi8qKlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZnVuY3Rpb24gVHJhbnNwb3J0SW50ZXJmYWNlKCkge1xuICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uIChjaGFubmVsLCBsb2dPYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0SW50ZXJmYWNlO1xuIiwiY29uc3QgVHJhbnNwb3J0SW50ZXJmYWNlID0gcmVxdWlyZSgnLi9UcmFuc3BvcnRJbnRlcmZhY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgVHJhbnNwb3J0SW50ZXJmYWNlXG59O1xuXG5pZihwcm9jZXNzLmVudi5jb250ZXh0ID09PSAnc2FuZGJveCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5NZXNzYWdlUHVibGlzaGVyID0gcmVxdWlyZSgnLi9NZXNzYWdlUHVibGlzaGVyRm9yU2FuZGJveCcpO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5NZXNzYWdlUHVibGlzaGVyID0gcmVxdWlyZSgnLi9NZXNzYWdlUHVibGlzaGVyJyk7XG59XG4iLCJjb25zdCB6ZXJvTVEgPSByZXF1aXJlKCd6ZXJvbXEnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgWmVyb01RIFN1YnNjcmliZXIgdGhhdCBsaXN0ZW5zIGZvciBwcm92aWRlZCB0b3BpY3Mgb24gdGhlIHNwZWNpZmllZCBhZGRyZXNzIGZvciBhIHB1Ymxpc2hlclxuICogQHBhcmFtIHtzdHJpbmchfSBhZGRyZXNzIC0gQmFzZSBhZGRyZXNzIGluY2x1ZGluZyBwcm90b2NvbCBhbmQgcG9ydCAoZXg6IHRjcDovLzEyNy4wLjAuMTo4MDgwKVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fGZ1bmN0aW9uP30gc3Vic2NyaXB0aW9ucyAtIGEgbGlzdCBvZiBzdWJzY3JpcHRpb24gdG9waWNzLCBpZiBtaXNzaW5nIGl0IHdpbGwgc3Vic2NyaWJlIHRvIGV2ZXJ5dGhpbmdcbiAqIEBwYXJhbSB7ZnVuY3Rpb24hfSBvbk1lc3NhZ2VDYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2VTdWJzY3JpYmVyKGFkZHJlc3MsIHN1YnNjcmlwdGlvbnMsIG9uTWVzc2FnZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgem1xU29ja2V0ID0gemVyb01RLmNyZWF0ZVNvY2tldCgnc3ViJyk7XG5cbiAgICAvLyB1bmNvbW1lbnQgbmV4dCBsaW5lIGlmIG1lc3NhZ2VzIGFyZSBsb3N0XG4gICAgLy8gem1xU29ja2V0LnNldHNvY2tvcHQoemVyb01RLlpNUV9SQ1ZIV00sIDApO1xuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbk1lc3NhZ2VDYWxsYmFjayA9IHN1YnNjcmlwdGlvbnM7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMgPSBbJyddO1xuICAgIH1cblxuICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4gem1xU29ja2V0LnN1YnNjcmliZShzdWJzY3JpcHRpb24pKTtcblxuICAgIHptcVNvY2tldC5jb25uZWN0KGFkZHJlc3MpO1xuXG4gICAgem1xU29ja2V0Lm9uKCdtZXNzYWdlJywgb25NZXNzYWdlQ2FsbGJhY2spO1xuXG4gICAgY29uc3QgZXZlbnRzID0gW1wiU0lHSU5UXCIsIFwiU0lHVVNSMVwiLCBcIlNJR1VTUjJcIiwgXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBcIlNJR1RFUk1cIiwgXCJTSUdIVVBcIl07XG5cbiAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgIHByb2Nlc3Mub24oZXZlbnQsICgpID0+IHtcbiAgICAgICAgICAgIHptcVNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlU3Vic2NyaWJlcjtcbiIsImNvbnN0IE1lc3NhZ2VTdWJzY3JpYmVyID0gcmVxdWlyZSgnLi9NZXNzYWdlU3Vic2NyaWJlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtNZXNzYWdlU3Vic2NyaWJlcn07XG4iLCJjb25zdCBMb2dnZXJDbGllbnRNb2R1bGUgPSByZXF1aXJlKCcuLi9Mb2dnZXJDbGllbnQnKTtcblxuY29uc3QgTG9nZ2VyQ2xpZW50ID0gTG9nZ2VyQ2xpZW50TW9kdWxlLkxvZ2dlckNsaWVudDtcbmNvbnN0IExvZ2dlckludGVyZmFjZSA9IExvZ2dlckNsaWVudE1vZHVsZS5Mb2dnZXJJbnRlcmZhY2U7XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VQdWJsaXNoZXJcbiAqIEBpbXBsZW1lbnRzIExvZ2dlckludGVyZmFjZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdlbmVyaWNQU0tMb2dnZXIobWVzc2FnZVB1Ymxpc2hlcikge1xuICAgIExvZ2dlckludGVyZmFjZS5jYWxsKHRoaXMpO1xuXG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlckNsaWVudChtZXNzYWdlUHVibGlzaGVyKTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBtZXRhID0gcHJlcGFyZU1ldGEoKTtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci5kZWJ1ZyhtZXRhLCAuLi5wYXJhbXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBtZXRhID0gcHJlcGFyZU1ldGEoKTtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcihtZXRhLCAuLi5wYXJhbXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluZm8oLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBwcmVwYXJlTWV0YSgpO1xuICAgICAgICByZXR1cm4gbG9nZ2VyLmluZm8obWV0YSwgLi4ucGFyYW1zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2coLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBwcmVwYXJlTWV0YSgpO1xuICAgICAgICByZXR1cm4gbG9nZ2VyLmxvZyhtZXRhLCAuLi5wYXJhbXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4oLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBwcmVwYXJlTWV0YSgpO1xuICAgICAgICByZXR1cm4gbG9nZ2VyLndhcm4obWV0YSwgLi4ucGFyYW1zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBldmVudChldmVudCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBwcmVwYXJlTWV0YSgpO1xuICAgICAgICByZXR1cm4gbG9nZ2VyLmV2ZW50KGV2ZW50LCBtZXRhLCBwYXJhbXMpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiByZWRpcmVjdChsb2dUeXBlLCBsb2dPYmplY3QpIHtcbiAgICAgICAgY29uc3QgbG9nTWV0YSA9IGxvZ09iamVjdC5tZXRhO1xuICAgICAgICBjb25zdCBtZXRhID0gcHJlcGFyZU1ldGEoKTtcbiAgICAgICAgXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWV0YSwgbG9nTWV0YSk7XG5cbiAgICAgICAgbG9nT2JqZWN0Lm1ldGEgPSBtZXRhO1xuXG4gICAgICAgIHJldHVybiBsb2dnZXIucmVkaXJlY3QobG9nVHlwZSwgbG9nT2JqZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlTWV0YSgpIHtcbiAgICAgICAgaWYgKGdsb2JhbC4kJC5nZXRFbnZpcm9ubWVudERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWwuJCQuZ2V0RW52aXJvbm1lbnREYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cblxuICAgIHRoaXMuZGVidWcgICAgPSBkZWJ1ZztcbiAgICB0aGlzLmVycm9yICAgID0gZXJyb3I7XG4gICAgdGhpcy5ldmVudCAgICA9IGV2ZW50O1xuICAgIHRoaXMuaW5mbyAgICAgPSBpbmZvO1xuICAgIHRoaXMubG9nICAgICAgPSBsb2c7XG4gICAgdGhpcy5yZWRpcmVjdCA9IHJlZGlyZWN0O1xuICAgIHRoaXMud2FybiAgICAgPSB3YXJuO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1BTS0xvZ2dlcjtcbiIsImNvbnN0IENvbmZpZ3VyYXRvciAgICAgPSByZXF1aXJlKCcuLi91dGlscy9Db25maWd1cmF0b3InKTtcbmNvbnN0IEdlbmVyaWNQU0tMb2dnZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNQU0tMb2dnZXInKTtcbmNvbnN0IE1lc3NhZ2VQdWJsaXNoZXIgPSByZXF1aXJlKCcuLi9NZXNzYWdlUHVibGlzaGVyJykuTWVzc2FnZVB1Ymxpc2hlcjtcblxuZnVuY3Rpb24gZ2V0TG9nZ2VyKCkge1xuICAgIGxldCBtZXNzYWdlUHVibGlzaGVyO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52LmNvbnRleHQgPT09ICdzYW5kYm94Jykge1xuXG4gICAgICAgIG1lc3NhZ2VQdWJsaXNoZXIgPSBuZXcgTWVzc2FnZVB1Ymxpc2hlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IENvbmZpZ3VyYXRvci5nZXRDb25maWcoKTtcbiAgICAgICAgbWVzc2FnZVB1Ymxpc2hlciA9IG5ldyBNZXNzYWdlUHVibGlzaGVyKGNvbmZpZy5hZGRyZXNzRm9yUHVibGlzaGVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBHZW5lcmljUFNLTG9nZ2VyKG1lc3NhZ2VQdWJsaXNoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRMb2dnZXJcbn07XG4iLCJjb25zdCB6ZXJvTVEgPSByZXF1aXJlKCd6ZXJvbXEnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBQcm94eSBiZXR3ZWVuIHB1Ymxpc2hlcnMgYW5kIHN1YnNjcmliZXJzIHRvIGF2b2lkIHN0YXIgdG9wb2xvZ3kgY29tbXVuaWNhdGlvblxuICogU3Vic2NyaWJlcnMgc2hvdWxkIGNvbm5lY3QgZmlyc3Qgb3RoZXJ3aXNlIG5vIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHdpbGwgYmUgc2VudCB0byBwdWJsaXNoZXJzIGFuZCB0aGVyZWZvcmUgdGhleVxuICogd29uJ3QgZXZlbiBzZW5kIHRoZSBtZXNzYWdlcyB0byB0aGUgcHJveHkuIFRoaXMgaXMgYmVjYXVzZSB0aGUgZmlsdGVyaW5nIGlzIGRvbmUgb24gdGhlIHB1Ymxpc2hlciBmb3IgdGNwIG9yIGlwYyxcbiAqIHZpZXcgaHR0cDovL3pndWlkZS56ZXJvbXEub3JnL3BhZ2U6YWxsI0dldHRpbmctdGhlLU1lc3NhZ2UtT3V0IGZvciBtb3JlIGluZm9cbiAqIEBwYXJhbSB7c3RyaW5nIX0gYWRkcmVzc0ZvclB1Ymxpc2hlcnMgLSBCYXNlIGFkZHJlc3MgaW5jbHVkaW5nIHByb3RvY29sIGFuZCBwb3J0IChleDogdGNwOi8vMTI3LjAuMC4xOjgwODApXG4gKiBAcGFyYW0ge3N0cmluZyF9IGFkZHJlc3NGb3JTdWJzY3JpYmVycyAtIEJhc2UgYWRkcmVzcyBpbmNsdWRpbmcgcHJvdG9jb2wgYW5kIHBvcnQgKGV4OiB0Y3A6Ly8xMjcuMC4wLjE6ODA4MClcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQdWJTdWJQcm94eSh7YWRkcmVzc0ZvclB1Ymxpc2hlcnMsIGFkZHJlc3NGb3JTdWJzY3JpYmVyc30pIHtcbiAgICBjb25zdCBmcm9udGVuZCA9IHplcm9NUS5jcmVhdGVTb2NrZXQoJ3hzdWInKTtcbiAgICBjb25zdCBiYWNrZW5kID0gemVyb01RLmNyZWF0ZVNvY2tldCgneHB1YicpO1xuICAgIGNvbnN0IGJ1ZmZlcmVkQmFja2VuZCA9IG5ldyB1dGlscy5CdWZmZXJlZFNvY2tldChiYWNrZW5kLCB1dGlscy5Tb2NrZXRUeXBlLmJpbmRhYmxlKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQgeHB1YiBvbmx5IHNpZ25hbHMgbmV3IHN1YnNjcmlwdGlvbnNcbiAgICAvLyBTZXR0aW5ncyBpdCB0byB2ZXJib3NlID0gMSAsIHdpbGwgc2lnbmFsIG9uIGV2ZXJ5IG5ldyBzdWJzY3JpYmVcbiAgICAvLyB1bmNvbW1lbnQgbmV4dCBsaW5lcyBpZiBtZXNzYWdlcyBhcmUgbG9zdFxuICAgIC8vIGJhY2tlbmQuc2V0c29ja29wdCh6ZXJvTVEuWk1RX1hQVUJfVkVSQk9TRSwgMSk7XG4gICAgLy8gYmFja2VuZC5zZXRzb2Nrb3B0KHplcm9NUS5aTVFfU05ESFdNLCAwKTtcbiAgICAvLyBiYWNrZW5kLnNldHNvY2tvcHQoemVyb01RLlpNUV9SQ1ZIV00sIDApO1xuICAgIC8vIGZyb250ZW5kLnNldHNvY2tvcHQoemVyb01RLlpNUV9SQ1ZIV00sIDApO1xuICAgIC8vIGZyb250ZW5kLnNldHNvY2tvcHQoemVyb01RLlpNUV9TTkRIV00sIDApO1xuXG4gICAgLy8gV2hlbiB3ZSByZWNlaXZlIGRhdGEgb24gZnJvbnRlbmQsIGl0IG1lYW5zIHNvbWVvbmUgaXMgcHVibGlzaGluZ1xuICAgIGZyb250ZW5kLm9uKCdtZXNzYWdlJywgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gV2UganVzdCByZWxheSBpdCB0byB0aGUgYmFja2VuZCwgc28gc3Vic2NyaWJlcnMgY2FuIHJlY2VpdmUgaXRcbiAgICAgICAgYnVmZmVyZWRCYWNrZW5kLnNlbmQoYXJncyk7XG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIGJhY2tlbmQgcmVjZWl2ZXMgYSBtZXNzYWdlLCBpdCdzIHN1YnNjcmliZSByZXF1ZXN0c1xuICAgIGJhY2tlbmQub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4ge1xuICAgICAgICAvLyBXZSBzZW5kIGl0IHRvIGZyb250ZW5kLCBzbyBpdCBrbm93cyB0byB3aGF0IGNoYW5uZWxzIHRvIGxpc3RlbiB0b1xuICAgICAgICBmcm9udGVuZC5zZW5kKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgLyoqKioqKioqKioqKiogTU9OSVRPUiBTT0NLRVQgKioqKioqKioqKioqKi9cblxuICAgIGZyb250ZW5kLmJpbmRTeW5jKGFkZHJlc3NGb3JQdWJsaXNoZXJzKTtcbiAgICBiYWNrZW5kLmJpbmRTeW5jKGFkZHJlc3NGb3JTdWJzY3JpYmVycyk7XG5cbiAgICBjb25zdCBldmVudHMgPSBbXCJTSUdJTlRcIiwgXCJTSUdVU1IxXCIsIFwiU0lHVVNSMlwiLCBcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIFwiU0lHVEVSTVwiLCBcIlNJR0hVUFwiXTtcblxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgcHJvY2Vzcy5vbihldmVudCwgKCkgPT4ge1xuICAgICAgICAgICAgZnJvbnRlbmQuY2xvc2UoKTtcbiAgICAgICAgICAgIGJhY2tlbmQuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHViU3ViUHJveHk7XG4iLCJjb25zdCBQdWJTdWJQcm94eSA9IHJlcXVpcmUoJy4vUHViU3ViUHJveHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7UHViU3ViUHJveHl9O1xuIiwiY29uc3QgU29ja2V0VHlwZSA9IHJlcXVpcmUoJy4vU29ja2V0VHlwZScpO1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIFplcm9NUSBzb2NrZXQgdGhhdCB0cmllcyB0byBwcmV2ZW50ICdzbG93IGpvaW5lcicsIG1lYW5pbmcgaXQgYnVmZmVycyB0aGUgZmlyc3QgbWVzc2FnZXMgdW50aWwgdGhlXG4gKiBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBvdGhlcndpc2UgdGhlIGZpcnN0IG1lc3NhZ2VzIHdvdWxkIGJlIGxvc3RcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXQgLSBpbnN0YW5jZSBvZiBaZXJvTVEgU29ja2V0XG4gKiBAcGFyYW0ge1NvY2tldFR5cGU8bnVtYmVyPn0gdHlwZSAtIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHNob3VsZCBsaXN0ZW4gZm9yICdjb25uZWN0JyBvciAnYWNjZXB0JyBldmVudFxuICogQHBhcmFtIHtOdW1iZXI/fSBtYXhTaXplID0gMTAwMCAtIE1heCBzaXplIGZvciB0aGUgaW50ZXJuYWwgYnVmZmVyLCBpZiAwIHRoZSBidWZmZXIgaXMgaW5maW5pdGUgYnV0IGNhbiBjYXVzZSBtZW1vcnkgbGVha1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcmVkU29ja2V0KHNvY2tldCwgdHlwZSwgbWF4U2l6ZSA9IDEwMDAwKSB7XG4gICAgaWYobWF4U2l6ZSA8IDApIHtcbiAgICAgICAgbWF4U2l6ZSA9IDEwMDA7XG4gICAgfVxuXG4gICAgbGV0IG1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgIGxldCBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50QnVmZmVyU2l6ZSA9IDA7XG5cbiAgICBzb2NrZXQubW9uaXRvcigpO1xuICAgIGNvbnN0IGV2ZW50ID0gX2dldEV2ZW50Rm9yVHlwZSh0eXBlKTtcblxuICAgIHNvY2tldC5vbihldmVudCwgKCkgPT4ge1xuICAgICAgICBpc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIF9mbHVzaFF1ZXVlKCk7XG4gICAgfSk7XG5cbiAgICAvKioqKioqKioqKioqKiBQVUJMSUMgTUVUSE9EUyAqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIGlmICghaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhTaXplICE9PSAwICYmIGN1cnJlbnRCdWZmZXJTaXplIDwgbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCdWZmZXJTaXplICs9IDE7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqIFBSSVZBVEUgTUVUSE9EUyAqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gX2ZsdXNoUXVldWUoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlUXVldWUpIHtcbiAgICAgICAgICAgIHNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgIGN1cnJlbnRCdWZmZXJTaXplID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0RXZlbnRGb3JUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFNvY2tldFR5cGUuY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29ubmVjdCc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gU29ja2V0VHlwZS5iaW5kYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuICdhY2NlcHQnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKiogRVhQT1JUUyAqKioqKioqKioqKioqL1xuXG4gICAgdGhpcy5zZW5kID0gc2VuZDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU29ja2V0O1xuIiwiY29uc3QgY29uZmlnID0ge1xuICAgIGFkZHJlc3NGb3JQdWJsaXNoZXJzOiAndGNwOi8vMTI3LjAuMC4xOjcwMDAnLFxuICAgIGFkZHJlc3NGb3JTdWJzY3JpYmVyczogJ3RjcDovLzEyNy4wLjAuMTo3MDAxJyxcbiAgICBhZGRyZXNzRm9yQ29sbGVjdG9yOiAndGNwOi8vMTI3LjAuMC4xOjU1NTgnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRDb25maWcgKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShjb25maWcpO1xuICAgIH1cbn07XG4iLCJcblxuZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnREYXRhICgpIHtcbiAgICBjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgIGNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbiAgICBjb25zdCBwbGF0Zm9ybSA9IG9zLnBsYXRmb3JtKCk7XG5cbiAgICBjb25zdCBwcm9jZXNzUGF0aCA9IHByb2Nlc3MuYXJndlsxXTtcbiAgICBjb25zdCBsYXN0U2VwID0gcHJvY2Vzc1BhdGgubGFzdEluZGV4T2YocGF0aC5zZXApO1xuICAgIGNvbnN0IHByb2Nlc3NTdGFydEZpbGUgPSBwcm9jZXNzUGF0aC5zdWJzdHJpbmcobGFzdFNlcCArIDEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbjogJ25vZGUnLFxuICAgICAgICBjb250ZXh0OiBwcm9jZXNzU3RhcnRGaWxlLFxuICAgICAgICBwcm9jZXNzU3RhcnRGaWxlOiBwcm9jZXNzU3RhcnRGaWxlLFxuICAgICAgICBwbGF0Zm9ybTogcGxhdGZvcm1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbnZpcm9ubWVudERhdGFGb3JEb21haW4oKSB7XG4gICAgY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gb3MucGxhdGZvcm0oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbjogJ2RvbWFpbicsXG4gICAgICAgIGRvbWFpbjogcHJvY2Vzcy5lbnYuUFJJVkFURVNLWV9ET01BSU5fTkFNRSxcbiAgICAgICAgcGxhdGZvcm06IHBsYXRmb3JtXG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbnZpcm9ubWVudERhdGFGb3JBZ2VudCgpIHtcbiAgICBjb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luOiAnYWdlbnQnLFxuICAgICAgICBkb21haW46IHByb2Nlc3MuZW52LlBSSVZBVEVTS1lfRE9NQUlOX05BTUUsXG4gICAgICAgIGFnZW50OiBwcm9jZXNzLmVudi5QUklWQVRFU0tZX0FHRU5UX05BTUUsXG4gICAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnREYXRhRm9yU2FuZGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW46ICdzYW5kYm94J1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0RW52aXJvbm1lbnREYXRhLFxuICAgIGdldEVudmlyb25tZW50RGF0YUZvckFnZW50LFxuICAgIGdldEVudmlyb25tZW50RGF0YUZvckRvbWFpbixcbiAgICBnZXRFbnZpcm9ubWVudERhdGFGb3JTYW5kYm94XG59O1xuIiwiY29uc3QgTG9nTGV2ZWwgPSB7fTtcblxuTG9nTGV2ZWxbTG9nTGV2ZWxbXCJlcnJvclwiXSA9IDBdID0gXCJlcnJvclwiO1xuTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ3YXJuXCJdICA9IDFdID0gXCJ3YXJuXCI7XG5Mb2dMZXZlbFtMb2dMZXZlbFtcImluZm9cIl0gID0gMl0gPSBcImluZm9cIjtcbkxvZ0xldmVsW0xvZ0xldmVsW1wiZGVidWdcIl0gPSAzXSA9IFwiZGVidWdcIjtcbkxvZ0xldmVsW0xvZ0xldmVsW1wibG9nXCJdICAgPSA0XSA9IFwibG9nXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShMb2dMZXZlbCk7XG4iLCJjb25zdCBTb2NrZXRUeXBlID0ge307XG5Tb2NrZXRUeXBlW1NvY2tldFR5cGVbXCJjb25uZWN0YWJsZVwiXSA9IDBdID0gXCJjb25uZWN0YWJsZVwiOyAvLyBpZiAuY29ubmVjdCBpcyBjYWxsZWQgb24gc29ja2V0XG5Tb2NrZXRUeXBlW1NvY2tldFR5cGVbXCJiaW5kYWJsZVwiXSA9IDFdID0gXCJiaW5kYWJsZVwiOyAvLyBpZiAuYmluZCBpcyBjYWxsZWQgb24gc29ja2V0XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShTb2NrZXRUeXBlKTtcbiIsImNvbnN0IENvbmZpZ3VyYXRvciAgICAgICAgICAgID0gcmVxdWlyZSgnLi9Db25maWd1cmF0b3InKTtcbmNvbnN0IEVudmlyb25tZW50RGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi9FbnZpcm9ubWVudERhdGFQcm92aWRlcicpO1xuY29uc3QgTG9nTGV2ZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL0xvZ0xldmVsJyk7XG5jb25zdCBCdWZmZXJlZFNvY2tldCAgICAgICAgICA9IHJlcXVpcmUoJy4vQnVmZmVyZWRTb2NrZXQnKTtcbmNvbnN0IFNvY2tldFR5cGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9Tb2NrZXRUeXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENvbmZpZ3VyYXRvcixcbiAgICBFbnZpcm9ubWVudERhdGFQcm92aWRlcixcbiAgICBMb2dMZXZlbCxcbiAgICBCdWZmZXJlZFNvY2tldCxcbiAgICBTb2NrZXRUeXBlXG59O1xuIiwiLypcbkluaXRpYWwgTGljZW5zZTogKGMpIEF4aW9sb2dpYyBSZXNlYXJjaCAmIEFsYm9haWUgU8OubmljxIMuXG5Db250cmlidXRvcnM6IEF4aW9sb2dpYyBSZXNlYXJjaCAsIFByaXZhdGVTa3kgcHJvamVjdFxuQ29kZSBMaWNlbnNlOiBMR1BMIG9yIE1JVC5cbiovXG5cblxuLyoqXG4gKiAgIFVzdWFsbHkgYW4gZXZlbnQgY291bGQgY2F1c2UgZXhlY3V0aW9uIG9mIG90aGVyIGNhbGxiYWNrIGV2ZW50cyAuIFdlIHNheSB0aGF0IGlzIGEgbGV2ZWwgMSBldmVudCBpZiBpcyBjYXVzZWVkIGJ5IGEgbGV2ZWwgMCBldmVudCBhbmQgc28gb25cbiAqXG4gKiAgICAgIFNvdW5kUHViU3ViIHByb3ZpZGVzIGludHVpdGl2ZSByZXN1bHRzIHJlZ2FyZGluZyB0byBhc3luY2hyb25vdXMgY2FsbHMgb2YgY2FsbGJhY2tzIGFuZCBjb21wdXRlZCB2YWx1ZXMvZXhwcmVzc2lvbnM6XG4gKiAgIHdlIHByZXZlbnQgaW1tZWRpYXRlIGV4ZWN1dGlvbiBvZiBldmVudCBjYWxsYmFja3MgdG8gZW5zdXJlIHRoZSBpbnR1aXRpdmUgZmluYWwgcmVzdWx0IGlzIGd1YXJhbnRlZWQgYXMgbGV2ZWwgMCBleGVjdXRpb25cbiAqICAgd2UgZ3VhcmFudGVlIHRoYXQgYW55IGNhbGxiYWNrIGZ1bmN0aW9uIGlzIFwicmUtZW50cmFudFwiXG4gKiAgIHdlIGFyZSBhbHNvIHRyeWluZyB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBjYWxsYmFjayBleGVjdXRpb24gYnkgbG9va2luZyBpbiBxdWV1ZXMgYXQgbmV3IG1lc3NhZ2VzIHB1Ymxpc2hlZCBieVxuICogICB0cnlpbmcgdG8gY29tcGFjdCB0aG9zZSBtZXNzYWdlcyAocmVtb3ZpbmcgZHVwbGljYXRlIG1lc3NhZ2VzLCBtb2RpZnlpbmcgbWVzc2FnZXMsIG9yIGFkZGluZyBpbiB0aGUgaGlzdG9yeSBvZiBhbm90aGVyIGV2ZW50ICxldGMpXG4gKlxuICogICAgICBFeGFtcGxlIG9mIHdoYXQgY2FuIGJlIHdyb25nIHdpdGhvdXQgbm9uLXNvdW5kIGFzeW5jaHJvbm91cyBjYWxsczpcbiAqXG4gKiAgU3RlcCAwOiBJbml0aWFsIHN0YXRlOlxuICogICBhID0gMDtcbiAqICAgYiA9IDA7XG4gKlxuICogIFN0ZXAgMTogSW5pdGlhbCBvcGVyYXRpb25zOlxuICogICBhID0gMTtcbiAqICAgYiA9IC0xO1xuICpcbiAqICAvLyBhbiBvYnNlcnZlciByZWFjdHMgdG8gY2hhbmdlcyBpbiBhIGFuZCBiIGFuZCBjb21wdXRlIENPUlJFQ1QgbGlrZSB0aGlzOlxuICogICBpZiggYSArIGIgPT0gMCkge1xuICogICAgICAgQ09SUkVDVCA9IGZhbHNlO1xuICogICAgICAgbm90aWZ5KC4uLik7IC8vIGFjdCBvciBzZW5kIGEgbm90aWZpY2F0aW9uIHNvbWV3aGVyZS4uXG4gKiAgIH0gZWxzZSB7XG4gKiAgICAgIENPUlJFQ1QgPSBmYWxzZTtcbiAqICAgfVxuICpcbiAqICAgIE5vdGljZSB0aGF0OiBDT1JSRUNUIHdpbGwgYmUgdHJ1ZSBpbiB0aGUgZW5kICwgYnV0IG1lYW50aW1lLCBhZnRlciBhIG5vdGlmaWNhdGlvbiB3YXMgc2VudCBhbmQgQ09SUkVDVCB3YXMgd3JvbmdseSwgdGVtcG9yYXJpbHkgZmFsc2UhXG4gKiAgICBzb3VuZFB1YlN1YiBndWFyYW50ZWUgdGhhdCB0aGlzIGRvZXMgbm90IGhhcHBlbiBiZWNhdXNlIHRoZSBzeW5jcm9ub3VzIGNhbGwgd2lsbCBiZWZvcmUgYW55IG9ic2VydmVyIChib3QgYXNpZ25hdGlvbiBvbiBhIGFuZCBiKVxuICpcbiAqICAgTW9yZTpcbiAqICAgeW91IGNhbiB1c2UgYmxvY2tDYWxsQmFja3MgYW5kIHJlbGVhc2VDYWxsQmFja3MgaW4gYSBmdW5jdGlvbiB0aGF0IGNoYW5nZSBhIGxvdCBhIGNvbGxlY3Rpb24gb3IgYmluZGFibGUgb2JqZWN0cyBhbmQgYWxsXG4gKiAgIHRoZSBub3RpZmljYXRpb25zIHdpbGwgYmUgc2VudCBjb21wYWN0ZWQgYW5kIHByb3Blcmx5XG4gKi9cblxuLy8gVE9ETzogb3B0aW1pc2F0aW9uIT8gdXNlIGEgbW9yZSBlZmZpY2llbnQgcXVldWUgaW5zdGVhZCBvZiBhcnJheXMgd2l0aCBwdXNoIGFuZCBzaGlmdCE/XG4vLyBUT0RPOiBzZWUgaG93IGJpZyB0aG9zZSBxdWV1ZXMgY2FuIGJlIGluIHJlYWwgYXBwbGljYXRpb25zXG4vLyBmb3IgYSBmZXcgaHVuZHJlZHMgaXRlbXMsIHF1ZXVlcyBtYWRlIGZyb20gYXJyYXkgc2hvdWxkIGJlIGVub3VnaFxuLy8qICAgUG90ZW50aWFsIFRPRE9zOlxuLy8gICAgKiAgICAgcHJldmVudCBhbnkgZm9ybSBvZiBwcm9ibGVtIGJ5IGNhbGxpbmcgY2FsbGJhY2tzIGluIHRoZSBleHBlY3RlZCBvcmRlciAhP1xuLy8qICAgICBwcmV2ZW50aW5nIGluZmluaXRlIGxvb3BzIGV4ZWN1dGlvbiBjYXVzZSBieSBldmVudHMhP1xuLy8qXG4vLypcbi8vIFRPRE86IGRldGVjdCBpbmZpbml0ZSBsb29wcyAob3IgdmVyeSBkZWVwIHByb3BhZ2F0aW9uKSBJdCBpcyBwb3NzaWJsZSE/XG5cbmNvbnN0IFF1ZXVlID0gcmVxdWlyZSgnc3dhcm11dGlscycpLlF1ZXVlO1xuXG5mdW5jdGlvbiBTb3VuZFB1YlN1Yigpe1xuXG5cdC8qKlxuXHQgKiBwdWJsaXNoXG5cdCAqICAgICAgUHVibGlzaCBhIG1lc3NhZ2Uge09iamVjdH0gdG8gYSBsaXN0IG9mIHN1YnNjcmliZXJzIG9uIGEgc3BlY2lmaWMgdG9waWNcblx0ICpcblx0ICogQHBhcmFtcyB7U3RyaW5nfE51bWJlcn0gdGFyZ2V0LCAge09iamVjdH0gbWVzc2FnZVxuXHQgKiBAcmV0dXJuIG51bWJlciBvZiBjaGFubmVsIHN1YnNjcmliZXJzIHRoYXQgd2lsbCBiZSBub3RpZmllZFxuXHQgKi9cblx0dGhpcy5wdWJsaXNoID0gZnVuY3Rpb24odGFyZ2V0LCBtZXNzYWdlKXtcblx0XHRpZighaW52YWxpZENoYW5uZWxOYW1lKHRhcmdldCkgJiYgIWludmFsaWRNZXNzYWdlVHlwZShtZXNzYWdlKSAmJiAodHlwZW9mIGNoYW5uZWxTdWJzY3JpYmVyc1t0YXJnZXRdICE9ICd1bmRlZmluZWQnKSl7XG5cdFx0XHRjb21wYWN0QW5kU3RvcmUodGFyZ2V0LCBtZXNzYWdlKTtcblx0XHRcdHNldFRpbWVvdXQoZGlzcGF0Y2hOZXh0LCAwKTtcblx0XHRcdHJldHVybiBjaGFubmVsU3Vic2NyaWJlcnNbdGFyZ2V0XS5sZW5ndGg7XG5cdFx0fSBlbHNle1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBzdWJzY3JpYmVcblx0ICogICAgICBTdWJzY3JpYmUgLyBhZGQgYSB7RnVuY3Rpb259IGNhbGxCYWNrIG9uIGEge1N0cmluZ3xOdW1iZXJ9dGFyZ2V0IGNoYW5uZWwgc3Vic2NyaWJlcnMgbGlzdCBpbiBvcmRlciB0byByZWNlaXZlXG5cdCAqICAgICAgbWVzc2FnZXMgcHVibGlzaGVkIGlmIHRoZSBjb25kaXRpb25zIGRlZmluZWQgYnkge0Z1bmN0aW9ufXdhaXRGb3JNb3JlIGFuZCB7RnVuY3Rpb259ZmlsdGVyIGFyZSBwYXNzZWQuXG5cdCAqXG5cdCAqIEBwYXJhbXMge1N0cmluZ3xOdW1iZXJ9dGFyZ2V0LCB7RnVuY3Rpb259Y2FsbEJhY2ssIHtGdW5jdGlvbn13YWl0Rm9yTW9yZSwge0Z1bmN0aW9ufWZpbHRlclxuXHQgKlxuXHQgKiAgICAgICAgICB0YXJnZXQgICAgICAtIGNoYW5uZWwgbmFtZSB0byBzdWJzY3JpYmVcblx0ICogICAgICAgICAgY2FsbGJhY2sgICAgLSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhIG1lc3NhZ2Ugd2FzIHB1Ymxpc2hlZCBvbiB0aGUgY2hhbm5lbFxuXHQgKiAgICAgICAgICB3YWl0Rm9yTW9yZSAtIGEgaW50ZXJtZWRpYXJ5IGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYSBzdWNjZXNzZnVseSBtZXNzYWdlIGRlbGl2ZXJ5IGluIG9yZGVyXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB0byBkZWNpZGUgaWYgYSBuZXcgbWVzc2FnZXMgaXMgZXhwZWN0ZWQuLi5cblx0ICogICAgICAgICAgZmlsdGVyICAgICAgLSBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG1lc3NhZ2UgYmVmb3JlIGludm9jYXRpb24gb2YgY2FsbGJhY2sgZnVuY3Rpb24gaW4gb3JkZXIgdG8gYWxsb3dcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGV2YW50IG1lc3NhZ2UgYmVmb3JlIGVudGVyaW5nIGluIG5vcm1hbCBjYWxsYmFjayBmbG93XG5cdCAqIEByZXR1cm5cblx0ICovXG5cdHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24odGFyZ2V0LCBjYWxsQmFjaywgd2FpdEZvck1vcmUsIGZpbHRlcil7XG5cdFx0aWYoIWludmFsaWRDaGFubmVsTmFtZSh0YXJnZXQpICYmICFpbnZhbGlkRnVuY3Rpb24oY2FsbEJhY2spKXtcblx0XHRcdHZhciBzdWJzY3JpYmVyID0ge1wiY2FsbEJhY2tcIjpjYWxsQmFjaywgXCJ3YWl0Rm9yTW9yZVwiOndhaXRGb3JNb3JlLCBcImZpbHRlclwiOmZpbHRlcn07XG5cdFx0XHR2YXIgYXJyID0gY2hhbm5lbFN1YnNjcmliZXJzW3RhcmdldF07XG5cdFx0XHRpZih0eXBlb2YgYXJyID09ICd1bmRlZmluZWQnKXtcblx0XHRcdFx0YXJyID0gW107XG5cdFx0XHRcdGNoYW5uZWxTdWJzY3JpYmVyc1t0YXJnZXRdID0gYXJyO1xuXHRcdFx0fVxuXHRcdFx0YXJyLnB1c2goc3Vic2NyaWJlcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiB1bnN1YnNjcmliZVxuXHQgKiAgICAgIFVuc3Vic2NyaWJlL3JlbW92ZSB7RnVuY3Rpb259IGNhbGxCYWNrIGZyb20gdGhlIGxpc3Qgb2Ygc3Vic2NyaWJlcnMgb2YgdGhlIHtTdHJpbmd8TnVtYmVyfSB0YXJnZXQgY2hhbm5lbFxuXHQgKlxuXHQgKiBAcGFyYW1zIHtTdHJpbmd8TnVtYmVyfSB0YXJnZXQsIHtGdW5jdGlvbn0gY2FsbEJhY2ssIHtGdW5jdGlvbn0gZmlsdGVyXG5cdCAqXG5cdCAqICAgICAgICAgIHRhcmdldCAgICAgIC0gY2hhbm5lbCBuYW1lIHRvIHVuc3Vic2NyaWJlXG5cdCAqICAgICAgICAgIGNhbGxiYWNrICAgIC0gcmVmZXJlbmNlIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0aGF0IHdhcyB1c2VkIGFzIHN1YnNjcmliZVxuXHQgKiAgICAgICAgICBmaWx0ZXIgICAgICAtIHJlZmVyZW5jZSBvZiB0aGUgb3JpZ2luYWwgZmlsdGVyIGZ1bmN0aW9uXG5cdCAqIEByZXR1cm5cblx0ICovXG5cdHRoaXMudW5zdWJzY3JpYmUgPSBmdW5jdGlvbih0YXJnZXQsIGNhbGxCYWNrLCBmaWx0ZXIpe1xuXHRcdGlmKCFpbnZhbGlkRnVuY3Rpb24oY2FsbEJhY2spKXtcblx0XHRcdHZhciBnb3RpdCA9IGZhbHNlO1xuXHRcdFx0aWYoY2hhbm5lbFN1YnNjcmliZXJzW3RhcmdldF0pe1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY2hhbm5lbFN1YnNjcmliZXJzW3RhcmdldF0ubGVuZ3RoO2krKyl7XG5cdFx0XHRcdFx0dmFyIHN1YnNjcmliZXIgPSAgY2hhbm5lbFN1YnNjcmliZXJzW3RhcmdldF1baV07XG5cdFx0XHRcdFx0aWYoc3Vic2NyaWJlci5jYWxsQmFjayA9PT0gY2FsbEJhY2sgJiYgKCB0eXBlb2YgZmlsdGVyID09PSAndW5kZWZpbmVkJyB8fCBzdWJzY3JpYmVyLmZpbHRlciA9PT0gZmlsdGVyICkpe1xuXHRcdFx0XHRcdFx0Z290aXQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0c3Vic2NyaWJlci5mb3JEZWxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0c3Vic2NyaWJlci5jYWxsQmFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdHN1YnNjcmliZXIuZmlsdGVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoIWdvdGl0KXtcblx0XHRcdFx0d3ByaW50KFwiVW5hYmxlIHRvIHVuc3Vic2NyaWJlIGEgY2FsbGJhY2sgdGhhdCB3YXMgbm90IHN1YnNjcmliZWQhXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogYmxvY2tDYWxsQmFja3Ncblx0ICpcblx0ICogQHBhcmFtc1xuXHQgKiBAcmV0dXJuXG5cdCAqL1xuXHR0aGlzLmJsb2NrQ2FsbEJhY2tzID0gZnVuY3Rpb24oKXtcblx0XHRsZXZlbCsrO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiByZWxlYXNlQ2FsbEJhY2tzXG5cdCAqXG5cdCAqIEBwYXJhbXNcblx0ICogQHJldHVyblxuXHQgKi9cblx0dGhpcy5yZWxlYXNlQ2FsbEJhY2tzID0gZnVuY3Rpb24oKXtcblx0XHRsZXZlbC0tO1xuXHRcdC8vaGFjay9vcHRpbWlzYXRpb24gdG8gbm90IGZpbGwgdGhlIHN0YWNrIGluIGV4dHJlbWUgY2FzZXMgKG1hbnkgZXZlbnRzIGNhdXNlZCBieSBsb29wcyBpbiBjb2xsZWN0aW9ucyxldGMpXG5cdFx0d2hpbGUobGV2ZWwgPT09IDAgJiYgZGlzcGF0Y2hOZXh0KHRydWUpKXtcblx0XHRcdC8vbm90aGluZ1xuXHRcdH1cblxuXHRcdHdoaWxlKGxldmVsID09PSAwICYmIGNhbGxBZnRlckFsbEV2ZW50cygpKXtcbiAgICAgICAgICAgIC8vbm90aGluZ1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogYWZ0ZXJBbGxFdmVudHNcblx0ICpcblx0ICogQHBhcmFtcyB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqXG5cdCAqICAgICAgICAgIGNhbGxiYWNrIC0gZnVuY3Rpb24gdGhhdCBuZWVkcyB0byBiZSBpbnZva2VkIG9uY2UgYWxsIGV2ZW50cyBhcmUgZGVsaXZlcmVkXG5cdCAqIEByZXR1cm5cblx0ICovXG5cdHRoaXMuYWZ0ZXJBbGxFdmVudHMgPSBmdW5jdGlvbihjYWxsQmFjayl7XG5cdFx0aWYoIWludmFsaWRGdW5jdGlvbihjYWxsQmFjaykpe1xuXHRcdFx0YWZ0ZXJFdmVudHNDYWxscy5wdXNoKGNhbGxCYWNrKTtcblx0XHR9XG5cdFx0dGhpcy5ibG9ja0NhbGxCYWNrcygpO1xuXHRcdHRoaXMucmVsZWFzZUNhbGxCYWNrcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBoYXNDaGFubmVsXG5cdCAqXG5cdCAqIEBwYXJhbXMge1N0cmluZ3xOdW1iZXJ9IGNoYW5uZWxcblx0ICpcblx0ICogICAgICAgICAgY2hhbm5lbCAtIG5hbWUgb2YgdGhlIGNoYW5uZWwgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZCBpZiBwcmVzZW50XG5cdCAqIEByZXR1cm5cblx0ICovXG5cdHRoaXMuaGFzQ2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWwpe1xuXHRcdHJldHVybiAhaW52YWxpZENoYW5uZWxOYW1lKGNoYW5uZWwpICYmICh0eXBlb2YgY2hhbm5lbFN1YnNjcmliZXJzW2NoYW5uZWxdICE9ICd1bmRlZmluZWQnKSA/IHRydWUgOiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogYWRkQ2hhbm5lbFxuXHQgKlxuXHQgKiBAcGFyYW1zIHtTdHJpbmd9IGNoYW5uZWxcblx0ICpcblx0ICogICAgICAgICAgY2hhbm5lbCAtIG5hbWUgb2YgYSBjaGFubmVsIHRoYXQgbmVlZHMgdG8gYmUgY3JlYXRlZCBhbmQgYWRkZWQgdG8gc291bmRwdWJzdWIgcmVwb3NpdG9yeVxuXHQgKiBAcmV0dXJuXG5cdCAqL1xuXHR0aGlzLmFkZENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKXtcblx0XHRpZighaW52YWxpZENoYW5uZWxOYW1lKGNoYW5uZWwpICYmICF0aGlzLmhhc0NoYW5uZWwoY2hhbm5lbCkpe1xuXHRcdFx0Y2hhbm5lbFN1YnNjcmliZXJzW2NoYW5uZWxdID0gW107XG5cdFx0fVxuXHR9O1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gcHJvdGVjdGVkIHN0dWZmIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0dmFyIHNlbGYgPSB0aGlzO1xuXHQvLyBtYXAgY2hhbm5lbE5hbWUgKG9iamVjdCBsb2NhbCBpZCkgLT4gYXJyYXkgd2l0aCBzdWJzY3JpYmVyc1xuXHR2YXIgY2hhbm5lbFN1YnNjcmliZXJzID0ge307XG5cblx0Ly8gbWFwIGNoYW5uZWxOYW1lIChvYmplY3QgbG9jYWwgaWQpIC0+IHF1ZXVlIHdpdGggd2FpdGluZyBtZXNzYWdlc1xuXHR2YXIgY2hhbm5lbHNTdG9yYWdlID0ge307XG5cblx0Ly8gb2JqZWN0XG5cdHZhciB0eXBlQ29tcGFjdG9yID0ge307XG5cblx0Ly8gY2hhbm5lbCBuYW1lc1xuXHR2YXIgZXhlY3V0aW9uUXVldWUgPSBuZXcgUXVldWUoKTtcblx0dmFyIGxldmVsID0gMDtcblxuXG5cblx0LyoqXG5cdCAqIHJlZ2lzdGVyQ29tcGFjdG9yXG5cdCAqXG5cdCAqICAgICAgIEFuIGNvbXBhY3RvciB0YWtlcyBhIG5ld0V2ZW50IGFuZCBhbmQgb2xkRXZlbnQgYW5kIHJldHVybiB0aGUgb25lIHRoYXQgc3Vydml2ZXMgKG9sZEV2ZW50IGlmXG5cdCAqICBpdCBjYW4gY29tcGFjdCB0aGUgbmV3IG9uZSBvciB0aGUgbmV3RXZlbnQgaWYgY2FuJ3QgYmUgY29tcGFjdGVkKVxuXHQgKlxuXHQgKiBAcGFyYW1zIHtTdHJpbmd9IHR5cGUsIHtGdW5jdGlvbn0gY2FsbEJhY2tcblx0ICpcblx0ICogICAgICAgICAgdHlwZSAgICAgICAgLSBjaGFubmVsIG5hbWUgdG8gdW5zdWJzY3JpYmVcblx0ICogICAgICAgICAgY2FsbEJhY2sgICAgLSBoYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50IHR5cGVcblx0ICogQHJldHVyblxuXHQgKi9cblx0dGhpcy5yZWdpc3RlckNvbXBhY3RvciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxCYWNrKSB7XG5cdFx0aWYoIWludmFsaWRGdW5jdGlvbihjYWxsQmFjaykpe1xuXHRcdFx0dHlwZUNvbXBhY3Rvclt0eXBlXSA9IGNhbGxCYWNrO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogZGlzcGF0Y2hOZXh0XG5cdCAqXG5cdCAqIEBwYXJhbSBmcm9tUmVsZWFzZUNhbGxCYWNrczogaGFjayB0byBwcmV2ZW50IHRvbyBtYW55IHJlY3Vyc2l2ZSBjYWxscyBvbiByZWxlYXNlQ2FsbEJhY2tzXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBkaXNwYXRjaE5leHQoZnJvbVJlbGVhc2VDYWxsQmFja3Mpe1xuXHRcdGlmKGxldmVsID4gMCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRjb25zdCBjaGFubmVsTmFtZSA9IGV4ZWN1dGlvblF1ZXVlLmZyb250KCk7XG5cdFx0aWYodHlwZW9mIGNoYW5uZWxOYW1lICE9ICd1bmRlZmluZWQnKXtcblx0XHRcdHNlbGYuYmxvY2tDYWxsQmFja3MoKTtcblx0XHRcdHRyeXtcblx0XHRcdFx0bGV0IG1lc3NhZ2U7XG5cdFx0XHRcdGlmKCFjaGFubmVsc1N0b3JhZ2VbY2hhbm5lbE5hbWVdLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdG1lc3NhZ2UgPSBjaGFubmVsc1N0b3JhZ2VbY2hhbm5lbE5hbWVdLmZyb250KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodHlwZW9mIG1lc3NhZ2UgPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdFx0XHRcdGlmKCFjaGFubmVsc1N0b3JhZ2VbY2hhbm5lbE5hbWVdLmlzRW1wdHkoKSl7XG5cdFx0XHRcdFx0XHR3cHJpbnQoXCJDYW4ndCB1c2UgYXMgbWVzc2FnZSBpbiBhIHB1Yi9zdWIgY2hhbm5lbCB0aGlzIG9iamVjdDogXCIgKyBtZXNzYWdlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXhlY3V0aW9uUXVldWUucG9wKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYodHlwZW9mIG1lc3NhZ2UuX190cmFuc21pc2lvbkluZGV4ID09ICd1bmRlZmluZWQnKXtcblx0XHRcdFx0XHRcdG1lc3NhZ2UuX190cmFuc21pc2lvbkluZGV4ID0gMDtcblx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IGNoYW5uZWxTdWJzY3JpYmVyc1tjaGFubmVsTmFtZV0ubGVuZ3RoLTE7IGkgPj0gMCA7IGktLSl7XG5cdFx0XHRcdFx0XHRcdHZhciBzdWJzY3JpYmVyID0gIGNoYW5uZWxTdWJzY3JpYmVyc1tjaGFubmVsTmFtZV1baV07XG5cdFx0XHRcdFx0XHRcdGlmKHN1YnNjcmliZXIuZm9yRGVsZXRlID09PSB0cnVlKXtcblx0XHRcdFx0XHRcdFx0XHRjaGFubmVsU3Vic2NyaWJlcnNbY2hhbm5lbE5hbWVdLnNwbGljZShpLDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNle1xuXHRcdFx0XHRcdFx0bWVzc2FnZS5fX3RyYW5zbWlzaW9uSW5kZXgrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9UT0RPOiBmb3IgaW1tdXRhYmxlIG9iamVjdHMgaXQgd2lsbCBub3Qgd29yayBhbHNvLCBmaXggZm9yIHNoYXBlIG1vZGVsc1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBtZXNzYWdlLl9fdHJhbnNtaXNpb25JbmRleCA9PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRcdFx0XHR3cHJpbnQoXCJDYW4ndCB1c2UgYXMgbWVzc2FnZSBpbiBhIHB1Yi9zdWIgY2hhbm5lbCB0aGlzIG9iamVjdDogXCIgKyBtZXNzYWdlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Vic2NyaWJlciA9IGNoYW5uZWxTdWJzY3JpYmVyc1tjaGFubmVsTmFtZV1bbWVzc2FnZS5fX3RyYW5zbWlzaW9uSW5kZXhdO1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBzdWJzY3JpYmVyID09ICd1bmRlZmluZWQnKXtcblx0XHRcdFx0XHRcdGRlbGV0ZSBtZXNzYWdlLl9fdHJhbnNtaXNpb25JbmRleDtcblx0XHRcdFx0XHRcdGNoYW5uZWxzU3RvcmFnZVtjaGFubmVsTmFtZV0ucG9wKCk7XG5cdFx0XHRcdFx0fSBlbHNle1xuXHRcdFx0XHRcdFx0aWYoc3Vic2NyaWJlci5maWx0ZXIgPT09IG51bGwgfHwgdHlwZW9mIHN1YnNjcmliZXIuZmlsdGVyID09PSBcInVuZGVmaW5lZFwiIHx8ICghaW52YWxpZEZ1bmN0aW9uKHN1YnNjcmliZXIuZmlsdGVyKSAmJiBzdWJzY3JpYmVyLmZpbHRlcihtZXNzYWdlKSkpe1xuXHRcdFx0XHRcdFx0XHRpZighc3Vic2NyaWJlci5mb3JEZWxldGUpe1xuXHRcdFx0XHRcdFx0XHRcdHN1YnNjcmliZXIuY2FsbEJhY2sobWVzc2FnZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYoc3Vic2NyaWJlci53YWl0Rm9yTW9yZSAmJiAhaW52YWxpZEZ1bmN0aW9uKHN1YnNjcmliZXIud2FpdEZvck1vcmUpICYmICFzdWJzY3JpYmVyLndhaXRGb3JNb3JlKG1lc3NhZ2UpKXtcblx0XHRcdFx0XHRcdFx0XHRcdHN1YnNjcmliZXIuZm9yRGVsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goZXJyKXtcblx0XHRcdFx0d3ByaW50KFwiRXZlbnQgY2FsbGJhY2sgZmFpbGVkOiBcIisgc3Vic2NyaWJlci5jYWxsQmFjayArXCJlcnJvcjogXCIgKyBlcnIuc3RhY2spO1xuXHRcdFx0fVxuXHRcdFx0Ly9cblx0XHRcdGlmKGZyb21SZWxlYXNlQ2FsbEJhY2tzKXtcblx0XHRcdFx0bGV2ZWwtLTtcblx0XHRcdH0gZWxzZXtcblx0XHRcdFx0c2VsZi5yZWxlYXNlQ2FsbEJhY2tzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2V7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGFjdEFuZFN0b3JlKHRhcmdldCwgbWVzc2FnZSl7XG5cdFx0dmFyIGdvdENvbXBhY3RlZCA9IGZhbHNlO1xuXHRcdHZhciBhcnIgPSBjaGFubmVsc1N0b3JhZ2VbdGFyZ2V0XTtcblx0XHRpZih0eXBlb2YgYXJyID09ICd1bmRlZmluZWQnKXtcblx0XHRcdGFyciA9IG5ldyBRdWV1ZSgpO1xuXHRcdFx0Y2hhbm5lbHNTdG9yYWdlW3RhcmdldF0gPSBhcnI7XG5cdFx0fVxuXG5cdFx0aWYobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZS50eXBlICE9ICd1bmRlZmluZWQnKXtcblx0XHRcdHZhciB0eXBlQ29tcGFjdG9yQ2FsbEJhY2sgPSB0eXBlQ29tcGFjdG9yW21lc3NhZ2UudHlwZV07XG5cblx0XHRcdGlmKHR5cGVvZiB0eXBlQ29tcGFjdG9yQ2FsbEJhY2sgIT0gJ3VuZGVmaW5lZCcpe1xuXHRcdFx0XHRmb3IobGV0IGNoYW5uZWwgb2YgYXJyKSB7XG5cdFx0XHRcdFx0aWYodHlwZUNvbXBhY3RvckNhbGxCYWNrKG1lc3NhZ2UsIGNoYW5uZWwpID09PSBjaGFubmVsKSB7XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YgY2hhbm5lbC5fX3RyYW5zbWlzaW9uSW5kZXggPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdFx0Z290Q29tcGFjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoIWdvdENvbXBhY3RlZCAmJiBtZXNzYWdlKXtcblx0XHRcdGFyci5wdXNoKG1lc3NhZ2UpO1xuXHRcdFx0ZXhlY3V0aW9uUXVldWUucHVzaCh0YXJnZXQpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBhZnRlckV2ZW50c0NhbGxzID0gbmV3IFF1ZXVlKCk7XG5cdGZ1bmN0aW9uIGNhbGxBZnRlckFsbEV2ZW50cyAoKXtcblx0XHRpZighYWZ0ZXJFdmVudHNDYWxscy5pc0VtcHR5KCkpe1xuXHRcdFx0dmFyIGNhbGxCYWNrID0gYWZ0ZXJFdmVudHNDYWxscy5wb3AoKTtcblx0XHRcdC8vZG8gbm90IGNhdGNoIGV4Y2VwdGlvbnMgaGVyZS4uXG5cdFx0XHRjYWxsQmFjaygpO1xuXHRcdH1cblx0XHRyZXR1cm4gIWFmdGVyRXZlbnRzQ2FsbHMuaXNFbXB0eSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW52YWxpZENoYW5uZWxOYW1lKG5hbWUpe1xuXHRcdHZhciByZXN1bHQgPSBmYWxzZTtcblx0XHRpZighbmFtZSB8fCAodHlwZW9mIG5hbWUgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgbmFtZSAhPSBcIm51bWJlclwiKSl7XG5cdFx0XHRyZXN1bHQgPSB0cnVlO1xuXHRcdFx0d3ByaW50KFwiSW52YWxpZCBjaGFubmVsIG5hbWU6IFwiICsgbmFtZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmFsaWRNZXNzYWdlVHlwZShtZXNzYWdlKXtcblx0XHR2YXIgcmVzdWx0ID0gZmFsc2U7XG5cdFx0aWYoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT0gXCJvYmplY3RcIil7XG5cdFx0XHRyZXN1bHQgPSB0cnVlO1xuXHRcdFx0d3ByaW50KFwiSW52YWxpZCBtZXNzYWdlcyB0eXBlczogXCIgKyBtZXNzYWdlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmFsaWRGdW5jdGlvbihjYWxsYmFjayl7XG5cdFx0dmFyIHJlc3VsdCA9IGZhbHNlO1xuXHRcdGlmKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdHJlc3VsdCA9IHRydWU7XG5cdFx0XHR3cHJpbnQoXCJFeHBlY3RlZCB0byBiZSBmdW5jdGlvbiBidXQgaXM6IFwiICsgY2FsbGJhY2spO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59XG5cbmV4cG9ydHMuc291bmRQdWJTdWIgPSBuZXcgU291bmRQdWJTdWIoKTsiLCJmdW5jdGlvbiBwcm9kdWN0KGFyZ3MpIHtcbiAgICBpZighYXJncy5sZW5ndGgpe1xuICAgICAgICByZXR1cm4gWyBbXSBdO1xuICAgIH1cbiAgICB2YXIgcHJvZCA9IHByb2R1Y3QoYXJncy5zbGljZSgxKSksIHIgPSBbXTtcbiAgICBhcmdzWzBdLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICBwcm9kLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgci5wdXNoKFsgeCBdLmNvbmNhdChwKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBvYmplY3RQcm9kdWN0KG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKSxcbiAgICAgICAgdmFsdWVzID0ga2V5cy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gb2JqW3hdOyB9KTtcblxuICAgIHJldHVybiBwcm9kdWN0KHZhbHVlcykubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGUgPSB7fTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGssIG4pIHsgZVtrXSA9IHBbbl07IH0pO1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RQcm9kdWN0OyIsInZhciBtZXRhID0gXCJtZXRhXCI7XG5cbmZ1bmN0aW9uIE93TShzZXJpYWxpemVkKXtcblxuICAgIGlmKHNlcmlhbGl6ZWQpe1xuICAgICAgICByZXR1cm4gT3dNLnByb3RvdHlwZS5jb252ZXJ0KHNlcmlhbGl6ZWQpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBtZXRhLCB7XG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRNZXRhXCIsIHtcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOmZhbHNlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24ocHJvcCwgdmFsdWUpe1xuICAgICAgICAgICAgaWYodHlwZW9mIHByb3AgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBwIGluIHByb3Ape1xuICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGFdW3BdID0gcHJvcFtwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW21ldGFdW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldE1ldGFcIiwge1xuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihwcm9wKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW21ldGFdW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRlc3RPd01TZXJpYWxpemF0aW9uKG9iail7XG4gICAgbGV0IHJlcyA9IGZhbHNlO1xuXG4gICAgaWYob2JqKXtcbiAgICAgICAgcmVzID0gdHlwZW9mIG9ialttZXRhXSAhPSBcInVuZGVmaW5lZFwiICYmICEob2JqIGluc3RhbmNlb2YgT3dNKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5Pd00ucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbihzZXJpYWxpemVkKXtcbiAgICBjb25zdCBvd20gPSBuZXcgT3dNKCk7XG5cbiAgICBmb3IodmFyIG1ldGFQcm9wIGluIHNlcmlhbGl6ZWQubWV0YSl7XG4gICAgICAgIGlmKCF0ZXN0T3dNU2VyaWFsaXphdGlvbihzZXJpYWxpemVkW21ldGFQcm9wXSkpIHtcbiAgICAgICAgICAgIG93bS5zZXRNZXRhKG1ldGFQcm9wLCBzZXJpYWxpemVkLm1ldGFbbWV0YVByb3BdKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvd20uc2V0TWV0YShtZXRhUHJvcCwgT3dNLnByb3RvdHlwZS5jb252ZXJ0KHNlcmlhbGl6ZWQubWV0YVttZXRhUHJvcF0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcih2YXIgc2ltcGxlUHJvcCBpbiBzZXJpYWxpemVkKXtcbiAgICAgICAgaWYoc2ltcGxlUHJvcCA9PT0gbWV0YSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGVzdE93TVNlcmlhbGl6YXRpb24oc2VyaWFsaXplZFtzaW1wbGVQcm9wXSkpe1xuICAgICAgICAgICAgb3dtW3NpbXBsZVByb3BdID0gc2VyaWFsaXplZFtzaW1wbGVQcm9wXTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvd21bc2ltcGxlUHJvcF0gPSBPd00ucHJvdG90eXBlLmNvbnZlcnQoc2VyaWFsaXplZFtzaW1wbGVQcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3dtO1xufTtcblxuT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSl7XG4gICAgdmFyIHJlcztcbiAgICBpZighbmFtZSl7XG4gICAgICAgIHJlcyA9IG9ialttZXRhXTtcbiAgICB9ZWxzZXtcbiAgICAgICAgcmVzID0gb2JqW21ldGFdW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuT3dNLnByb3RvdHlwZS5zZXRNZXRhRm9yID0gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSl7XG4gICAgb2JqW21ldGFdW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIG9ialttZXRhXVtuYW1lXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3dNOyIsImZ1bmN0aW9uIFF1ZXVlRWxlbWVudChjb250ZW50KSB7XG5cdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdHRoaXMubmV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKCkge1xuXHR0aGlzLmhlYWQgPSBudWxsO1xuXHR0aGlzLnRhaWwgPSBudWxsO1xuXHR0aGlzLmxlbmd0aCA9IDA7XG5cdHRoaXMucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGNvbnN0IG5ld0VsZW1lbnQgPSBuZXcgUXVldWVFbGVtZW50KHZhbHVlKTtcblx0XHRpZiAoIXRoaXMuaGVhZCkge1xuXHRcdFx0dGhpcy5oZWFkID0gbmV3RWxlbWVudDtcblx0XHRcdHRoaXMudGFpbCA9IG5ld0VsZW1lbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudGFpbC5uZXh0ID0gbmV3RWxlbWVudDtcblx0XHRcdHRoaXMudGFpbCA9IG5ld0VsZW1lbnQ7XG5cdFx0fVxuXHRcdHRoaXMubGVuZ3RoKys7XG5cdH07XG5cblx0dGhpcy5wb3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmhlYWQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRjb25zdCBoZWFkQ29weSA9IHRoaXMuaGVhZDtcblx0XHR0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcblx0XHR0aGlzLmxlbmd0aC0tO1xuXG5cdFx0Ly9maXg/Pz8/Pz8/XG5cdFx0aWYodGhpcy5sZW5ndGggPT09IDApe1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGVhZENvcHkuY29udGVudDtcblx0fTtcblxuXHR0aGlzLmZyb250ID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmhlYWQgPyB0aGlzLmhlYWQuY29udGVudCA6IHVuZGVmaW5lZDtcblx0fTtcblxuXHR0aGlzLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGVhZCA9PT0gbnVsbDtcblx0fTtcblxuXHR0aGlzW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuXHRcdGxldCBoZWFkID0gdGhpcy5oZWFkO1xuXHRcdHdoaWxlKGhlYWQgIT09IG51bGwpIHtcblx0XHRcdHlpZWxkIGhlYWQuY29udGVudDtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0fVxuXHR9LmJpbmQodGhpcyk7XG59XG5cblF1ZXVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0bGV0IHN0cmluZ2lmaWVkUXVldWUgPSAnJztcblx0bGV0IGl0ZXJhdG9yID0gdGhpcy5oZWFkO1xuXHR3aGlsZSAoaXRlcmF0b3IpIHtcblx0XHRzdHJpbmdpZmllZFF1ZXVlICs9IGAke0pTT04uc3RyaW5naWZ5KGl0ZXJhdG9yLmNvbnRlbnQpfSBgO1xuXHRcdGl0ZXJhdG9yID0gaXRlcmF0b3IubmV4dDtcblx0fVxuXHRyZXR1cm4gc3RyaW5naWZpZWRRdWV1ZTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5pbnNwZWN0ID0gUXVldWUucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlOyIsImNvbnN0IE93TSA9IHJlcXVpcmUoXCIuL093TVwiKTtcblxuLypcbiAgICBQcmVwYXJlIHRoZSBzdGF0ZSBvZiBhIHN3YXJtIHRvIGJlIHNlcmlhbGlzZWRcbiovXG5cbmV4cG9ydHMuYXNKU09OID0gZnVuY3Rpb24odmFsdWVPYmosIHBoYXNlTmFtZSwgYXJncywgY2FsbGJhY2spe1xuXG4gICAgICAgIGxldCB2YWx1ZU9iamVjdCA9IHZhbHVlT2JqLnZhbHVlT2YoKTtcbiAgICAgICAgbGV0IHJlcyA9IG5ldyBPd00oKTtcbiAgICAgICAgcmVzLnB1YmxpY1ZhcnMgICAgICAgICAgPSB2YWx1ZU9iamVjdC5wdWJsaWNWYXJzO1xuICAgICAgICByZXMucHJpdmF0ZVZhcnMgICAgICAgICA9IHZhbHVlT2JqZWN0LnByaXZhdGVWYXJzO1xuXG4gICAgICAgIHJlcy5zZXRNZXRhKFwic3dhcm1UeXBlTmFtZVwiLCBPd00ucHJvdG90eXBlLmdldE1ldGFGcm9tKHZhbHVlT2JqZWN0LCBcInN3YXJtVHlwZU5hbWVcIikpO1xuICAgICAgICByZXMuc2V0TWV0YShcInN3YXJtSWRcIiwgICAgICAgT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSh2YWx1ZU9iamVjdCwgXCJzd2FybUlkXCIpKTtcbiAgICAgICAgcmVzLnNldE1ldGEoXCJ0YXJnZXRcIiwgICAgICAgIE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20odmFsdWVPYmplY3QsIFwidGFyZ2V0XCIpKTtcbiAgICAgICAgcmVzLnNldE1ldGEoXCJob21lU2VjdXJpdHlDb250ZXh0XCIsICAgICAgICBPd00ucHJvdG90eXBlLmdldE1ldGFGcm9tKHZhbHVlT2JqZWN0LCBcImhvbWVTZWN1cml0eUNvbnRleHRcIikpO1xuICAgICAgICByZXMuc2V0TWV0YShcInJlcXVlc3RJZFwiLCAgICAgICAgT3dNLnByb3RvdHlwZS5nZXRNZXRhRnJvbSh2YWx1ZU9iamVjdCwgXCJyZXF1ZXN0SWRcIikpO1xuXG4gICAgICAgIGlmKCFwaGFzZU5hbWUpe1xuICAgICAgICAgICAgcmVzLnNldE1ldGEoXCJjb21tYW5kXCIsIFwic3RvcmVkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnNldE1ldGEoXCJwaGFzZU5hbWVcIiwgcGhhc2VOYW1lKTtcbiAgICAgICAgICAgIHJlcy5zZXRNZXRhKFwicGhhc2VJZFwiLCAkJC51aWRHZW5lcmF0b3Iuc2FmZV91dWlkKCkpO1xuICAgICAgICAgICAgcmVzLnNldE1ldGEoXCJhcmdzXCIsIGFyZ3MpO1xuICAgICAgICAgICAgcmVzLnNldE1ldGEoXCJjb21tYW5kXCIsIE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20odmFsdWVPYmplY3QsIFwiY29tbWFuZFwiKSB8fCBcImV4ZWN1dGVTd2FybVBoYXNlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLnNldE1ldGEoXCJ3YWl0U3RhY2tcIiwgdmFsdWVPYmplY3QubWV0YS53YWl0U3RhY2spOyAvL1RPRE86IHRoaW5rIGlmIGlzIG5vdCBiZXR0ZXIgdG8gYmUgZGVlcCBjbG9uZWQgYW5kIG5vdCByZWZlcmVuY2VkISEhXG5cbiAgICAgICAgaWYoY2FsbGJhY2spe1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImFzSlNPTjpcIiwgcmVzLCB2YWx1ZU9iamVjdCk7XG4gICAgICAgIHJldHVybiByZXM7XG59O1xuXG5leHBvcnRzLmpzb25Ub05hdGl2ZSA9IGZ1bmN0aW9uKHNlcmlhbGlzZWRWYWx1ZXMsIHJlc3VsdCl7XG5cbiAgICBmb3IobGV0IHYgaW4gc2VyaWFsaXNlZFZhbHVlcy5wdWJsaWNWYXJzKXtcbiAgICAgICAgcmVzdWx0LnB1YmxpY1ZhcnNbdl0gPSBzZXJpYWxpc2VkVmFsdWVzLnB1YmxpY1ZhcnNbdl07XG5cbiAgICB9O1xuICAgIGZvcihsZXQgbCBpbiBzZXJpYWxpc2VkVmFsdWVzLnByaXZhdGVWYXJzKXtcbiAgICAgICAgcmVzdWx0LnByaXZhdGVWYXJzW2xdID0gc2VyaWFsaXNlZFZhbHVlcy5wcml2YXRlVmFyc1tsXTtcbiAgICB9O1xuXG4gICAgZm9yKGxldCBpIGluIE93TS5wcm90b3R5cGUuZ2V0TWV0YUZyb20oc2VyaWFsaXNlZFZhbHVlcykpe1xuICAgICAgICBPd00ucHJvdG90eXBlLnNldE1ldGFGb3IocmVzdWx0LCBpLCBPd00ucHJvdG90eXBlLmdldE1ldGFGcm9tKHNlcmlhbGlzZWRWYWx1ZXMsIGkpKTtcbiAgICB9O1xuXG59OyIsInZhciBjb21tYW5kcyA9IHt9O1xudmFyIGNvbW1hbmRzX2hlbHAgPSB7fTtcblxuLy9nbG9iYWwgZnVuY3Rpb24gYWRkQ29tbWFuZFxuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uIGFkZENvbW1hbmQodmVyYiwgYWR2ZXJiZSwgZnVuY3QsIGhlbHBMaW5lKXtcbiAgICB2YXIgY21kSWQ7XG4gICAgaWYoIWhlbHBMaW5lKXtcbiAgICAgICAgaGVscExpbmUgPSBcIiBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoZWxwTGluZSA9IFwiIFwiICsgaGVscExpbmU7XG4gICAgfVxuICAgIGlmKGFkdmVyYmUpe1xuICAgICAgICBjbWRJZCA9IHZlcmIgKyBcIiBcIiArICBhZHZlcmJlO1xuICAgICAgICBoZWxwTGluZSA9IHZlcmIgKyBcIiBcIiArICBhZHZlcmJlICsgaGVscExpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY21kSWQgPSB2ZXJiO1xuICAgICAgICBoZWxwTGluZSA9IHZlcmIgKyBoZWxwTGluZTtcbiAgICB9XG4gICAgY29tbWFuZHNbY21kSWRdID0gZnVuY3Q7XG4gICAgICAgIGNvbW1hbmRzX2hlbHBbY21kSWRdID0gaGVscExpbmU7XG59O1xuXG5mdW5jdGlvbiBkb0hlbHAoKXtcbiAgICBjb25zb2xlLmxvZyhcIkxpc3Qgb2YgY29tbWFuZHM6XCIpO1xuICAgIGZvcih2YXIgbCBpbiBjb21tYW5kc19oZWxwKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXHRcIiwgY29tbWFuZHNfaGVscFtsXSk7XG4gICAgfVxufVxuXG5hZGRDb21tYW5kKFwiLWhcIiwgbnVsbCwgZG9IZWxwLCBcIlxcdFxcdFxcdFxcdFxcdFxcdCB8anVzdCBwcmludCB0aGUgaGVscFwiKTtcbmFkZENvbW1hbmQoXCIvP1wiLCBudWxsLCBkb0hlbHAsIFwiXFx0XFx0XFx0XFx0XFx0XFx0IHxqdXN0IHByaW50IHRoZSBoZWxwXCIpO1xuYWRkQ29tbWFuZChcImhlbHBcIiwgbnVsbCwgZG9IZWxwLCBcIlxcdFxcdFxcdFxcdFxcdFxcdCB8anVzdCBwcmludCB0aGUgaGVscFwiKTtcblxuXG5mdW5jdGlvbiBydW5Db21tYW5kKCl7XG4gIHZhciBhcmd2ID0gT2JqZWN0LmFzc2lnbihbXSwgcHJvY2Vzcy5hcmd2KTtcbiAgdmFyIGNtZElkID0gbnVsbDtcbiAgdmFyIGNtZCA9IG51bGw7XG4gIGFyZ3Yuc2hpZnQoKTtcbiAgYXJndi5zaGlmdCgpO1xuXG4gIGlmKGFyZ3YubGVuZ3RoID49MSl7XG4gICAgICBjbWRJZCA9IGFyZ3ZbMF07XG4gICAgICBjbWQgPSBjb21tYW5kc1tjbWRJZF07XG4gICAgICBhcmd2LnNoaWZ0KCk7XG4gIH1cblxuXG4gIGlmKCFjbWQgJiYgYXJndi5sZW5ndGggPj0xKXtcbiAgICAgIGNtZElkID0gY21kSWQgKyBcIiBcIiArIGFyZ3ZbMF07XG4gICAgICBjbWQgPSBjb21tYW5kc1tjbWRJZF07XG4gICAgICBhcmd2LnNoaWZ0KCk7XG4gIH1cblxuICBpZighY21kKXtcbiAgICBpZihjbWRJZCl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBjb21tYW5kOiBcIiwgY21kSWQpO1xuICAgIH1cbiAgICBjbWQgPSBkb0hlbHA7XG4gIH1cblxuICBjbWQuYXBwbHkobnVsbCxhcmd2KTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBydW5Db21tYW5kXG59O1xuXG4iLCJcbmZ1bmN0aW9uIGVuY29kZShidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAucmVwbGFjZSgvXFwrL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csICcnKVxuICAgICAgICAucmVwbGFjZSgvPSskLywgJycpO1xufTtcblxuZnVuY3Rpb24gc3RhbXBXaXRoVGltZShidWYsIHNhbHQsIG1zYWx0KXtcbiAgICBpZighc2FsdCl7XG4gICAgICAgIHNhbHQgPSAxO1xuICAgIH1cbiAgICBpZighbXNhbHQpe1xuICAgICAgICBtc2FsdCA9IDE7XG4gICAgfVxuICAgIHZhciBkYXRlID0gbmV3IERhdGU7XG4gICAgdmFyIGN0ID0gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIHNhbHQpO1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICB3aGlsZShjdCA+IDAgKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNvdW50ZXJcIiwgY291bnRlciwgY3QpO1xuICAgICAgICBidWZbY291bnRlciptc2FsdF0gPSBNYXRoLmZsb29yKGN0ICUgMjU2KTtcbiAgICAgICAgY3QgPSBNYXRoLmZsb29yKGN0IC8gMjU2KTtcbiAgICAgICAgY291bnRlcisrO1xuICAgIH1cbn1cblxuLypcbiAgICBUaGUgdWlkIGNvbnRhaW5zIGFyb3VuZCAyNTYgYml0cyBvZiByYW5kb21uZXNzIGFuZCBhcmUgdW5pcXVlIGF0IHRoZSBsZXZlbCBvZiBzZWNvbmRzLiBUaGlzIFVVSUQgc2hvdWxkIGJ5IGNyeXB0b2dyYXBoaWNhbGx5IHNhZmUgKGNhbiBub3QgYmUgZ3Vlc3NlZClcblxuICAgIFdlIGdlbmVyYXRlIGEgc2FmZSBVSUQgdGhhdCBpcyBndWFyYW50ZWVkIHVuaXF1ZSAoYnkgdXNhZ2Ugb2YgYSBQUk5HIHRvIGdlbmVhdGUgMjU2IGJpdHMpIGFuZCB0aW1lIHN0YW1waW5nIHdpdGggdGhlIG51bWJlciBvZiBzZWNvbmRzIGF0IHRoZSBtb21lbnQgd2hlbiBpcyBnZW5lcmF0ZWRcbiAgICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgc2FmZSB0byB1c2UgYXQgdGhlIGxldmVsIG9mIHZlcnkgbGFyZ2UgZGlzdHJpYnV0ZWQgc3lzdGVtcy5cbiAgICBUaGUgVVVJRCBpcyBzdGFtcGVkIHdpdGggdGltZSAoc2Vjb25kcyk6IGRvZXMgaXQgb3BlbiBhIHdheSB0byBndWVzcyB0aGUgVVVJRD8gSXQgZGVwZW5kcyBob3cgc2FmZSBpcyBcImNyeXB0b1wiIFBSTkcsIGJ1dCBpdCBzaG91bGQgYmUgbm8gcHJvYmxlbS4uLlxuXG4gKi9cblxudmFyIGdlbmVyYXRlVWlkID0gbnVsbDtcblxuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbihleHRlcm5hbEdlbmVyYXRvcil7XG4gICAgZ2VuZXJhdGVVaWQgPSBleHRlcm5hbEdlbmVyYXRvci5nZW5lcmF0ZVVpZDtcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59O1xuXG5leHBvcnRzLnNhZmVfdXVpZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWYgPSBnZW5lcmF0ZVVpZCgzMik7XG4gICAgc3RhbXBXaXRoVGltZShidWYsIDEwMDAsIDMpO1xuICAgIHJldHVybiBlbmNvZGUoYnVmKTtcbn07XG5cblxuXG4vKlxuICAgIFRyeSB0byBnZW5lcmF0ZSBhIHNtYWxsIFVJRCB0aGF0IGlzIHVuaXF1ZSBhZ2FpbnN0IGNoYW5jZSBpbiB0aGUgc2FtZSBtaWxsaXNlY29uZCBzZWNvbmQgYW5kIGluIGEgc3BlY2lmaWMgY29udGV4dCAoZWcgaW4gdGhlIHNhbWUgY2hvcmVvZ3JhcGh5IGV4ZWN1dGlvbilcbiAgICBUaGUgaWQgY29udGFpbnMgYXJvdW5kIDYqOCA9IDQ4ICBiaXRzIG9mIHJhbmRvbW5lc3MgYW5kIGFyZSB1bmlxdWUgYXQgdGhlIGxldmVsIG9mIG1pbGxpc2Vjb25kc1xuICAgIFRoaXMgbWV0aG9kIGlzIHNhZmUgb24gYSBzaW5nbGUgY29tcHV0ZXIgYnV0IHNob3VsZCBiZSB1c2VkIHdpdGggY2FyZSBvdGhlcndpc2VcbiAgICBUaGlzIFVVSUQgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHNhZmUgKGNhbiBiZSBndWVzc2VkKVxuICovXG5leHBvcnRzLnNob3J0X3V1aWQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzKDEyLCBmdW5jdGlvbiAoZXJyLCBidWYpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFtcFdpdGhUaW1lKGJ1ZiwxLDIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBlbmNvZGUoYnVmKSk7XG4gICAgfSk7XG59OyIsImNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgUXVldWUgPSByZXF1aXJlKFwiLi9RdWV1ZVwiKTtcbnZhciBQU0tCdWZmZXIgPSB0eXBlb2YgJCQgIT09IFwidW5kZWZpbmVkXCIgJiYgJCQuUFNLQnVmZmVyID8gJCQuUFNLQnVmZmVyIDogQnVmZmVyO1xuXG5mdW5jdGlvbiBVaWRHZW5lcmF0b3IobWluQnVmZmVycywgYnVmZmVyc1NpemUpIHtcblx0dmFyIGJ1ZmZlcnMgPSBuZXcgUXVldWUoKTtcblx0dmFyIGxvd0xpbWl0ID0gLjI7XG5cblx0ZnVuY3Rpb24gZmlsbEJ1ZmZlcnMoc2l6ZSl7XG5cdFx0Ly9ub3RpZnlPYnNlcnZlcigpO1xuXHRcdGNvbnN0IHN6ID0gc2l6ZSB8fCBtaW5CdWZmZXJzO1xuXHRcdGlmKGJ1ZmZlcnMubGVuZ3RoIDwgTWF0aC5mbG9vcihtaW5CdWZmZXJzKmxvd0xpbWl0KSl7XG5cdFx0XHRmb3IodmFyIGk9MCtidWZmZXJzLmxlbmd0aDsgaSA8IHN6OyBpKyspe1xuXHRcdFx0XHRnZW5lcmF0ZU9uZUJ1ZmZlcihudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmaWxsQnVmZmVycygpO1xuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlT25lQnVmZmVyKGIpe1xuXHRcdGlmKCFiKXtcblx0XHRcdGIgPSBQU0tCdWZmZXIuYWxsb2MoMCk7XG5cdFx0fVxuXHRcdGNvbnN0IHN6ID0gYnVmZmVyc1NpemUgLSBiLmxlbmd0aDtcblx0XHQvKmNyeXB0by5yYW5kb21CeXRlcyhzeiwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG5cdFx0XHRidWZmZXJzLnB1c2goQnVmZmVyLmNvbmNhdChbcmVzLCBiXSkpO1xuXHRcdFx0bm90aWZ5T2JzZXJ2ZXIoKTtcblx0XHR9KTsqL1xuXHRcdGJ1ZmZlcnMucHVzaChQU0tCdWZmZXIuY29uY2F0KFsgY3J5cHRvLnJhbmRvbUJ5dGVzKHN6KSwgYiBdKSk7XG5cdFx0bm90aWZ5T2JzZXJ2ZXIoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dHJhY3ROKG4pe1xuXHRcdHZhciBzeiA9IE1hdGguZmxvb3IobiAvIGJ1ZmZlcnNTaXplKTtcblx0XHR2YXIgcmV0ID0gW107XG5cblx0XHRmb3IodmFyIGk9MDsgaTxzejsgaSsrKXtcblx0XHRcdHJldC5wdXNoKGJ1ZmZlcnMucG9wKCkpO1xuXHRcdFx0c2V0VGltZW91dChnZW5lcmF0ZU9uZUJ1ZmZlciwgMSk7XG5cdFx0fVxuXG5cblxuXHRcdHZhciByZW1haW5kZXIgPSBuICUgYnVmZmVyc1NpemU7XG5cdFx0aWYocmVtYWluZGVyID4gMCl7XG5cdFx0XHR2YXIgZnJvbnQgPSBidWZmZXJzLnBvcCgpO1xuXHRcdFx0cmV0LnB1c2goZnJvbnQuc2xpY2UoMCxyZW1haW5kZXIpKTtcblx0XHRcdC8vZ2VuZXJhdGVPbmVCdWZmZXIoZnJvbnQuc2xpY2UocmVtYWluZGVyKSk7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGdlbmVyYXRlT25lQnVmZmVyKGZyb250LnNsaWNlKHJlbWFpbmRlcikpO1xuXHRcdFx0fSwxKTtcblx0XHR9XG5cblx0XHQvL3NldFRpbWVvdXQoZmlsbEJ1ZmZlcnMsIDEpO1xuXG5cdFx0cmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KTtcblx0fVxuXG5cdHZhciBmaWxsSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG5cdHRoaXMuZ2VuZXJhdGVVaWQgPSBmdW5jdGlvbihuKXtcblx0XHR2YXIgdG90YWxTaXplID0gYnVmZmVycy5sZW5ndGggKiBidWZmZXJzU2l6ZTtcblx0XHRpZihuIDw9IHRvdGFsU2l6ZSl7XG5cdFx0XHRyZXR1cm4gZXh0cmFjdE4obik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKCFmaWxsSW5Qcm9ncmVzcyl7XG5cdFx0XHRcdGZpbGxJblByb2dyZXNzID0gdHJ1ZTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGZpbGxCdWZmZXJzKE1hdGguZmxvb3IobWluQnVmZmVycyoyLjUpKTtcblx0XHRcdFx0XHRmaWxsSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0XHR9LCAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMobik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBvYnNlcnZlcjtcblx0dGhpcy5yZWdpc3Rlck9ic2VydmVyID0gZnVuY3Rpb24ob2JzKXtcblx0XHRpZihvYnNlcnZlcil7XG5cdFx0XHRjb25zb2xlLmVycm9yKG5ldyBFcnJvcihcIk9uZSBvYnNlcnZlciBhbGxvd2VkIVwiKSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRpZih0eXBlb2Ygb2JzID09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdG9ic2VydmVyID0gb2JzO1xuXHRcdFx0XHQvL25vdGlmeU9ic2VydmVyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIG5vdGlmeU9ic2VydmVyKCl7XG5cdFx0aWYob2JzZXJ2ZXIpe1xuXHRcdFx0dmFyIHZhbHVlVG9SZXBvcnQgPSBidWZmZXJzLmxlbmd0aCpidWZmZXJzU2l6ZTtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0b2JzZXJ2ZXIobnVsbCwge1wic2l6ZVwiOiB2YWx1ZVRvUmVwb3J0fSk7XG5cdFx0XHR9LCAxMCk7XG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVVpZEdlbmVyYXRvciA9IGZ1bmN0aW9uIChtaW5CdWZmZXJzLCBidWZmZXJTaXplKSB7XG5cdHJldHVybiBuZXcgVWlkR2VuZXJhdG9yKG1pbkJ1ZmZlcnMsIGJ1ZmZlclNpemUpO1xufTtcbiIsInZhciBtcSA9ICQkLnJlcXVpcmUoXCJmb2xkZXJtcVwiKTtcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxuY29uc3QgUkVTVEFSVF9USU1FT1VUID0gNTAwO1xuY29uc3QgUkVTVEFSVF9USU1FT1VUX0xJTUlUID0gNTAwMDA7XG5cbnZhciBzYW5kYm94ZXMgPSB7fTtcbnZhciBleGl0SGFuZGxlciA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9leGl0SGFuZGxlclwiKShzYW5kYm94ZXMpO1xuXG52YXIgYm9vdFNhbmRCb3ggPSAkJC5mbG93LmRlc2NyaWJlKFwiUHJpdmF0ZVNreS5zd2FybS5lbmdpbmUuYm9vdEluTGF1bmNoZXJcIiwge1xuICAgIGJvb3Q6ZnVuY3Rpb24oc2FuZEJveCwgc3BhY2VOYW1lLCBmb2xkZXIsIGNvZGVGb2xkZXIsIGNhbGxiYWNrKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJCb290aW5nIGluIFwiLCBmb2xkZXIsIFwiIGNvbnRleHQgXCIsIHNwYWNlTmFtZSk7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayAgID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuZm9sZGVyICAgICA9IGZvbGRlcjtcbiAgICAgICAgdGhpcy5zcGFjZU5hbWUgID0gc3BhY2VOYW1lO1xuICAgICAgICB0aGlzLnNhbmRCb3ggICAgPSBzYW5kQm94O1xuICAgICAgICB0aGlzLmNvZGVGb2xkZXIgICAgPSBjb2RlRm9sZGVyO1xuICAgICAgICB0aGlzLnRpbWVvdXRNdWx0aXBsaWVyID0gMTtcblxuICAgICAgICB2YXIgdGFzayA9IHRoaXMuc2VyaWFsKHRoaXMuZW5zdXJlRm9sZGVyc0V4aXN0cyk7XG5cbiAgICAgICAgdGFzay5mb2xkZXJTaG91bGRFeGlzdChwYXRoLmpvaW4odGhpcy5mb2xkZXIsIFwibXFcIiksICAgIHRhc2sucHJvZ3Jlc3MpO1xuICAgICAgICB0YXNrLmZvbGRlclNob3VsZEV4aXN0KHBhdGguam9pbih0aGlzLmZvbGRlciwgXCJidW5kbGVzXCIpLCAgdGFzay5wcm9ncmVzcyk7XG4gICAgICAgIHRhc2suZm9sZGVyU2hvdWxkRXhpc3QocGF0aC5qb2luKHRoaXMuZm9sZGVyLCBcInRtcFwiKSwgICB0YXNrLnByb2dyZXNzKTtcbiAgICB9LFxuICAgIGZvbGRlclNob3VsZEV4aXN0OiAgZnVuY3Rpb24ocGF0aCwgcHJvZ3Jlc3Mpe1xuICAgICAgICBmcy5ta2RpcihwYXRoLCB7cmVjdXJzaXZlOiB0cnVlfSwgcHJvZ3Jlc3MpO1xuICAgIH0sXG4gICAgY29weUZvbGRlcjogZnVuY3Rpb24oc291cmNlUGF0aCwgdGFyZ2V0UGF0aCwgY2FsbGJhY2spe1xuICAgICAgICBsZXQgZnNFeHQgPSByZXF1aXJlKFwidXRpbHNcIikuZnNFeHQ7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGZzRXh0LmNvcHkoc291cmNlUGF0aCwgdGFyZ2V0UGF0aCwge292ZXJ3cml0ZTogdHJ1ZX0sIGNhbGxiYWNrKTtcbiAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBzb21ldGhpbmcuLi5cIiwgZXJyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW5zdXJlRm9sZGVyc0V4aXN0czogZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgICAgICBpZihlcnIpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGhpcy5wYXJhbGxlbCh0aGlzLnJ1bkNvZGUpO1xuICAgICAgICAgICAgdGhpcy5zYW5kQm94LmluYm91bmQgPSBtcS5jcmVhdGVRdWUocGF0aC5qb2luKHRoaXMuZm9sZGVyLCBcIm1xL2luYm91bmRcIiksIHRoaXMucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgdGhpcy5zYW5kQm94Lm91dGJvdW5kID0gbXEuY3JlYXRlUXVlKHBhdGguam9pbih0aGlzLmZvbGRlciwgXCJtcS9vdXRib3VuZFwiKSwgdGhpcy5wcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJlcGFyaW5nIHRvIGNvcHlcIiwgcGF0aC5qb2luKHRoaXMuY29kZUZvbGRlciwgXCJidW5kbGVzXCIpLCBwYXRoLnJlc29sdmUocGF0aC5qb2luKHRoaXMuZm9sZGVyLCBcImJ1bmRsZXNcIikpKTtcbiAgICAgICAgICAgIHRoaXMuY29weUZvbGRlcihwYXRoLmpvaW4odGhpcy5jb2RlRm9sZGVyLCBcImJ1bmRsZXNcIiksIHBhdGgucmVzb2x2ZShwYXRoLmpvaW4odGhpcy5mb2xkZXIsIFwiYnVuZGxlc1wiKSksIHRhc2sucHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICB9LFxuICAgIHJ1bkNvZGU6IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgICAgICAgaWYoIWVycil7XG4gICAgICAgICAgICB2YXIgbWFpbkZpbGUgPSBwYXRoLmpvaW4ocHJvY2Vzcy5lbnYuUFJJVkFURVNLWV9ST09UX0ZPTERFUiwgXCJjb3JlXCIsIFwic2FuZGJveGVzXCIsIFwiYWdlbnRTYW5kYm94LmpzXCIpO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5zcGFjZU5hbWUsIHByb2Nlc3MuZW52LlBSSVZBVEVTS1lfUk9PVF9GT0xERVIsIHBhdGgucmVzb2x2ZShwcm9jZXNzLmVudi5QUklWQVRFU0tZX0RPTUFJTl9CVUlMRCldO1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB7c3RkaW86IFswLCAxLCAyLCBcImlwY1wiXX07XG5cbiAgICAgICAgICAgIHZhciBzdGFydENoaWxkID0gKG1haW5GaWxlLCBhcmdzLCBvcHRzKSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiUnVubmluZzogXCIsIG1haW5GaWxlLCBhcmdzLCBvcHRzKTtcblxuXHRcdFx0XHQvLyBwYXNzaW5nIG9wdGlvbnMuZW52IG1pZ2h0IGJyZWFrIHRoZSBhZ2VudFNhbmRib3gsIGl0IHJlbGllcyBvbiBzb21lIGluaGVyaXRlZCBlbnYgdmFyaWFibGVzIGZyb20gZG9tYWluXG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkX3Byb2Nlc3MuZm9yayhtYWluRmlsZSwgYXJncyk7XG5cdFx0XHRcdHNhbmRib3hlc1t0aGlzLnNwYWNlTmFtZV0gPSBjaGlsZDtcblxuXHRcdFx0XHR0aGlzLnNhbmRCb3guaW5ib3VuZC5zZXRJUENDaGFubmVsKGNoaWxkKTtcblx0XHRcdFx0dGhpcy5zYW5kQm94Lm91dGJvdW5kLnNldElQQ0NoYW5uZWwoY2hpbGQpO1xuXG5cdFx0XHRcdGNoaWxkLm9uKFwiZXhpdFwiLCAoY29kZSwgc2lnbmFsKT0+e1xuXHRcdFx0XHQgICAgaWYoY29kZSA9PT0gMCl7XG5cdFx0XHRcdCAgICAgICAgY29uc29sZS5sb2coYFNhbmRib3ggPCR7dGhpcy5zcGFjZU5hbWV9PiBzaHV0dGluZyBkb3duLmApO1xuXHRcdFx0XHQgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcdFx0XHQgICAgbGV0IHRpbWVvdXQgPSAodGhpcy50aW1lb3V0TXVsdGlwbGllcipSRVNUQVJUX1RJTUVPVVQpICUgUkVTVEFSVF9USU1FT1VUX0xJTUlUO1xuXHRcdFx0XHQgICAgY29uc29sZS5sb2coYFNhbmRib3ggPCR7dGhpcy5zcGFjZU5hbWV9PiBleGl0cyB3aXRoIGNvZGUgJHtjb2RlfS4gUmVzdGFydGluZyBpbiAke3RpbWVvdXR9IG1zLmApO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoKCk9Pntcblx0XHRcdFx0XHRcdHN0YXJ0Q2hpbGQobWFpbkZpbGUsIGFyZ3MsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0TXVsdGlwbGllciAqPSAxLjU7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG51bGwsIHN0YXJ0Q2hpbGQobWFpbkZpbGUsIGFyZ3MsIG9wdHMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZXhlY3V0aW5nIHNhbmRib3ghOlwiLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuZnVuY3Rpb24gU2FuZEJveEhhbmRsZXIoc3BhY2VOYW1lLCBmb2xkZXIsIGNvZGVGb2xkZXIsIHJlc3VsdENhbGxCYWNrKXtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbXFIYW5kbGVyO1xuXG5cbiAgICBib290U2FuZEJveCgpLmJvb3QodGhpcywgc3BhY2VOYW1lLGZvbGRlciwgY29kZUZvbGRlciwgZnVuY3Rpb24oZXJyLCBjaGlsZFByb2Nlc3Mpe1xuICAgICAgICBpZighZXJyKXtcbiAgICAgICAgICAgIHNlbGYuY2hpbGRQcm9jZXNzID0gY2hpbGRQcm9jZXNzO1xuXG5cbiAgICAgICAgICAgIC8qc2VsZi5vdXRib3VuZC5yZWdpc3RlckNvbnN1bWVyKGZ1bmN0aW9uKGVyciwgc3dhcm0pe1xuICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIucHVibGlzaCgkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTiwgc3dhcm0pO1xuICAgICAgICAgICAgfSk7Ki9cblxuICAgICAgICAgICAgc2VsZi5vdXRib3VuZC5yZWdpc3RlckFzSVBDQ29uc3VtZXIoZnVuY3Rpb24oZXJyLCBzd2FybSl7XG4gICAgICAgICAgICAgICAgJCQuUFNLX1B1YlN1Yi5wdWJsaXNoKCQkLkNPTlNUQU5UUy5TV0FSTV9GT1JfRVhFQ1VUSU9OLCBzd2FybSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbXFIYW5kbGVyID0gc2VsZi5pbmJvdW5kLmdldEhhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmKHBlbmRpbmdNZXNzYWdlcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlcy5tYXAoZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VuZChpdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nTWVzc2FnZXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcGVuZGluZ01lc3NhZ2VzID0gW107XG5cbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiAoc3dhcm0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmKG1xSGFuZGxlcil7XG4gICAgICAgICAgICBtcUhhbmRsZXIuc2VuZFN3YXJtRm9yRXhlY3V0aW9uKHN3YXJtLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZXMucHVzaChzd2FybSk7IC8vVE9ETzogd2VsbCwgYSBkZWVwIGNsb25lIHdpbGwgbm90IGJlIGEgYmV0dGVyIGlkZWE/XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG5mdW5jdGlvbiBTYW5kQm94TWFuYWdlcihzYW5kYm94ZXNGb2xkZXIsIGNvZGVGb2xkZXIsIGNhbGxiYWNrKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgc2FuZEJveGVzID0ge1xuXG4gICAgfTtcbiAgICBmdW5jdGlvbiBiZWxvbmdzVG9SZXBsaWNhdGVkU3BhY2UoKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZyhcIlN1YnNjcmliaW5nIHRvOlwiLCAkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTik7XG4gICAgJCQuUFNLX1B1YlN1Yi5zdWJzY3JpYmUoJCQuQ09OU1RBTlRTLlNXQVJNX0ZPUl9FWEVDVVRJT04sIGZ1bmN0aW9uKHN3YXJtKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFeGVjdXRpbmcgaW4gc2FuZGJveCB0b3dhcmRzOiBcIiwgc3dhcm0ubWV0YS50YXJnZXQpO1xuXG4gICAgICAgIGlmKHN3YXJtLm1ldGEudGFyZ2V0ID09IFwic3lzdGVtXCIgfHwgc3dhcm0ubWV0YS5jb21tYW5kID09IFwiYXN5bmNSZXR1cm5cIil7XG4gICAgICAgICAgICAkJC5zd2FybXNJbnN0YW5jZXNNYW5hZ2VyLnJldml2ZV9zd2FybShzd2FybSk7XG4gICAgICAgICAgICAvLyQkLnN3YXJtcy5yZXN0YXJ0KHN3YXJtLm1ldGEuc3dhcm1UeXBlTmFtZSwgc3dhcm0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYoc3dhcm0ubWV0YS50YXJnZXQgPT0gXCJwZHNcIil7XG4gICAgICAgICAgICAvL1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYoYmVsb25nc1RvUmVwbGljYXRlZFNwYWNlKHN3YXJtLm1ldGEudGFyZ2V0KSl7XG4gICAgICAgICAgICBzZWxmLnB1c2hUb1NwYWNlQVN3YXJtKHN3YXJtLm1ldGEudGFyZ2V0LCBzd2FybSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RPRE86IHNlbmQgdG93YXJkcyBuZXR3b3JrXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgICBmdW5jdGlvbiBzdGFydFNhbmRCb3goc3BhY2VOYW1lKXtcbiAgICAgICAgdmFyIHNhbmRCb3ggPSBuZXcgU2FuZEJveEhhbmRsZXIoc3BhY2VOYW1lLCBwYXRoLmpvaW4oc2FuZGJveGVzRm9sZGVyLCBzcGFjZU5hbWUpLCBjb2RlRm9sZGVyKTtcbiAgICAgICAgc2FuZEJveGVzW3NwYWNlTmFtZV0gPSBzYW5kQm94O1xuICAgICAgICByZXR1cm4gc2FuZEJveDtcbiAgICB9XG5cblxuICAgIHRoaXMucHVzaFRvU3BhY2VBU3dhcm0gPSBmdW5jdGlvbihzcGFjZU5hbWUsIHN3YXJtLCBjYWxsYmFjayl7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJwdXNoVG9TcGFjZUFTd2FybSBcIiAsIHNwYWNlTmFtZSk7XG4gICAgICAgIHZhciBzYW5kYm94ID0gc2FuZEJveGVzW3NwYWNlTmFtZV07XG4gICAgICAgIGlmKCFzYW5kYm94KXtcbiAgICAgICAgICAgIHNhbmRib3ggPSBzYW5kQm94ZXNbc3BhY2VOYW1lXSA9IHN0YXJ0U2FuZEJveChzcGFjZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHNhbmRib3guc2VuZChzd2FybSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xufVxuXG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oZm9sZGVyLCBjb2RlRm9sZGVyLCBjYWxsYmFjayl7XG4gICAgbmV3IFNhbmRCb3hNYW5hZ2VyKGZvbGRlciwgY29kZUZvbGRlciwgY2FsbGJhY2spO1xufTtcblxuXG4iLCJjb25zdCBldmVudHMgPSBbXCJleGl0XCIsIFwiU0lHSU5UXCIsIFwiU0lHVVNSMVwiLCBcIlNJR1VTUjJcIiwgXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBcIlNJR1RFUk1cIiwgXCJTSUdIVVBcIl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFuYWdlU2h1dGRvd25Qcm9jZXNzKGNoaWxkcmVuTGlzdCl7XG5cbiAgICBsZXQgc2h1dHRpbmcgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKCl7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJIYW5kbGluZyBleGl0IGV2ZW50IG9uXCIsIHByb2Nlc3MucGlkLCBcImFyZ3VtZW50czpcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuTmFtZXMgPSBPYmplY3Qua2V5cyhjaGlsZHJlbkxpc3QpO1xuICAgICAgICBmb3IobGV0IGo9MDsgajxjaGlsZHJlbk5hbWVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuTGlzdFtjaGlsZHJlbk5hbWVzW2pdXTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYFske3Byb2Nlc3MucGlkfV1gLCBcIlNlbmRpbmcga2lsbCBzaWduYWwgdG8gUElEOlwiLCBjaGlsZC5waWQpO1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIHByb2Nlc3Mua2lsbChjaGlsZC5waWQpO1xuICAgICAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICAgICAgLy8uLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFzaHV0dGluZyl7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQuY3Vyc29yVG8oMCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFtQSUQ6ICR7cHJvY2Vzcy5waWR9XSBbVGltZXN0YW1wOiAke25ldyBEYXRlKCkuZ2V0VGltZSgpfV0gW1Byb2Nlc3MgYXJndjogJHtwcm9jZXNzLmFyZ3Z9XS0gU2h1dHRpbmcgZG93bi4uLlxcbmApO1xuICAgICAgICAgICAgfWNhdGNoKGVycilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLy4uLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2h1dHRpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLnN0ZGluLnJlc3VtZSgpO1xuICAgIGZvcihsZXQgaT0wOyBpPGV2ZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBldmVudHNbaV07XG4gICAgICAgIHByb2Nlc3Mub24oZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhcIkV4aXQgaGFuZGxlciBzZXR1cCFcIiwgYFske3Byb2Nlc3MucGlkfV1gKTtcbn07IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5NZXNzYWdlUGFjaz10KCk6ZS5NZXNzYWdlUGFjaz10KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz0wKX0oW2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtyLnIodCk7dmFyIG49ZnVuY3Rpb24oZSx0KXt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighcilyZXR1cm4gZTt2YXIgbixpLG89ci5jYWxsKGUpLHM9W107dHJ5e2Zvcig7KHZvaWQgMD09PXR8fHQtLSA+MCkmJiEobj1vLm5leHQoKSkuZG9uZTspcy5wdXNoKG4udmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e24mJiFuLmRvbmUmJihyPW8ucmV0dXJuKSYmci5jYWxsKG8pfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gc30saT1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllPWUuY29uY2F0KG4oYXJndW1lbnRzW3RdKSk7cmV0dXJuIGV9LG89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHRFbmNvZGVyJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI7ZnVuY3Rpb24gcyhlKXtmb3IodmFyIHQ9ZS5sZW5ndGgscj0wLG49MDtuPHQ7KXt2YXIgaT1lLmNoYXJDb2RlQXQobisrKTtpZigwIT0oNDI5NDk2NzE2OCZpKSlpZigwPT0oNDI5NDk2NTI0OCZpKSlyKz0yO2Vsc2V7aWYoaT49NTUyOTYmJmk8PTU2MzE5JiZuPHQpe3ZhciBvPWUuY2hhckNvZGVBdChuKTs1NjMyMD09KDY0NTEyJm8pJiYoKytuLGk9KCgxMDIzJmkpPDwxMCkrKDEwMjMmbykrNjU1MzYpfXIrPTA9PSg0Mjk0OTAxNzYwJmkpPzM6NH1lbHNlIHIrK31yZXR1cm4gcn12YXIgYT1vP25ldyBUZXh0RW5jb2Rlcjp2b2lkIDA7dmFyIHU9YSYmYS5lbmNvZGVJbnRvP2Z1bmN0aW9uKGUsdCxyKXthLmVuY29kZUludG8oZSx0LnN1YmFycmF5KHIpKX06ZnVuY3Rpb24oZSx0LHIpe3Quc2V0KGEuZW5jb2RlKGUpLHIpfSxoPTY1NTM2O3ZhciBjPW8/bmV3IFRleHREZWNvZGVyOm51bGw7dmFyIGY9ZnVuY3Rpb24oZSx0KXt0aGlzLnR5cGU9ZSx0aGlzLmRhdGE9dH07ZnVuY3Rpb24gbChlLHQscil7dmFyIG49TWF0aC5mbG9vcihyLzQyOTQ5NjcyOTYpLGk9cjtlLnNldFVpbnQzMih0LG4pLGUuc2V0VWludDMyKHQrNCxpKX1mdW5jdGlvbiBwKGUsdCl7cmV0dXJuIDQyOTQ5NjcyOTYqZS5nZXRJbnQzMih0KStlLmdldFVpbnQzMih0KzQpfXZhciBkPTQyOTQ5NjcyOTUseT0xNzE3OTg2OTE4MztmdW5jdGlvbiB3KGUpe3ZhciB0PWUuc2VjLHI9ZS5uc2VjO2lmKHQ+PTAmJnI+PTAmJnQ8PXkpe2lmKDA9PT1yJiZ0PD1kKXt2YXIgbj1uZXcgVWludDhBcnJheSg0KTtyZXR1cm4ocz1uZXcgRGF0YVZpZXcobi5idWZmZXIpKS5zZXRVaW50MzIoMCx0KSxufXZhciBpPXQvNDI5NDk2NzI5NixvPTQyOTQ5NjcyOTUmdDtuPW5ldyBVaW50OEFycmF5KDgpO3JldHVybihzPW5ldyBEYXRhVmlldyhuLmJ1ZmZlcikpLnNldFVpbnQzMigwLHI8PDJ8MyZpKSxzLnNldFVpbnQzMig0LG8pLG59dmFyIHM7bj1uZXcgVWludDhBcnJheSgxMik7cmV0dXJuKHM9bmV3IERhdGFWaWV3KG4uYnVmZmVyKSkuc2V0VWludDMyKDAsciksbChzLDQsdCksbn1mdW5jdGlvbiB2KGUpe3ZhciB0PWUuZ2V0VGltZSgpLHI9TWF0aC5mbG9vcih0LzFlMyksbj0xZTYqKHQtMWUzKnIpLGk9TWF0aC5mbG9vcihuLzFlOSk7cmV0dXJue3NlYzpyK2ksbnNlYzpuLTFlOSppfX1mdW5jdGlvbiBiKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRGF0ZT93KHYoZSkpOm51bGx9ZnVuY3Rpb24gZyhlKXt2YXIgdD1uZXcgRGF0YVZpZXcoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCk7c3dpdGNoKGUuYnl0ZUxlbmd0aCl7Y2FzZSA0OnJldHVybntzZWM6dC5nZXRVaW50MzIoMCksbnNlYzowfTtjYXNlIDg6dmFyIHI9dC5nZXRVaW50MzIoMCk7cmV0dXJue3NlYzo0Mjk0OTY3Mjk2KigzJnIpK3QuZ2V0VWludDMyKDQpLG5zZWM6cj4+PjJ9O2Nhc2UgMTI6cmV0dXJue3NlYzpwKHQsNCksbnNlYzp0LmdldFVpbnQzMigwKX07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGF0YSBzaXplIGZvciB0aW1lc3RhbXA6IFwiK2UubGVuZ3RoKX19ZnVuY3Rpb24gVShlKXt2YXIgdD1nKGUpO3JldHVybiBuZXcgRGF0ZSgxZTMqdC5zZWMrdC5uc2VjLzFlNil9dmFyIG09e3R5cGU6LTEsZW5jb2RlOmIsZGVjb2RlOlV9LHg9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy5idWlsdEluRW5jb2RlcnM9W10sdGhpcy5idWlsdEluRGVjb2RlcnM9W10sdGhpcy5lbmNvZGVycz1bXSx0aGlzLmRlY29kZXJzPVtdLHRoaXMucmVnaXN0ZXIobSl9cmV0dXJuIGUucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUudHlwZSxyPWUuZW5jb2RlLG49ZS5kZWNvZGU7aWYodD49MCl0aGlzLmVuY29kZXJzW3RdPXIsdGhpcy5kZWNvZGVyc1t0XT1uO2Vsc2V7dmFyIGk9MSt0O3RoaXMuYnVpbHRJbkVuY29kZXJzW2ldPXIsdGhpcy5idWlsdEluRGVjb2RlcnNbaV09bn19LGUucHJvdG90eXBlLnRyeVRvRW5jb2RlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8dGhpcy5idWlsdEluRW5jb2RlcnMubGVuZ3RoO3QrKyl7aWYobnVsbCE9KHI9dGhpcy5idWlsdEluRW5jb2RlcnNbdF0pKWlmKG51bGwhPShuPXIoZSkpKXJldHVybiBuZXcgZigtMS10LG4pfWZvcih0PTA7dDx0aGlzLmVuY29kZXJzLmxlbmd0aDt0Kyspe3ZhciByLG47aWYobnVsbCE9KHI9dGhpcy5lbmNvZGVyc1t0XSkpaWYobnVsbCE9KG49cihlKSkpcmV0dXJuIG5ldyBmKHQsbil9cmV0dXJuIGUgaW5zdGFuY2VvZiBmP2U6bnVsbH0sZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dDwwP3RoaXMuYnVpbHRJbkRlY29kZXJzWy0xLXRdOnRoaXMuZGVjb2RlcnNbdF07cmV0dXJuIHI/cihlLHQpOm5ldyBmKHQsZSl9LGUuZGVmYXVsdENvZGVjPW5ldyBlLGV9KCk7ZnVuY3Rpb24gUyhlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/ZTpBcnJheUJ1ZmZlci5pc1ZpZXcoZSk/bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCk6ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP25ldyBVaW50OEFycmF5KGUpOlVpbnQ4QXJyYXkuZnJvbShlKX12YXIgQT1udWxsLEU9ISFBO2Z1bmN0aW9uIEIoZSx0LHIpe3ZhciBuPWUubGVuZ3RoLGk9MipuLG89QS5tYWxsb2MoaSk7IWZ1bmN0aW9uKGUsdCxyLG4pe2Zvcih2YXIgaT1uZXcgRGF0YVZpZXcoQS5tZW1vcnkuYnVmZmVyLGUsdCksbz0wO288bjtvKyspaS5zZXRVaW50MTYoMipvLHIuY2hhckNvZGVBdChvKSl9KG8saSxlLG4pO3ZhciBzPUEubWFsbG9jKDUrNCpuKTt0cnl7dmFyIGE9QS51dGY4RW5jb2RlVWludDE2QXJyYXkocyxvLG4pO3JldHVybiB0LnNldChuZXcgVWludDhBcnJheShBLm1lbW9yeS5idWZmZXIscyxhKSxyKSxhfWZpbmFsbHl7QS5mcmVlKG8pLEEuZnJlZShzKX19dmFyIEw9NjU1MzY7ZnVuY3Rpb24gVChlLHQscil7dmFyIG4saSxvLHM9QS5tYWxsb2MociksYT1BLm1hbGxvYygyKnIpO3RyeXtuPXMsaT1lLnN1YmFycmF5KHQsdCtyKSxvPXIsbmV3IFVpbnQ4QXJyYXkoQS5tZW1vcnkuYnVmZmVyLG4sbykuc2V0KGkpO3ZhciB1PUEudXRmOERlY29kZVRvVWludDE2QXJyYXkoYSxzLHIpO3JldHVybiBmdW5jdGlvbihlKXtpZihlLmxlbmd0aDw9TClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSk7Zm9yKHZhciB0PVwiXCIscj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbj1lLnN1YmFycmF5KHIqTCwocisxKSpMKTt0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxuKX1yZXR1cm4gdH0obmV3IFVpbnQxNkFycmF5KEEubWVtb3J5LmJ1ZmZlcixhLHUpKX1maW5hbGx5e0EuZnJlZShzKSxBLmZyZWUoYSl9fXZhciBJPWZ1bmN0aW9uKGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdLHI9MDtyZXR1cm4gdD90LmNhbGwoZSk6e25leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gZSYmcj49ZS5sZW5ndGgmJihlPXZvaWQgMCkse3ZhbHVlOmUmJmVbcisrXSxkb25lOiFlfX19fSxNPTEwMCxrPTIwNDgsUD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIsbixpKXt2b2lkIDA9PT1lJiYoZT14LmRlZmF1bHRDb2RlYyksdm9pZCAwPT09dCYmKHQ9TSksdm9pZCAwPT09ciYmKHI9ayksdm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PWkmJihpPSExKSx0aGlzLmV4dGVuc2lvbkNvZGVjPWUsdGhpcy5tYXhEZXB0aD10LHRoaXMuaW5pdGlhbEJ1ZmZlclNpemU9cix0aGlzLnNvcnRLZXlzPW4sdGhpcy5mb3JjZUZsb2F0MzI9aSx0aGlzLnBvcz0wLHRoaXMudmlldz1uZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKHRoaXMuaW5pdGlhbEJ1ZmZlclNpemUpKSx0aGlzLmJ5dGVzPW5ldyBVaW50OEFycmF5KHRoaXMudmlldy5idWZmZXIpfXJldHVybiBlLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0PnRoaXMubWF4RGVwdGgpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGRlZXAgb2JqZWN0cyBpbiBkZXB0aCBcIit0KTtudWxsPT1lP3RoaXMuZW5jb2RlTmlsKCk6XCJib29sZWFuXCI9PXR5cGVvZiBlP3RoaXMuZW5jb2RlQm9vbGVhbihlKTpcIm51bWJlclwiPT10eXBlb2YgZT90aGlzLmVuY29kZU51bWJlcihlKTpcInN0cmluZ1wiPT10eXBlb2YgZT90aGlzLmVuY29kZVN0cmluZyhlKTp0aGlzLmVuY29kZU9iamVjdChlLHQpfSxlLnByb3RvdHlwZS5nZXRVaW50OEFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZXMuc3ViYXJyYXkoMCx0aGlzLnBvcyl9LGUucHJvdG90eXBlLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucG9zK2U7dGhpcy52aWV3LmJ5dGVMZW5ndGg8dCYmdGhpcy5yZXNpemVCdWZmZXIoMip0KX0sZS5wcm90b3R5cGUucmVzaXplQnVmZmVyPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheUJ1ZmZlcihlKSxyPW5ldyBVaW50OEFycmF5KHQpLG49bmV3IERhdGFWaWV3KHQpO3Iuc2V0KHRoaXMuYnl0ZXMpLHRoaXMudmlldz1uLHRoaXMuYnl0ZXM9cn0sZS5wcm90b3R5cGUuZW5jb2RlTmlsPWZ1bmN0aW9uKCl7dGhpcy53cml0ZVU4KDE5Mil9LGUucHJvdG90eXBlLmVuY29kZUJvb2xlYW49ZnVuY3Rpb24oZSl7ITE9PT1lP3RoaXMud3JpdGVVOCgxOTQpOnRoaXMud3JpdGVVOCgxOTUpfSxlLnByb3RvdHlwZS5lbmNvZGVOdW1iZXI9ZnVuY3Rpb24oZSl7TnVtYmVyLmlzU2FmZUludGVnZXIoZSk/ZT49MD9lPDEyOD90aGlzLndyaXRlVTgoZSk6ZTwyNTY/KHRoaXMud3JpdGVVOCgyMDQpLHRoaXMud3JpdGVVOChlKSk6ZTw2NTUzNj8odGhpcy53cml0ZVU4KDIwNSksdGhpcy53cml0ZVUxNihlKSk6ZTw0Mjk0OTY3Mjk2Pyh0aGlzLndyaXRlVTgoMjA2KSx0aGlzLndyaXRlVTMyKGUpKToodGhpcy53cml0ZVU4KDIwNyksdGhpcy53cml0ZVU2NChlKSk6ZT49LTMyP3RoaXMud3JpdGVVOCgyMjR8ZSszMik6ZT49LTEyOD8odGhpcy53cml0ZVU4KDIwOCksdGhpcy53cml0ZUk4KGUpKTplPj0tMzI3Njg/KHRoaXMud3JpdGVVOCgyMDkpLHRoaXMud3JpdGVJMTYoZSkpOmU+PS0yMTQ3NDgzNjQ4Pyh0aGlzLndyaXRlVTgoMjEwKSx0aGlzLndyaXRlSTMyKGUpKToodGhpcy53cml0ZVU4KDIxMSksdGhpcy53cml0ZUk2NChlKSk6dGhpcy5mb3JjZUZsb2F0MzI/KHRoaXMud3JpdGVVOCgyMDIpLHRoaXMud3JpdGVGMzIoZSkpOih0aGlzLndyaXRlVTgoMjAzKSx0aGlzLndyaXRlRjY0KGUpKX0sZS5wcm90b3R5cGUud3JpdGVTdHJpbmdIZWFkZXI9ZnVuY3Rpb24oZSl7aWYoZTwzMil0aGlzLndyaXRlVTgoMTYwK2UpO2Vsc2UgaWYoZTwyNTYpdGhpcy53cml0ZVU4KDIxNyksdGhpcy53cml0ZVU4KGUpO2Vsc2UgaWYoZTw2NTUzNil0aGlzLndyaXRlVTgoMjE4KSx0aGlzLndyaXRlVTE2KGUpO2Vsc2V7aWYoIShlPDQyOTQ5NjcyOTYpKXRocm93IG5ldyBFcnJvcihcIlRvbyBsb25nIHN0cmluZzogXCIrZStcIiBieXRlcyBpbiBVVEYtOFwiKTt0aGlzLndyaXRlVTgoMjE5KSx0aGlzLndyaXRlVTMyKGUpfX0sZS5wcm90b3R5cGUuZW5jb2RlU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKG8mJnQ+MjAwKXt2YXIgcj1zKGUpO3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNStyKSx0aGlzLndyaXRlU3RyaW5nSGVhZGVyKHIpLHUoZSx0aGlzLmJ5dGVzLHRoaXMucG9zKSx0aGlzLnBvcys9cn1lbHNle2lmKEUmJnQ+MTAyNCl7dmFyIG49NSs0KnQ7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZShuKTt2YXIgaT1CKGUsdGhpcy5ieXRlcyx0aGlzLnBvcyk7cmV0dXJuIHZvaWQodGhpcy5wb3MrPWkpfXI9cyhlKTt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDUrciksdGhpcy53cml0ZVN0cmluZ0hlYWRlcihyKSxmdW5jdGlvbihlLHQscil7Zm9yKHZhciBuPWUubGVuZ3RoLGk9cixvPTA7bzxuOyl7dmFyIHM9ZS5jaGFyQ29kZUF0KG8rKyk7aWYoMCE9KDQyOTQ5NjcxNjgmcykpe2lmKDA9PSg0Mjk0OTY1MjQ4JnMpKXRbaSsrXT1zPj42JjMxfDE5MjtlbHNle2lmKHM+PTU1Mjk2JiZzPD01NjMxOSYmbzxuKXt2YXIgYT1lLmNoYXJDb2RlQXQobyk7NTYzMjA9PSg2NDUxMiZhKSYmKCsrbyxzPSgoMTAyMyZzKTw8MTApKygxMDIzJmEpKzY1NTM2KX0wPT0oNDI5NDkwMTc2MCZzKT8odFtpKytdPXM+PjEyJjE1fDIyNCx0W2krK109cz4+NiY2M3wxMjgpOih0W2krK109cz4+MTgmN3wyNDAsdFtpKytdPXM+PjEyJjYzfDEyOCx0W2krK109cz4+NiY2M3wxMjgpfXRbaSsrXT02MyZzfDEyOH1lbHNlIHRbaSsrXT1zfX0oZSx0aGlzLmJ5dGVzLHRoaXMucG9zKSx0aGlzLnBvcys9cn19LGUucHJvdG90eXBlLmVuY29kZU9iamVjdD1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZXh0ZW5zaW9uQ29kZWMudHJ5VG9FbmNvZGUoZSk7aWYobnVsbCE9cil0aGlzLmVuY29kZUV4dGVuc2lvbihyKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpdGhpcy5lbmNvZGVBcnJheShlLHQpO2Vsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXRoaXMuZW5jb2RlQmluYXJ5KGUpO2Vsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG9iamVjdDogXCIrT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShlKSk7dGhpcy5lbmNvZGVNYXAoZSx0KX19LGUucHJvdG90eXBlLmVuY29kZUJpbmFyeT1mdW5jdGlvbihlKXt2YXIgdD1lLmJ5dGVMZW5ndGg7aWYodDwyNTYpdGhpcy53cml0ZVU4KDE5NiksdGhpcy53cml0ZVU4KHQpO2Vsc2UgaWYodDw2NTUzNil0aGlzLndyaXRlVTgoMTk3KSx0aGlzLndyaXRlVTE2KHQpO2Vsc2V7aWYoISh0PDQyOTQ5NjcyOTYpKXRocm93IG5ldyBFcnJvcihcIlRvbyBsYXJnZSBiaW5hcnk6IFwiK3QpO3RoaXMud3JpdGVVOCgxOTgpLHRoaXMud3JpdGVVMzIodCl9dmFyIHI9UyhlKTt0aGlzLndyaXRlVThhKHIpfSxlLnByb3RvdHlwZS5lbmNvZGVBcnJheT1mdW5jdGlvbihlLHQpe3ZhciByLG4saT1lLmxlbmd0aDtpZihpPDE2KXRoaXMud3JpdGVVOCgxNDQraSk7ZWxzZSBpZihpPDY1NTM2KXRoaXMud3JpdGVVOCgyMjApLHRoaXMud3JpdGVVMTYoaSk7ZWxzZXtpZighKGk8NDI5NDk2NzI5NikpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGxhcmdlIGFycmF5OiBcIitpKTt0aGlzLndyaXRlVTgoMjIxKSx0aGlzLndyaXRlVTMyKGkpfXRyeXtmb3IodmFyIG89SShlKSxzPW8ubmV4dCgpOyFzLmRvbmU7cz1vLm5leHQoKSl7dmFyIGE9cy52YWx1ZTt0aGlzLmVuY29kZShhLHQrMSl9fWNhdGNoKGUpe3I9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e3MmJiFzLmRvbmUmJihuPW8ucmV0dXJuKSYmbi5jYWxsKG8pfWZpbmFsbHl7aWYocil0aHJvdyByLmVycm9yfX19LGUucHJvdG90eXBlLmVuY29kZU1hcD1mdW5jdGlvbihlLHQpe3ZhciByPU9iamVjdC5rZXlzKGUpO3RoaXMuc29ydEtleXMmJnIuc29ydCgpO3ZhciBuPXIubGVuZ3RoO2lmKG48MTYpdGhpcy53cml0ZVU4KDEyOCtuKTtlbHNlIGlmKG48NjU1MzYpdGhpcy53cml0ZVU4KDIyMiksdGhpcy53cml0ZVUxNihuKTtlbHNle2lmKCEobjw0Mjk0OTY3Mjk2KSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gbGFyZ2UgbWFwIG9iamVjdDogXCIrbik7dGhpcy53cml0ZVU4KDIyMyksdGhpcy53cml0ZVUzMihuKX1mb3IodmFyIGk9MDtpPG47aSsrKXt2YXIgbz1yW2ldO3RoaXMuZW5jb2RlU3RyaW5nKG8pLHRoaXMuZW5jb2RlKGVbb10sdCsxKX19LGUucHJvdG90eXBlLmVuY29kZUV4dGVuc2lvbj1mdW5jdGlvbihlKXt2YXIgdD1lLmRhdGEubGVuZ3RoO2lmKDE9PT10KXRoaXMud3JpdGVVOCgyMTIpO2Vsc2UgaWYoMj09PXQpdGhpcy53cml0ZVU4KDIxMyk7ZWxzZSBpZig0PT09dCl0aGlzLndyaXRlVTgoMjE0KTtlbHNlIGlmKDg9PT10KXRoaXMud3JpdGVVOCgyMTUpO2Vsc2UgaWYoMTY9PT10KXRoaXMud3JpdGVVOCgyMTYpO2Vsc2UgaWYodDwyNTYpdGhpcy53cml0ZVU4KDE5OSksdGhpcy53cml0ZVU4KHQpO2Vsc2UgaWYodDw2NTUzNil0aGlzLndyaXRlVTgoMjAwKSx0aGlzLndyaXRlVTE2KHQpO2Vsc2V7aWYoISh0PDQyOTQ5NjcyOTYpKXRocm93IG5ldyBFcnJvcihcIlRvbyBsYXJnZSBleHRlbnNpb24gb2JqZWN0OiBcIit0KTt0aGlzLndyaXRlVTgoMjAxKSx0aGlzLndyaXRlVTMyKHQpfXRoaXMud3JpdGVJOChlLnR5cGUpLHRoaXMud3JpdGVVOGEoZS5kYXRhKX0sZS5wcm90b3R5cGUud3JpdGVVOD1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDEpLHRoaXMudmlldy5zZXRVaW50OCh0aGlzLnBvcyxlKSx0aGlzLnBvcysrfSxlLnByb3RvdHlwZS53cml0ZVU4YT1mdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aDt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKHQpLHRoaXMuYnl0ZXMuc2V0KGUsdGhpcy5wb3MpLHRoaXMucG9zKz10fSxlLnByb3RvdHlwZS53cml0ZUk4PWZ1bmN0aW9uKGUpe3RoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSksdGhpcy52aWV3LnNldEludDgodGhpcy5wb3MsZSksdGhpcy5wb3MrK30sZS5wcm90b3R5cGUud3JpdGVVMTY9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSgyKSx0aGlzLnZpZXcuc2V0VWludDE2KHRoaXMucG9zLGUpLHRoaXMucG9zKz0yfSxlLnByb3RvdHlwZS53cml0ZUkxNj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpLHRoaXMudmlldy5zZXRJbnQxNih0aGlzLnBvcyxlKSx0aGlzLnBvcys9Mn0sZS5wcm90b3R5cGUud3JpdGVVMzI9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg0KSx0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMucG9zLGUpLHRoaXMucG9zKz00fSxlLnByb3RvdHlwZS53cml0ZUkzMj1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDQpLHRoaXMudmlldy5zZXRJbnQzMih0aGlzLnBvcyxlKSx0aGlzLnBvcys9NH0sZS5wcm90b3R5cGUud3JpdGVGMzI9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg0KSx0aGlzLnZpZXcuc2V0RmxvYXQzMih0aGlzLnBvcyxlKSx0aGlzLnBvcys9NH0sZS5wcm90b3R5cGUud3JpdGVGNjQ9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg4KSx0aGlzLnZpZXcuc2V0RmxvYXQ2NCh0aGlzLnBvcyxlKSx0aGlzLnBvcys9OH0sZS5wcm90b3R5cGUud3JpdGVVNjQ9ZnVuY3Rpb24oZSl7dGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg4KSxmdW5jdGlvbihlLHQscil7dmFyIG49ci80Mjk0OTY3Mjk2LGk9cjtlLnNldFVpbnQzMih0LG4pLGUuc2V0VWludDMyKHQrNCxpKX0odGhpcy52aWV3LHRoaXMucG9zLGUpLHRoaXMucG9zKz04fSxlLnByb3RvdHlwZS53cml0ZUk2ND1mdW5jdGlvbihlKXt0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpLGwodGhpcy52aWV3LHRoaXMucG9zLGUpLHRoaXMucG9zKz04fSxlfSgpLHo9e307ZnVuY3Rpb24gQyhlLHQpe3ZvaWQgMD09PXQmJih0PXopO3ZhciByPW5ldyBQKHQuZXh0ZW5zaW9uQ29kZWMsdC5tYXhEZXB0aCx0LmluaXRpYWxCdWZmZXJTaXplLHQuc29ydEtleXMsdC5mb3JjZUZsb2F0MzIpO3JldHVybiByLmVuY29kZShlLDEpLHIuZ2V0VWludDhBcnJheSgpfWZ1bmN0aW9uIEQoZSl7cmV0dXJuKGU8MD9cIi1cIjpcIlwiKStcIjB4XCIrTWF0aC5hYnMoZSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsXCIwXCIpfXZhciBfLGo9ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoZnVuY3Rpb24oaSxvKXtmdW5jdGlvbiBzKGUpe3RyeXt1KG4ubmV4dChlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gYShlKXt0cnl7dShuLnRocm93KGUpKX1jYXRjaChlKXtvKGUpfX1mdW5jdGlvbiB1KGUpe2UuZG9uZT9pKGUudmFsdWUpOm5ldyByKGZ1bmN0aW9uKHQpe3QoZS52YWx1ZSl9KS50aGVuKHMsYSl9dSgobj1uLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSl9LE89ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksbyxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBvPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYob1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxvO2Z1bmN0aW9uIGEobyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihvKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHI9MSxuJiYoaT0yJm9bMF0/bi5yZXR1cm46b1swXT9uLnRocm93fHwoKGk9bi5yZXR1cm4pJiZpLmNhbGwobiksMCk6bi5uZXh0KSYmIShpPWkuY2FsbChuLG9bMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChuPTAsaSYmKG89WzImb1swXSxpLnZhbHVlXSksb1swXSl7Y2FzZSAwOmNhc2UgMTppPW87YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOm9bMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxuPW9bMV0sbz1bMF07Y29udGludWU7Y2FzZSA3Om89cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPXMudHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PW9bMF18fDI9PT1vWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1vWzBdJiYoIWl8fG9bMV0+aVswXSYmb1sxXTxpWzNdKSl7cy5sYWJlbD1vWzFdO2JyZWFrfWlmKDY9PT1vWzBdJiZzLmxhYmVsPGlbMV0pe3MubGFiZWw9aVsxXSxpPW87YnJlYWt9aWYoaSYmcy5sYWJlbDxpWzJdKXtzLmxhYmVsPWlbMl0scy5vcHMucHVzaChvKTticmVha31pWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9bz10LmNhbGwoZSxzKX1jYXRjaChlKXtvPVs2LGVdLG49MH1maW5hbGx5e3I9aT0wfWlmKDUmb1swXSl0aHJvdyBvWzFdO3JldHVybnt2YWx1ZTpvWzBdP29bMV06dm9pZCAwLGRvbmU6ITB9fShbbyxhXSl9fX0sRj1mdW5jdGlvbihlKXtpZighU3ltYm9sLmFzeW5jSXRlcmF0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTt2YXIgdCxyPWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO3JldHVybiByP3IuY2FsbChlKTooZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBfX3ZhbHVlcz9fX3ZhbHVlcyhlKTplW1N5bWJvbC5pdGVyYXRvcl0oKSx0PXt9LG4oXCJuZXh0XCIpLG4oXCJ0aHJvd1wiKSxuKFwicmV0dXJuXCIpLHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHQpO2Z1bmN0aW9uIG4ocil7dFtyXT1lW3JdJiZmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixpKXsoZnVuY3Rpb24oZSx0LHIsbil7UHJvbWlzZS5yZXNvbHZlKG4pLnRoZW4oZnVuY3Rpb24odCl7ZSh7dmFsdWU6dCxkb25lOnJ9KX0sdCl9KShuLGksKHQ9ZVtyXSh0KSkuZG9uZSx0LnZhbHVlKX0pfX19LFY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBWPyh0aGlzLnY9ZSx0aGlzKTpuZXcgVihlKX0sUj1mdW5jdGlvbihlLHQscil7aWYoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7dmFyIG4saT1yLmFwcGx5KGUsdHx8W10pLG89W107cmV0dXJuIG49e30scyhcIm5leHRcIikscyhcInRocm93XCIpLHMoXCJyZXR1cm5cIiksbltTeW1ib2wuYXN5bmNJdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sbjtmdW5jdGlvbiBzKGUpe2lbZV0mJihuW2VdPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLG4pe28ucHVzaChbZSx0LHIsbl0pPjF8fGEoZSx0KX0pfSl9ZnVuY3Rpb24gYShlLHQpe3RyeXsocj1pW2VdKHQpKS52YWx1ZSBpbnN0YW5jZW9mIFY/UHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbih1LGgpOmMob1swXVsyXSxyKX1jYXRjaChlKXtjKG9bMF1bM10sZSl9dmFyIHJ9ZnVuY3Rpb24gdShlKXthKFwibmV4dFwiLGUpfWZ1bmN0aW9uIGgoZSl7YShcInRocm93XCIsZSl9ZnVuY3Rpb24gYyhlLHQpe2UodCksby5zaGlmdCgpLG8ubGVuZ3RoJiZhKG9bMF1bMF0sb1swXVsxXSl9fTshZnVuY3Rpb24oZSl7ZVtlLkFSUkFZPTBdPVwiQVJSQVlcIixlW2UuTUFQX0tFWT0xXT1cIk1BUF9LRVlcIixlW2UuTUFQX1ZBTFVFPTJdPVwiTUFQX1ZBTFVFXCJ9KF98fChfPXt9KSk7dmFyIFc9LTEsTj1uZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSxZPW5ldyBVaW50OEFycmF5KE4uYnVmZmVyKSxLPWZ1bmN0aW9uKCl7dHJ5e04uZ2V0SW50OCgwKX1jYXRjaChlKXtyZXR1cm4gZS5jb25zdHJ1Y3Rvcn10aHJvdyBuZXcgRXJyb3IoXCJuZXZlciByZWFjaGVkXCIpfSgpLEg9bmV3IEsoXCJJbnN1ZmZpY2llbnQgZGF0YVwiKSxHPTQyOTQ5NjcyOTUsWD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LHIsbixpLG8pe3ZvaWQgMD09PWUmJihlPXguZGVmYXVsdENvZGVjKSx2b2lkIDA9PT10JiYodD1HKSx2b2lkIDA9PT1yJiYocj1HKSx2b2lkIDA9PT1uJiYobj1HKSx2b2lkIDA9PT1pJiYoaT1HKSx2b2lkIDA9PT1vJiYobz1HKSx0aGlzLmV4dGVuc2lvbkNvZGVjPWUsdGhpcy5tYXhTdHJMZW5ndGg9dCx0aGlzLm1heEJpbkxlbmd0aD1yLHRoaXMubWF4QXJyYXlMZW5ndGg9bix0aGlzLm1heE1hcExlbmd0aD1pLHRoaXMubWF4RXh0TGVuZ3RoPW8sdGhpcy50b3RhbFBvcz0wLHRoaXMucG9zPTAsdGhpcy52aWV3PU4sdGhpcy5ieXRlcz1ZLHRoaXMuaGVhZEJ5dGU9Vyx0aGlzLnN0YWNrPVtdfXJldHVybiBlLnByb3RvdHlwZS5zZXRCdWZmZXI9ZnVuY3Rpb24oZSl7dGhpcy5ieXRlcz1TKGUpLHRoaXMudmlldz1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpcmV0dXJuIG5ldyBEYXRhVmlldyhlKTt2YXIgdD1TKGUpO3JldHVybiBuZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCl9KHRoaXMuYnl0ZXMpLHRoaXMucG9zPTB9LGUucHJvdG90eXBlLmFwcGVuZEJ1ZmZlcj1mdW5jdGlvbihlKXtpZih0aGlzLmhlYWRCeXRlIT09V3x8dGhpcy5oYXNSZW1haW5pbmcoKSl7dmFyIHQ9dGhpcy5ieXRlcy5zdWJhcnJheSh0aGlzLnBvcykscj1TKGUpLG49bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgrci5sZW5ndGgpO24uc2V0KHQpLG4uc2V0KHIsdC5sZW5ndGgpLHRoaXMuc2V0QnVmZmVyKG4pfWVsc2UgdGhpcy5zZXRCdWZmZXIoZSl9LGUucHJvdG90eXBlLmhhc1JlbWFpbmluZz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MSksdGhpcy52aWV3LmJ5dGVMZW5ndGgtdGhpcy5wb3M+PWV9LGUucHJvdG90eXBlLmNyZWF0ZU5vRXh0cmFCeXRlc0Vycm9yPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMudmlldyxyPXRoaXMucG9zO3JldHVybiBuZXcgUmFuZ2VFcnJvcihcIkV4dHJhIFwiKyh0LmJ5dGVMZW5ndGgtcikrXCIgYnl0ZShzKSBmb3VuZCBhdCBidWZmZXJbXCIrZStcIl1cIil9LGUucHJvdG90eXBlLmRlY29kZU9uZVN5bmM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRlY29kZVN5bmMoKTtpZih0aGlzLmhhc1JlbWFpbmluZygpKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy5wb3MpO3JldHVybiBlfSxlLnByb3RvdHlwZS5kZWNvZGVPbmVBc3luYz1mdW5jdGlvbihlKXt2YXIgdCxyLG4saTtyZXR1cm4gaih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbyxzLGEsdSxoLGMsZixsO3JldHVybiBPKHRoaXMsZnVuY3Rpb24ocCl7c3dpdGNoKHAubGFiZWwpe2Nhc2UgMDpvPSExLHAubGFiZWw9MTtjYXNlIDE6cC50cnlzLnB1c2goWzEsNiw3LDEyXSksdD1GKGUpLHAubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzQsdC5uZXh0KCldO2Nhc2UgMzppZigocj1wLnNlbnQoKSkuZG9uZSlyZXR1cm5bMyw1XTtpZihhPXIudmFsdWUsbyl0aHJvdyB0aGlzLmNyZWF0ZU5vRXh0cmFCeXRlc0Vycm9yKHRoaXMudG90YWxQb3MpO3RoaXMuYXBwZW5kQnVmZmVyKGEpO3RyeXtzPXRoaXMuZGVjb2RlU3luYygpLG89ITB9Y2F0Y2goZSl7aWYoIShlIGluc3RhbmNlb2YgSykpdGhyb3cgZX10aGlzLnRvdGFsUG9zKz10aGlzLnBvcyxwLmxhYmVsPTQ7Y2FzZSA0OnJldHVyblszLDJdO2Nhc2UgNTpyZXR1cm5bMywxMl07Y2FzZSA2OnJldHVybiB1PXAuc2VudCgpLG49e2Vycm9yOnV9LFszLDEyXTtjYXNlIDc6cmV0dXJuIHAudHJ5cy5wdXNoKFs3LCwxMCwxMV0pLHImJiFyLmRvbmUmJihpPXQucmV0dXJuKT9bNCxpLmNhbGwodCldOlszLDldO2Nhc2UgODpwLnNlbnQoKSxwLmxhYmVsPTk7Y2FzZSA5OnJldHVyblszLDExXTtjYXNlIDEwOmlmKG4pdGhyb3cgbi5lcnJvcjtyZXR1cm5bN107Y2FzZSAxMTpyZXR1cm5bN107Y2FzZSAxMjppZihvKXtpZih0aGlzLmhhc1JlbWFpbmluZygpKXRocm93IHRoaXMuY3JlYXRlTm9FeHRyYUJ5dGVzRXJyb3IodGhpcy50b3RhbFBvcyk7cmV0dXJuWzIsc119dGhyb3cgYz0oaD10aGlzKS5oZWFkQnl0ZSxmPWgucG9zLGw9aC50b3RhbFBvcyxuZXcgUmFuZ2VFcnJvcihcIkluc3VmZmljaWVudCBkYXRhIGluIHBhcmNpbmcgXCIrRChjKStcIiBhdCBcIitsK1wiIChcIitmK1wiIGluIHRoZSBjdXJyZW50IGJ1ZmZlcilcIil9fSl9KX0sZS5wcm90b3R5cGUuZGVjb2RlU3RyZWFtPWZ1bmN0aW9uKGUpe3JldHVybiBSKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKCl7dmFyIHQscixuLGksbyxzLGEsdTtyZXR1cm4gTyh0aGlzLGZ1bmN0aW9uKGgpe3N3aXRjaChoLmxhYmVsKXtjYXNlIDA6aC50cnlzLnB1c2goWzAsMTEsMTIsMTddKSx0PUYoZSksaC5sYWJlbD0xO2Nhc2UgMTpyZXR1cm5bNCxWKHQubmV4dCgpKV07Y2FzZSAyOmlmKChyPWguc2VudCgpKS5kb25lKXJldHVyblszLDEwXTtuPXIudmFsdWUsdGhpcy5hcHBlbmRCdWZmZXIobiksaC5sYWJlbD0zO2Nhc2UgMzpoLnRyeXMucHVzaChbMyw4LCw5XSksaC5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gaT10aGlzLmRlY29kZVN5bmMoKSxbNCxWKGkpXTtjYXNlIDU6cmV0dXJuWzQsaC5zZW50KCldO2Nhc2UgNjpyZXR1cm4gaC5zZW50KCksWzMsNF07Y2FzZSA3OnJldHVyblszLDldO2Nhc2UgODppZighKChvPWguc2VudCgpKWluc3RhbmNlb2YgSykpdGhyb3cgbztyZXR1cm5bMyw5XTtjYXNlIDk6cmV0dXJuWzMsMV07Y2FzZSAxMDpyZXR1cm5bMywxN107Y2FzZSAxMTpyZXR1cm4gcz1oLnNlbnQoKSxhPXtlcnJvcjpzfSxbMywxN107Y2FzZSAxMjpyZXR1cm4gaC50cnlzLnB1c2goWzEyLCwxNSwxNl0pLHImJiFyLmRvbmUmJih1PXQucmV0dXJuKT9bNCxWKHUuY2FsbCh0KSldOlszLDE0XTtjYXNlIDEzOmguc2VudCgpLGgubGFiZWw9MTQ7Y2FzZSAxNDpyZXR1cm5bMywxNl07Y2FzZSAxNTppZihhKXRocm93IGEuZXJyb3I7cmV0dXJuWzddO2Nhc2UgMTY6cmV0dXJuWzddO2Nhc2UgMTc6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLmRlY29kZUFycmF5U3RyZWFtPWZ1bmN0aW9uKGUpe3JldHVybiBSKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKCl7dmFyIHQscixuLGksbyxzLGEsdSxoLGMsZjtyZXR1cm4gTyh0aGlzLGZ1bmN0aW9uKGwpe3N3aXRjaChsLmxhYmVsKXtjYXNlIDA6dD0hMSxyPSExLG49MCxsLmxhYmVsPTE7Y2FzZSAxOmwudHJ5cy5wdXNoKFsxLDEzLDE0LDE5XSksaT1GKGUpLGwubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzQsVihpLm5leHQoKSldO2Nhc2UgMzppZigobz1sLnNlbnQoKSkuZG9uZSlyZXR1cm5bMywxMl07aWYocz1vLnZhbHVlLHIpdGhyb3cgdGhpcy5jcmVhdGVOb0V4dHJhQnl0ZXNFcnJvcih0aGlzLnRvdGFsUG9zKTt0aGlzLmFwcGVuZEJ1ZmZlcihzKSx0fHwobj10aGlzLnJlYWRBcnJheVNpemUoKSx0PSEwLHRoaXMuY29tcGxldGUoKSksbC5sYWJlbD00O2Nhc2UgNDpsLnRyeXMucHVzaChbNCw5LCwxMF0pLGwubGFiZWw9NTtjYXNlIDU6cmV0dXJuIGE9dGhpcy5kZWNvZGVTeW5jKCksWzQsVihhKV07Y2FzZSA2OnJldHVybls0LGwuc2VudCgpXTtjYXNlIDc6cmV0dXJuIGwuc2VudCgpLDA9PT0tLW4/KHI9ITAsWzMsOF0pOlszLDVdO2Nhc2UgODpyZXR1cm5bMywxMF07Y2FzZSA5OmlmKCEoKHU9bC5zZW50KCkpaW5zdGFuY2VvZiBLKSl0aHJvdyB1O3JldHVyblszLDEwXTtjYXNlIDEwOnRoaXMudG90YWxQb3MrPXRoaXMucG9zLGwubGFiZWw9MTE7Y2FzZSAxMTpyZXR1cm5bMywyXTtjYXNlIDEyOnJldHVyblszLDE5XTtjYXNlIDEzOnJldHVybiBoPWwuc2VudCgpLGM9e2Vycm9yOmh9LFszLDE5XTtjYXNlIDE0OnJldHVybiBsLnRyeXMucHVzaChbMTQsLDE3LDE4XSksbyYmIW8uZG9uZSYmKGY9aS5yZXR1cm4pP1s0LFYoZi5jYWxsKGkpKV06WzMsMTZdO2Nhc2UgMTU6bC5zZW50KCksbC5sYWJlbD0xNjtjYXNlIDE2OnJldHVyblszLDE4XTtjYXNlIDE3OmlmKGMpdGhyb3cgYy5lcnJvcjtyZXR1cm5bN107Y2FzZSAxODpyZXR1cm5bN107Y2FzZSAxOTpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUuZGVjb2RlU3luYz1mdW5jdGlvbigpe2U6Zm9yKDs7KXt2YXIgZT10aGlzLnJlYWRIZWFkQnl0ZSgpLHQ9dm9pZCAwO2lmKGU+PTIyNCl0PWUtMjU2O2Vsc2UgaWYoZTwxOTIpaWYoZTwxMjgpdD1lO2Vsc2UgaWYoZTwxNDQpe2lmKDAhPT0obj1lLTEyOCkpe3RoaXMucHVzaE1hcFN0YXRlKG4pLHRoaXMuY29tcGxldGUoKTtjb250aW51ZSBlfXQ9e319ZWxzZSBpZihlPDE2MCl7aWYoMCE9PShuPWUtMTQ0KSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2V7dmFyIHI9ZS0xNjA7dD10aGlzLmRlY29kZVV0ZjhTdHJpbmcociwwKX1lbHNlIGlmKDE5Mj09PWUpdD1udWxsO2Vsc2UgaWYoMTk0PT09ZSl0PSExO2Vsc2UgaWYoMTk1PT09ZSl0PSEwO2Vsc2UgaWYoMjAyPT09ZSl0PXRoaXMucmVhZEYzMigpO2Vsc2UgaWYoMjAzPT09ZSl0PXRoaXMucmVhZEY2NCgpO2Vsc2UgaWYoMjA0PT09ZSl0PXRoaXMucmVhZFU4KCk7ZWxzZSBpZigyMDU9PT1lKXQ9dGhpcy5yZWFkVTE2KCk7ZWxzZSBpZigyMDY9PT1lKXQ9dGhpcy5yZWFkVTMyKCk7ZWxzZSBpZigyMDc9PT1lKXQ9dGhpcy5yZWFkVTY0KCk7ZWxzZSBpZigyMDg9PT1lKXQ9dGhpcy5yZWFkSTgoKTtlbHNlIGlmKDIwOT09PWUpdD10aGlzLnJlYWRJMTYoKTtlbHNlIGlmKDIxMD09PWUpdD10aGlzLnJlYWRJMzIoKTtlbHNlIGlmKDIxMT09PWUpdD10aGlzLnJlYWRJNjQoKTtlbHNlIGlmKDIxNz09PWUpe3I9dGhpcy5sb29rVTgoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDEpfWVsc2UgaWYoMjE4PT09ZSl7cj10aGlzLmxvb2tVMTYoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDIpfWVsc2UgaWYoMjE5PT09ZSl7cj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlVXRmOFN0cmluZyhyLDQpfWVsc2UgaWYoMjIwPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUxNigpKSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2UgaWYoMjIxPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUzMigpKSl7dGhpcy5wdXNoQXJyYXlTdGF0ZShuKSx0aGlzLmNvbXBsZXRlKCk7Y29udGludWUgZX10PVtdfWVsc2UgaWYoMjIyPT09ZSl7aWYoMCE9PShuPXRoaXMucmVhZFUxNigpKSl7dGhpcy5wdXNoTWFwU3RhdGUobiksdGhpcy5jb21wbGV0ZSgpO2NvbnRpbnVlIGV9dD17fX1lbHNlIGlmKDIyMz09PWUpe2lmKDAhPT0obj10aGlzLnJlYWRVMzIoKSkpe3RoaXMucHVzaE1hcFN0YXRlKG4pLHRoaXMuY29tcGxldGUoKTtjb250aW51ZSBlfXQ9e319ZWxzZSBpZigxOTY9PT1lKXt2YXIgbj10aGlzLmxvb2tVOCgpO3Q9dGhpcy5kZWNvZGVCaW5hcnkobiwxKX1lbHNlIGlmKDE5Nz09PWUpe249dGhpcy5sb29rVTE2KCk7dD10aGlzLmRlY29kZUJpbmFyeShuLDIpfWVsc2UgaWYoMTk4PT09ZSl7bj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlQmluYXJ5KG4sNCl9ZWxzZSBpZigyMTI9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oMSwwKTtlbHNlIGlmKDIxMz09PWUpdD10aGlzLmRlY29kZUV4dGVuc2lvbigyLDApO2Vsc2UgaWYoMjE0PT09ZSl0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKDQsMCk7ZWxzZSBpZigyMTU9PT1lKXQ9dGhpcy5kZWNvZGVFeHRlbnNpb24oOCwwKTtlbHNlIGlmKDIxNj09PWUpdD10aGlzLmRlY29kZUV4dGVuc2lvbigxNiwwKTtlbHNlIGlmKDE5OT09PWUpe249dGhpcy5sb29rVTgoKTt0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKG4sMSl9ZWxzZSBpZigyMDA9PT1lKXtuPXRoaXMubG9va1UxNigpO3Q9dGhpcy5kZWNvZGVFeHRlbnNpb24obiwyKX1lbHNle2lmKDIwMSE9PWUpdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHR5cGUgYnl0ZTogXCIrRChlKSk7bj10aGlzLmxvb2tVMzIoKTt0PXRoaXMuZGVjb2RlRXh0ZW5zaW9uKG4sNCl9dGhpcy5jb21wbGV0ZSgpO2Zvcih2YXIgaT10aGlzLnN0YWNrO2kubGVuZ3RoPjA7KXt2YXIgbz1pW2kubGVuZ3RoLTFdO2lmKG8udHlwZT09PV8uQVJSQVkpe2lmKG8uYXJyYXlbby5wb3NpdGlvbl09dCxvLnBvc2l0aW9uKyssby5wb3NpdGlvbiE9PW8uc2l6ZSljb250aW51ZSBlO2kucG9wKCksdD1vLmFycmF5fWVsc2V7aWYoby50eXBlPT09Xy5NQVBfS0VZKXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHlwZSBvZiBrZXkgbXVzdCBiZSBzdHJpbmcgYnV0IFwiK3R5cGVvZiB0KTtvLmtleT10LG8udHlwZT1fLk1BUF9WQUxVRTtjb250aW51ZSBlfWlmKG8udHlwZT09PV8uTUFQX1ZBTFVFKXtpZihvLm1hcFtvLmtleV09dCxvLnJlYWRDb3VudCsrLG8ucmVhZENvdW50IT09by5zaXplKXtvLmtleT1udWxsLG8udHlwZT1fLk1BUF9LRVk7Y29udGludWUgZX1pLnBvcCgpLHQ9by5tYXB9fX1yZXR1cm4gdH19LGUucHJvdG90eXBlLnJlYWRIZWFkQnl0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWRCeXRlPT09VyYmKHRoaXMuaGVhZEJ5dGU9dGhpcy5yZWFkVTgoKSksdGhpcy5oZWFkQnl0ZX0sZS5wcm90b3R5cGUuY29tcGxldGU9ZnVuY3Rpb24oKXt0aGlzLmhlYWRCeXRlPVd9LGUucHJvdG90eXBlLnJlYWRBcnJheVNpemU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlYWRIZWFkQnl0ZSgpO3N3aXRjaChlKXtjYXNlIDIyMDpyZXR1cm4gdGhpcy5yZWFkVTE2KCk7Y2FzZSAyMjE6cmV0dXJuIHRoaXMucmVhZFUzMigpO2RlZmF1bHQ6aWYoZTwxNjApcmV0dXJuIGUtMTQ0O3Rocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBhcnJheSB0eXBlIGJ5dGU6IFwiK0QoZSkpfX0sZS5wcm90b3R5cGUucHVzaE1hcFN0YXRlPWZ1bmN0aW9uKGUpe2lmKGU+dGhpcy5tYXhNYXBMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGxlbmd0aCBleGNlZWRlZDogbWFwIGxlbmd0aCAoXCIrZStcIikgPiBtYXhNYXBMZW5ndGhMZW5ndGggKFwiK3RoaXMubWF4TWFwTGVuZ3RoK1wiKVwiKTt0aGlzLnN0YWNrLnB1c2goe3R5cGU6Xy5NQVBfS0VZLHNpemU6ZSxrZXk6bnVsbCxyZWFkQ291bnQ6MCxtYXA6e319KX0sZS5wcm90b3R5cGUucHVzaEFycmF5U3RhdGU9ZnVuY3Rpb24oZSl7aWYoZT50aGlzLm1heEFycmF5TGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1heCBsZW5ndGggZXhjZWVkZWQ6IGFycmF5IGxlbmd0aCAoXCIrZStcIikgPiBtYXhBcnJheUxlbmd0aCAoXCIrdGhpcy5tYXhBcnJheUxlbmd0aCtcIilcIik7dGhpcy5zdGFjay5wdXNoKHt0eXBlOl8uQVJSQVksc2l6ZTplLGFycmF5Om5ldyBBcnJheShlKSxwb3NpdGlvbjowfSl9LGUucHJvdG90eXBlLmRlY29kZVV0ZjhTdHJpbmc9ZnVuY3Rpb24oZSx0KXtpZihlPnRoaXMubWF4U3RyTGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1heCBsZW5ndGggZXhjZWVkZWQ6IFVURi04IGJ5dGUgbGVuZ3RoIChcIitlK1wiKSA+IG1heFN0ckxlbmd0aCAoXCIrdGhpcy5tYXhTdHJMZW5ndGgrXCIpXCIpO2lmKHRoaXMuYnl0ZXMuYnl0ZUxlbmd0aDx0aGlzLnBvcyt0K2UpdGhyb3cgSDt2YXIgcixuPXRoaXMucG9zK3Q7cmV0dXJuIHI9byYmZT4yMDA/ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuc3ViYXJyYXkodCx0K3IpO3JldHVybiBjLmRlY29kZShuKX0odGhpcy5ieXRlcyxuLGUpOkUmJmU+MTAyND9UKHRoaXMuYnl0ZXMsbixlKTpmdW5jdGlvbihlLHQscil7Zm9yKHZhciBuPXQsbz1uK3Iscz1bXSxhPVwiXCI7bjxvOyl7dmFyIHU9ZVtuKytdO2lmKDA9PSgxMjgmdSkpcy5wdXNoKHUpO2Vsc2UgaWYoMTkyPT0oMjI0JnUpKXt2YXIgYz02MyZlW24rK107cy5wdXNoKCgzMSZ1KTw8NnxjKX1lbHNlIGlmKDIyND09KDI0MCZ1KSl7Yz02MyZlW24rK107dmFyIGY9NjMmZVtuKytdO3MucHVzaCgoMzEmdSk8PDEyfGM8PDZ8Zil9ZWxzZSBpZigyNDA9PSgyNDgmdSkpe3ZhciBsPSg3JnUpPDwxOHwoYz02MyZlW24rK10pPDwxMnwoZj02MyZlW24rK10pPDw2fDYzJmVbbisrXTtsPjY1NTM1JiYobC09NjU1MzYscy5wdXNoKGw+Pj4xMCYxMDIzfDU1Mjk2KSxsPTU2MzIwfDEwMjMmbCkscy5wdXNoKGwpfWVsc2Ugcy5wdXNoKHUpO3MubGVuZ3RoLTQ+PWgmJihhKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKHMpKSxzLmxlbmd0aD0wKX1yZXR1cm4gcy5sZW5ndGg+MCYmKGErPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGkocykpKSxhfSh0aGlzLmJ5dGVzLG4sZSksdGhpcy5wb3MrPXQrZSxyfSxlLnByb3RvdHlwZS5kZWNvZGVCaW5hcnk9ZnVuY3Rpb24oZSx0KXtpZihlPnRoaXMubWF4QmluTGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1heCBsZW5ndGggZXhjZWVkZWQ6IGJpbiBsZW5ndGggKFwiK2UrXCIpID4gbWF4QmluTGVuZ3RoIChcIit0aGlzLm1heEJpbkxlbmd0aCtcIilcIik7aWYoIXRoaXMuaGFzUmVtYWluaW5nKGUrdCkpdGhyb3cgSDt2YXIgcj10aGlzLnBvcyt0LG49dGhpcy5ieXRlcy5zdWJhcnJheShyLHIrZSk7cmV0dXJuIHRoaXMucG9zKz10K2Usbn0sZS5wcm90b3R5cGUuZGVjb2RlRXh0ZW5zaW9uPWZ1bmN0aW9uKGUsdCl7aWYoZT50aGlzLm1heEV4dExlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNYXggbGVuZ3RoIGV4Y2VlZGVkOiBleHQgbGVuZ3RoIChcIitlK1wiKSA+IG1heEV4dExlbmd0aCAoXCIrdGhpcy5tYXhFeHRMZW5ndGgrXCIpXCIpO3ZhciByPXRoaXMudmlldy5nZXRJbnQ4KHRoaXMucG9zK3QpLG49dGhpcy5kZWNvZGVCaW5hcnkoZSx0KzEpO3JldHVybiB0aGlzLmV4dGVuc2lvbkNvZGVjLmRlY29kZShuLHIpfSxlLnByb3RvdHlwZS5sb29rVTg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKX0sZS5wcm90b3R5cGUubG9va1UxNj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMucG9zKX0sZS5wcm90b3R5cGUubG9va1UzMj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMucG9zKX0sZS5wcm90b3R5cGUucmVhZFU4PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrKyxlfSxlLnByb3RvdHlwZS5yZWFkSTg9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnZpZXcuZ2V0SW50OCh0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKyssZX0sZS5wcm90b3R5cGUucmVhZFUxNj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmlldy5nZXRVaW50MTYodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9MixlfSxlLnByb3RvdHlwZS5yZWFkSTE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEludDE2KHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTIsZX0sZS5wcm90b3R5cGUucmVhZFUzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxlLnByb3RvdHlwZS5yZWFkSTMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTQsZX0sZS5wcm90b3R5cGUucmVhZFU2ND1mdW5jdGlvbigpe3ZhciBlLHQscj0oZT10aGlzLnZpZXcsdD10aGlzLnBvcyw0Mjk0OTY3Mjk2KmUuZ2V0VWludDMyKHQpK2UuZ2V0VWludDMyKHQrNCkpO3JldHVybiB0aGlzLnBvcys9OCxyfSxlLnByb3RvdHlwZS5yZWFkSTY0PWZ1bmN0aW9uKCl7dmFyIGU9cCh0aGlzLnZpZXcsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxlLnByb3RvdHlwZS5yZWFkRjMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEZsb2F0MzIodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxlLnByb3RvdHlwZS5yZWFkRjY0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWV3LmdldEZsb2F0NjQodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxlfSgpLHE9e307ZnVuY3Rpb24gSihlLHQpe3ZvaWQgMD09PXQmJih0PXEpO3ZhciByPW5ldyBYKHQuZXh0ZW5zaW9uQ29kZWMsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCk7cmV0dXJuIHIuc2V0QnVmZmVyKGUpLHIuZGVjb2RlT25lU3luYygpfXZhciBRPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLG8scz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZpWzBdKXRocm93IGlbMV07cmV0dXJuIGlbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gbz17bmV4dDphKDApLHRocm93OmEoMSkscmV0dXJuOmEoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKG9bU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksbztmdW5jdGlvbiBhKG8pe3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24obyl7aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO3M7KXRyeXtpZihyPTEsbiYmKGk9MiZvWzBdP24ucmV0dXJuOm9bMF0/bi50aHJvd3x8KChpPW4ucmV0dXJuKSYmaS5jYWxsKG4pLDApOm4ubmV4dCkmJiEoaT1pLmNhbGwobixvWzFdKSkuZG9uZSlyZXR1cm4gaTtzd2l0Y2gobj0wLGkmJihvPVsyJm9bMF0saS52YWx1ZV0pLG9bMF0pe2Nhc2UgMDpjYXNlIDE6aT1vO2JyZWFrO2Nhc2UgNDpyZXR1cm4gcy5sYWJlbCsrLHt2YWx1ZTpvWzFdLGRvbmU6ITF9O2Nhc2UgNTpzLmxhYmVsKyssbj1vWzFdLG89WzBdO2NvbnRpbnVlO2Nhc2UgNzpvPXMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEoaT0oaT1zLnRyeXMpLmxlbmd0aD4wJiZpW2kubGVuZ3RoLTFdKSYmKDY9PT1vWzBdfHwyPT09b1swXSkpe3M9MDtjb250aW51ZX1pZigzPT09b1swXSYmKCFpfHxvWzFdPmlbMF0mJm9bMV08aVszXSkpe3MubGFiZWw9b1sxXTticmVha31pZig2PT09b1swXSYmcy5sYWJlbDxpWzFdKXtzLmxhYmVsPWlbMV0saT1vO2JyZWFrfWlmKGkmJnMubGFiZWw8aVsyXSl7cy5sYWJlbD1pWzJdLHMub3BzLnB1c2gobyk7YnJlYWt9aVsyXSYmcy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlfW89dC5jYWxsKGUscyl9Y2F0Y2goZSl7bz1bNixlXSxuPTB9ZmluYWxseXtyPWk9MH1pZig1Jm9bMF0pdGhyb3cgb1sxXTtyZXR1cm57dmFsdWU6b1swXT9vWzFdOnZvaWQgMCxkb25lOiEwfX0oW28sYV0pfX19LFo9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBaPyh0aGlzLnY9ZSx0aGlzKTpuZXcgWihlKX0sJD1mdW5jdGlvbihlLHQscil7aWYoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7dmFyIG4saT1yLmFwcGx5KGUsdHx8W10pLG89W107cmV0dXJuIG49e30scyhcIm5leHRcIikscyhcInRocm93XCIpLHMoXCJyZXR1cm5cIiksbltTeW1ib2wuYXN5bmNJdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sbjtmdW5jdGlvbiBzKGUpe2lbZV0mJihuW2VdPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLG4pe28ucHVzaChbZSx0LHIsbl0pPjF8fGEoZSx0KX0pfSl9ZnVuY3Rpb24gYShlLHQpe3RyeXsocj1pW2VdKHQpKS52YWx1ZSBpbnN0YW5jZW9mIFo/UHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbih1LGgpOmMob1swXVsyXSxyKX1jYXRjaChlKXtjKG9bMF1bM10sZSl9dmFyIHJ9ZnVuY3Rpb24gdShlKXthKFwibmV4dFwiLGUpfWZ1bmN0aW9uIGgoZSl7YShcInRocm93XCIsZSl9ZnVuY3Rpb24gYyhlLHQpe2UodCksby5zaGlmdCgpLG8ubGVuZ3RoJiZhKG9bMF1bMF0sb1swXVsxXSl9fTtmdW5jdGlvbiBlZShlKXtyZXR1cm4gbnVsbCE9ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0/ZTpmdW5jdGlvbihlKXtyZXR1cm4gJCh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbigpe3ZhciB0LHIsbixpO3JldHVybiBRKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDp0PWUuZ2V0UmVhZGVyKCksby5sYWJlbD0xO2Nhc2UgMTpvLnRyeXMucHVzaChbMSwsOSwxMF0pLG8ubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzQsWih0LnJlYWQoKSldO2Nhc2UgMzpyZXR1cm4gcj1vLnNlbnQoKSxuPXIuZG9uZSxpPXIudmFsdWUsbj9bNCxaKHZvaWQgMCldOlszLDVdO2Nhc2UgNDpyZXR1cm5bMixvLnNlbnQoKV07Y2FzZSA1OnJldHVybls0LFooaSldO2Nhc2UgNjpyZXR1cm5bNCxvLnNlbnQoKV07Y2FzZSA3OnJldHVybiBvLnNlbnQoKSxbMywyXTtjYXNlIDg6cmV0dXJuWzMsMTBdO2Nhc2UgOTpyZXR1cm4gdC5yZWxlYXNlTG9jaygpLFs3XTtjYXNlIDEwOnJldHVyblsyXX19KX0pfShlKX12YXIgdGU9ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoZnVuY3Rpb24oaSxvKXtmdW5jdGlvbiBzKGUpe3RyeXt1KG4ubmV4dChlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gYShlKXt0cnl7dShuLnRocm93KGUpKX1jYXRjaChlKXtvKGUpfX1mdW5jdGlvbiB1KGUpe2UuZG9uZT9pKGUudmFsdWUpOm5ldyByKGZ1bmN0aW9uKHQpe3QoZS52YWx1ZSl9KS50aGVuKHMsYSl9dSgobj1uLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSl9LHJlPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLG8scz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZpWzBdKXRocm93IGlbMV07cmV0dXJuIGlbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gbz17bmV4dDphKDApLHRocm93OmEoMSkscmV0dXJuOmEoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKG9bU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksbztmdW5jdGlvbiBhKG8pe3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24obyl7aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO3M7KXRyeXtpZihyPTEsbiYmKGk9MiZvWzBdP24ucmV0dXJuOm9bMF0/bi50aHJvd3x8KChpPW4ucmV0dXJuKSYmaS5jYWxsKG4pLDApOm4ubmV4dCkmJiEoaT1pLmNhbGwobixvWzFdKSkuZG9uZSlyZXR1cm4gaTtzd2l0Y2gobj0wLGkmJihvPVsyJm9bMF0saS52YWx1ZV0pLG9bMF0pe2Nhc2UgMDpjYXNlIDE6aT1vO2JyZWFrO2Nhc2UgNDpyZXR1cm4gcy5sYWJlbCsrLHt2YWx1ZTpvWzFdLGRvbmU6ITF9O2Nhc2UgNTpzLmxhYmVsKyssbj1vWzFdLG89WzBdO2NvbnRpbnVlO2Nhc2UgNzpvPXMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEoaT0oaT1zLnRyeXMpLmxlbmd0aD4wJiZpW2kubGVuZ3RoLTFdKSYmKDY9PT1vWzBdfHwyPT09b1swXSkpe3M9MDtjb250aW51ZX1pZigzPT09b1swXSYmKCFpfHxvWzFdPmlbMF0mJm9bMV08aVszXSkpe3MubGFiZWw9b1sxXTticmVha31pZig2PT09b1swXSYmcy5sYWJlbDxpWzFdKXtzLmxhYmVsPWlbMV0saT1vO2JyZWFrfWlmKGkmJnMubGFiZWw8aVsyXSl7cy5sYWJlbD1pWzJdLHMub3BzLnB1c2gobyk7YnJlYWt9aVsyXSYmcy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlfW89dC5jYWxsKGUscyl9Y2F0Y2goZSl7bz1bNixlXSxuPTB9ZmluYWxseXtyPWk9MH1pZig1Jm9bMF0pdGhyb3cgb1sxXTtyZXR1cm57dmFsdWU6b1swXT9vWzFdOnZvaWQgMCxkb25lOiEwfX0oW28sYV0pfX19O2Z1bmN0aW9uIG5lKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXEpLHRlKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByO3JldHVybiByZSh0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiByPWVlKGUpLFsyLG5ldyBYKHQuZXh0ZW5zaW9uQ29kZWMsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCkuZGVjb2RlT25lQXN5bmMocildfSl9KX1mdW5jdGlvbiBpZShlLHQpe3ZvaWQgMD09PXQmJih0PXEpO3ZhciByPWVlKGUpO3JldHVybiBuZXcgWCh0LmV4dGVuc2lvbkNvZGVjLHQubWF4U3RyTGVuZ3RoLHQubWF4QmluTGVuZ3RoLHQubWF4QXJyYXlMZW5ndGgsdC5tYXhNYXBMZW5ndGgsdC5tYXhFeHRMZW5ndGgpLmRlY29kZUFycmF5U3RyZWFtKHIpfWZ1bmN0aW9uIG9lKGUsdCl7dm9pZCAwPT09dCYmKHQ9cSk7dmFyIHI9ZWUoZSk7cmV0dXJuIG5ldyBYKHQuZXh0ZW5zaW9uQ29kZWMsdC5tYXhTdHJMZW5ndGgsdC5tYXhCaW5MZW5ndGgsdC5tYXhBcnJheUxlbmd0aCx0Lm1heE1hcExlbmd0aCx0Lm1heEV4dExlbmd0aCkuZGVjb2RlU3RyZWFtKHIpfXIuZCh0LFwiZW5jb2RlXCIsZnVuY3Rpb24oKXtyZXR1cm4gQ30pLHIuZCh0LFwiZGVjb2RlXCIsZnVuY3Rpb24oKXtyZXR1cm4gSn0pLHIuZCh0LFwiZGVjb2RlQXN5bmNcIixmdW5jdGlvbigpe3JldHVybiBuZX0pLHIuZCh0LFwiZGVjb2RlQXJyYXlTdHJlYW1cIixmdW5jdGlvbigpe3JldHVybiBpZX0pLHIuZCh0LFwiZGVjb2RlU3RyZWFtXCIsZnVuY3Rpb24oKXtyZXR1cm4gb2V9KSxyLmQodCxcIkRlY29kZXJcIixmdW5jdGlvbigpe3JldHVybiBYfSksci5kKHQsXCJFbmNvZGVyXCIsZnVuY3Rpb24oKXtyZXR1cm4gUH0pLHIuZCh0LFwiRXh0ZW5zaW9uQ29kZWNcIixmdW5jdGlvbigpe3JldHVybiB4fSksci5kKHQsXCJFeHREYXRhXCIsZnVuY3Rpb24oKXtyZXR1cm4gZn0pLHIuZCh0LFwiRVhUX1RJTUVTVEFNUFwiLGZ1bmN0aW9uKCl7cmV0dXJuLTF9KSxyLmQodCxcImVuY29kZURhdGVUb1RpbWVTcGVjXCIsZnVuY3Rpb24oKXtyZXR1cm4gdn0pLHIuZCh0LFwiZW5jb2RlVGltZVNwZWNUb1RpbWVzdGFtcFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSxyLmQodCxcImRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWNcIixmdW5jdGlvbigpe3JldHVybiBnfSksci5kKHQsXCJlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb25cIixmdW5jdGlvbigpe3JldHVybiBifSksci5kKHQsXCJkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb25cIixmdW5jdGlvbigpe3JldHVybiBVfSksci5kKHQsXCJfX1dBU01fQVZBSUxBQkxFXCIsZnVuY3Rpb24oKXtyZXR1cm4gRX0pfV0pfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2dwYWNrLm1pbi5qcy5tYXAiLCJcbi8vdmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsaW5nSW1wbGVtZW50YXRpb24oZXJyLCByZXMpe1xuXHQvL2NvbnNvbGUubG9nKGVyci5zdGFjayk7XG5cdGlmKGVycikgdGhyb3cgZXJyO1xuXHRyZXR1cm4gcmVzO1xufVxuXG5yZXF1aXJlKFwiLi9saWIvb3ZlcndyaXRlUmVxdWlyZVwiKTtcbi8qXG5jb25zdCBQU0tCdWZmZXIgPSByZXF1aXJlKCdwc2tidWZmZXInKTtcbiQkLlBTS0J1ZmZlciA9IFBTS0J1ZmZlcjsgKi9cblxuXG4kJC5vYnNvbGV0ZShcIlBsZWFzZSByZW1vdmUgJCQuZXJyb3JIYW5kbGVyICBhc2FwXCIpO1xuJCQuZXJyb3JIYW5kbGVyID0ge1xuICAgICAgICBlcnJvcjpmdW5jdGlvbihlcnIsIGFyZ3MsIG1zZyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIsIFwiVW5rbm93biBlcnJvciBmcm9tIGZ1bmN0aW9uIGNhbGwgd2l0aCBhcmd1bWVudHM6XCIsIGFyZ3MsIFwiTWVzc2FnZTpcIiwgbXNnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3dFcnJvcjpmdW5jdGlvbihlcnIsIGFyZ3MsIG1zZyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIsIFwiVW5rbm93biBlcnJvciBmcm9tIGZ1bmN0aW9uIGNhbGwgd2l0aCBhcmd1bWVudHM6XCIsIGFyZ3MsIFwiTWVzc2FnZTpcIiwgbXNnKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSxcbiAgICAgICAgaWdub3JlUG9zc2libGVFcnJvcjogZnVuY3Rpb24obmFtZSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3ludGF4RXJyb3I6ZnVuY3Rpb24ocHJvcGVydHksIHN3YXJtLCB0ZXh0KXtcbiAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiTWlzc3BlbGxlZCBtZW1iZXIgbmFtZSBvciBvdGhlciBpbnRlcm5hbCBlcnJvciFcIik7XG4gICAgICAgICAgICB2YXIgc3dhcm1OYW1lO1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzd2FybSA9PSBcInN0cmluZ1wiKXtcbiAgICAgICAgICAgICAgICAgICAgc3dhcm1OYW1lID0gc3dhcm07XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgaWYoc3dhcm0gJiYgc3dhcm0ubWV0YSl7XG4gICAgICAgICAgICAgICAgICAgIHN3YXJtTmFtZSAgPSBzd2FybS5tZXRhLnN3YXJtVHlwZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dhcm1OYW1lID0gc3dhcm0uZ2V0SW5uZXJWYWx1ZSgpLm1ldGEuc3dhcm1UeXBlTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgICAgICAgICAgc3dhcm1OYW1lID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihwcm9wZXJ0eSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcm9uZyBtZW1iZXIgbmFtZSBcIiwgcHJvcGVydHksICBcIiBpbiBzd2FybSBcIiwgc3dhcm1OYW1lKTtcbiAgICAgICAgICAgICAgICBpZih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIHN3YXJtXCIsIHN3YXJtTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcbiAgICAgICAgd2FybmluZzpmdW5jdGlvbihtc2cpe1xuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuJCQub2Jzb2xldGUoXCJQbGVhc2UgcmVtb3ZlICQkLnNhZmVFcnJvckhhbmRsaW5nIGFzYXBcIik7XG4kJC5zYWZlRXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICAgICAgaWYoY2FsbGJhY2spe1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEVycm9ySGFuZGxpbmdJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4kJC5vYnNvbGV0ZShcIlBsZWFzZSByZW1vdmUgJCQuX19pbnRlcm4gYXNhcFwiKTtcbiQkLl9faW50ZXJuID0ge1xuICAgICAgICBta0FyZ3M6ZnVuY3Rpb24oYXJncyxwb3Mpe1xuICAgICAgICAgICAgdmFyIGFyZ3NBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gcG9zOyBpIDwgYXJncy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgYXJnc0FycmF5LnB1c2goYXJnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnc0FycmF5O1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbnZhciBzd2FybVV0aWxzID0gcmVxdWlyZShcIi4vbGliL2Nob3Jlb2dyYXBoaWVzL3N3YXJtXCIpO1xudmFyIGFzc2V0VXRpbHMgPSByZXF1aXJlKFwiLi9saWIvdXRpbGl0eUZ1bmN0aW9ucy9hc3NldFwiKTtcblxudmFyIHRyYW5zYWN0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi9saWIvdXRpbGl0eUZ1bmN0aW9ucy90cmFuc2FjdGlvblwiKTtcbiQkLmRlZmF1bHRFcnJvckhhbmRsaW5nSW1wbGVtZW50YXRpb24gPSBkZWZhdWx0RXJyb3JIYW5kbGluZ0ltcGxlbWVudGF0aW9uO1xuXG52YXIgY2FsbGZsb3dNb2R1bGUgPSByZXF1aXJlKFwiLi9saWIvc3dhcm1EZXNjcmlwdGlvblwiKTtcbiQkLmNhbGxmbG93cyAgICAgICAgPSBjYWxsZmxvd01vZHVsZS5jcmVhdGVTd2FybUVuZ2luZShcImNhbGxmbG93XCIpO1xuJCQuY2FsbGZsb3cgICAgICAgICA9ICQkLmNhbGxmbG93cztcbiQkLmZsb3cgICAgICAgICAgICAgPSAkJC5jYWxsZmxvd3M7XG4kJC5mbG93cyAgICAgICAgICAgID0gJCQuY2FsbGZsb3dzO1xuXG4kJC5zd2FybXMgICAgICAgICAgID0gY2FsbGZsb3dNb2R1bGUuY3JlYXRlU3dhcm1FbmdpbmUoXCJzd2FybVwiLCBzd2FybVV0aWxzKTtcbiQkLnN3YXJtICAgICAgICAgICAgPSAkJC5zd2FybXM7XG4kJC5jb250cmFjdHMgICAgICAgID0gY2FsbGZsb3dNb2R1bGUuY3JlYXRlU3dhcm1FbmdpbmUoXCJjb250cmFjdFwiLCBzd2FybVV0aWxzKTtcbiQkLmNvbnRyYWN0ICAgICAgICAgPSAkJC5jb250cmFjdHM7XG4kJC5hc3NldHMgICAgICAgICAgID0gY2FsbGZsb3dNb2R1bGUuY3JlYXRlU3dhcm1FbmdpbmUoXCJhc3NldFwiLCBhc3NldFV0aWxzKTtcbiQkLmFzc2V0ICAgICAgICAgICAgPSAkJC5hc3NldHM7XG4kJC50cmFuc2FjdGlvbnMgICAgID0gY2FsbGZsb3dNb2R1bGUuY3JlYXRlU3dhcm1FbmdpbmUoXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvblV0aWxzKTtcbiQkLnRyYW5zYWN0aW9uICAgICAgPSAkJC50cmFuc2FjdGlvbnM7XG5cblxuJCQuUFNLX1B1YlN1YiA9IHJlcXVpcmUoXCJzb3VuZHB1YnN1YlwiKS5zb3VuZFB1YlN1YjtcblxuJCQuc2VjdXJpdHlDb250ZXh0ID0gXCJzeXN0ZW1cIjtcbiQkLmxpYnJhcnlQcmVmaXggPSBcImdsb2JhbFwiO1xuJCQubGlicmFyaWVzID0ge1xuICAgIGdsb2JhbDp7XG5cbiAgICB9XG59O1xuXG4kJC5pbnRlcmNlcHRvciA9IHJlcXVpcmUoXCIuL2xpYi9JbnRlcmNlcHRvclJlZ2lzdHJ5XCIpLmNyZWF0ZUludGVyY2VwdG9yUmVnaXN0cnkoKTtcblxuJCQubG9hZExpYnJhcnkgPSByZXF1aXJlKFwiLi9saWIvbG9hZExpYnJhcnlcIikubG9hZExpYnJhcnk7XG5cbnJlcXVpcmVMaWJyYXJ5ID0gZnVuY3Rpb24obmFtZSl7XG4gICAgLy92YXIgYWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKCAgJCQuX19nbG9iYWwuX19sb2FkTGlicmFyeVJvb3QgKyBuYW1lKTtcbiAgICByZXR1cm4gJCQubG9hZExpYnJhcnkobmFtZSxuYW1lKTtcbn07XG5cbnJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxuLyovL1RPRE86IFNIT1VMRCBiZSBtb3ZlZCBpbiAkJC5fX2dsb2JhbHNcbiQkLmVuc3VyZUZvbGRlckV4aXN0cyA9IGZ1bmN0aW9uIChmb2xkZXIsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxvdyA9ICQkLmZsb3cuc3RhcnQoXCJ1dGlscy5ta0RpclJlY1wiKTtcbiAgICBmbG93Lm1ha2UoZm9sZGVyLCBjYWxsYmFjayk7XG59O1xuXG4kJC5lbnN1cmVMaW5rRXhpc3RzID0gZnVuY3Rpb24gKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBmbG93ID0gJCQuZmxvdy5zdGFydChcInV0aWxzLm1rRGlyUmVjXCIpO1xuICAgIGZsb3cubWFrZUxpbmsoZXhpc3RpbmdQYXRoLCBuZXdQYXRoLCBjYWxsYmFjayk7XG59OyovXG5cbiQkLnBhdGhOb3JtYWxpemUgPSBmdW5jdGlvbiAocGF0aFRvTm9ybWFsaXplKSB7XG4gICAgY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgIHBhdGhUb05vcm1hbGl6ZSA9IHBhdGgubm9ybWFsaXplKHBhdGhUb05vcm1hbGl6ZSk7XG5cbiAgICByZXR1cm4gcGF0aFRvTm9ybWFsaXplLnJlcGxhY2UoL1tcXC9cXFxcXS9nLCBwYXRoLnNlcCk7XG59O1xuXG4vLyBhZGQgaW50ZXJjZXB0b3JzXG5cbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4kJC5pbnRlcmNlcHRvci5yZWdpc3RlcignKicsICcqJywgJ2JlZm9yZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzd2FybVR5cGVOYW1lID0gdGhpcy5nZXRNZXRhZGF0YSgnc3dhcm1UeXBlTmFtZScpO1xuICAgIGNvbnN0IHBoYXNlTmFtZSA9IHRoaXMuZ2V0TWV0YWRhdGEoJ3BoYXNlTmFtZScpO1xuICAgIGNvbnN0IHN3YXJtSWQgPSB0aGlzLmdldE1ldGFkYXRhKCdzd2FybUlkJyk7XG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIHRoaXMuc2V0TWV0YWRhdGEoJ2V4ZWN1dGlvbklkJywgZXhlY3V0aW9uSWQpO1xuXG4gICAgJCQuZXZlbnQoJ3N3YXJtLmNhbGwuYmVmb3JlJywge3N3YXJtVHlwZU5hbWUsIHBoYXNlTmFtZSwgZXhlY3V0aW9uSWR9KTtcbn0pO1xuXG4kJC5pbnRlcmNlcHRvci5yZWdpc3RlcignKicsICcqJywgJ2FmdGVyJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHN3YXJtVHlwZU5hbWUgPSB0aGlzLmdldE1ldGFkYXRhKCdzd2FybVR5cGVOYW1lJyk7XG4gICAgY29uc3QgcGhhc2VOYW1lID0gdGhpcy5nZXRNZXRhZGF0YSgncGhhc2VOYW1lJyk7XG4gICAgY29uc3QgZXhlY3V0aW9uSWQgPSB0aGlzLmdldE1ldGFkYXRhKCdleGVjdXRpb25JZCcpO1xuXG4gICAgdGhpcy5zZXRNZXRhZGF0YSgnZXhlY3V0aW9uSWQnLCB1bmRlZmluZWQpO1xuXG4gICAgJCQuZXZlbnQoJ3N3YXJtLmNhbGwudGltZScsIHtzd2FybVR5cGVOYW1lLCBwaGFzZU5hbWUsIGV4ZWN1dGlvbklkfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgXHRcdFx0XHRjcmVhdGVTd2FybUVuZ2luZTogcmVxdWlyZShcIi4vbGliL3N3YXJtRGVzY3JpcHRpb25cIikuY3JlYXRlU3dhcm1FbmdpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUpvaW5Qb2ludDogcmVxdWlyZShcIi4vbGliL3BhcmFsbGVsSm9pblBvaW50XCIpLmNyZWF0ZUpvaW5Qb2ludCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2VyaWFsSm9pblBvaW50OiByZXF1aXJlKFwiLi9saWIvc2VyaWFsSm9pblBvaW50XCIpLmNyZWF0ZVNlcmlhbEpvaW5Qb2ludCxcbiAgICAgICAgICAgICAgICAgICAgc3dhcm1JbnN0YW5jZU1hbmFnZXI6IHJlcXVpcmUoXCIuL2xpYi9jaG9yZW9ncmFwaGllcy9zd2FybUluc3RhbmNlc01hbmFnZXJcIiksXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUludGVybmFsU3dhcm1Sb3V0aW5nOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZHVtbXlWTShuYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzb2x2ZVN3YXJtKHN3YXJtKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCQuc3dhcm1zSW5zdGFuY2VzTWFuYWdlci5yZXZpdmVfc3dhcm0oc3dhcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkLlBTS19QdWJTdWIuc3Vic2NyaWJlKG5hbWUsIHNvbHZlU3dhcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgYSBmYWtlIGV4ZWN1dGlvbiBjb250ZXh0Li4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtbXlWTSgkJC5DT05TVEFOVFMuU1dBUk1fRk9SX0VYRUNVVElPTik7XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0fTtcbiIsImlmKHR5cGVvZiBzaW5nbGV0b25fY29udGFpbmVyX21vZHVsZV93b3JrYXJvdW5kX2Zvcl93aXJlZF9ub2RlX2pzX2NhY2hpbmcgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzaW5nbGV0b25fY29udGFpbmVyX21vZHVsZV93b3JrYXJvdW5kX2Zvcl93aXJlZF9ub2RlX2pzX2NhY2hpbmcgICA9IG1vZHVsZTtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaW5nbGV0b25fY29udGFpbmVyX21vZHVsZV93b3JrYXJvdW5kX2Zvcl93aXJlZF9ub2RlX2pzX2NhY2hpbmcgLmV4cG9ydHM7XG4gICAgcmV0dXJuIG1vZHVsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVkIGJ5IHNhbGJvYWllIG9uIDQvMjcvMTUuXG4gKi9cbmZ1bmN0aW9uIENvbnRhaW5lcihlcnJvckhhbmRsZXIpe1xuICAgIHZhciB0aGluZ3MgPSB7fTsgICAgICAgIC8vdGhlIGFjdHVhbCB2YWx1ZXMgZm9yIG91ciBzZXJ2aWNlcywgdGhpbmdzXG4gICAgdmFyIGltbWVkaWF0ZSA9IHt9OyAgICAgLy9ob3cgZGVwZW5kZW5jaWVzIHdlcmUgZGVjbGFyZWRcbiAgICB2YXIgY2FsbGJhY2tzID0ge307ICAgICAvL2NhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBmb3IgZWFjaCBkZXBlbmRlbmN5IGRlY2xhcmF0aW9uXG4gICAgdmFyIGRlcHNDb3VudGVyID0ge307ICAgLy9jb3VudCBkZXBlbmRlbmNpZXNcbiAgICB2YXIgcmV2ZXJzZWRUcmVlID0ge307ICAvL3JldmVyc2VkIGRlcGVuZGVuY2llcywgb3Bwb3NpdGUgb2YgaW1tZWRpYXRlIG9iamVjdFxuXG4gICAgIHRoaXMuZHVtcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICBjb25zb2xlLmxvZyhcIkNvbmF0aW5lciBkdW1wXFxuIFRoaW5nczpcIiwgdGhpbmdzLCBcIlxcbkRlcHMgY291bnRlcjogXCIsIGRlcHNDb3VudGVyLCBcIlxcblN0cmlnaHQ6XCIsIGltbWVkaWF0ZSwgXCJcXG5SZXZlcnNlZDpcIiwgcmV2ZXJzZWRUcmVlKTtcbiAgICAgfTtcblxuICAgIGZ1bmN0aW9uIGluY0NvdW50ZXIobmFtZSl7XG4gICAgICAgIGlmKCFkZXBzQ291bnRlcltuYW1lXSl7XG4gICAgICAgICAgICBkZXBzQ291bnRlcltuYW1lXSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXBzQ291bnRlcltuYW1lXSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0RGVwZW5kZW5jeWluUlQobm9kZU5hbWUsIGRlcGVuZGVuY2llcyl7XG4gICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW1OYW1lKXtcbiAgICAgICAgICAgIHZhciBsID0gcmV2ZXJzZWRUcmVlW2l0ZW1OYW1lXTtcbiAgICAgICAgICAgIGlmKCFsKXtcbiAgICAgICAgICAgICAgICBsID0gcmV2ZXJzZWRUcmVlW2l0ZW1OYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbFtub2RlTmFtZV0gPSBub2RlTmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBkaXNjb3ZlclVwTm9kZXMobm9kZU5hbWUpe1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gREZTKG5uKXtcbiAgICAgICAgICAgIHZhciBsID0gcmV2ZXJzZWRUcmVlW25uXTtcbiAgICAgICAgICAgIGZvcih2YXIgaSBpbiBsKXtcbiAgICAgICAgICAgICAgICBpZighcmVzW2ldKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgREZTKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIERGUyhub2RlTmFtZSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0Q291bnRlcihuYW1lKXtcbiAgICAgICAgdmFyIGRlcGVuZGVuY3lBcnJheSA9IGltbWVkaWF0ZVtuYW1lXTtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICBpZihkZXBlbmRlbmN5QXJyYXkpe1xuICAgICAgICAgICAgZGVwZW5kZW5jeUFycmF5LmZvckVhY2goZnVuY3Rpb24oZGVwKXtcbiAgICAgICAgICAgICAgICBpZih0aGluZ3NbZGVwXSA9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgaW5jQ291bnRlcihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlcHNDb3VudGVyW25hbWVdID0gY291bnRlcjtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNvdW50ZXIgZm9yIFwiLCBuYW1lLCAnIGlzICcsIGNvdW50ZXIpO1xuICAgICAgICByZXR1cm4gY291bnRlcjtcbiAgICB9XG5cbiAgICAvKiByZXR1cm5zIHRob3NlIHRoYXQgYXJlIHJlYWR5IHRvIGJlIHJlc29sdmVkKi9cbiAgICBmdW5jdGlvbiByZXNldFVwQ291bnRlcnMobmFtZSl7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnUmVzZXRpbmcgdXAgY291bnRlcnMgZm9yICcsIG5hbWUsIFwiUmV2ZXJzZTpcIiwgcmV2ZXJzZWRUcmVlW25hbWVdKTtcbiAgICAgICAgdmFyIHVwcyA9IHJldmVyc2VkVHJlZVtuYW1lXTtcbiAgICAgICAgZm9yKHZhciB2IGluIHVwcyl7XG4gICAgICAgICAgICBpZihyZXNldENvdW50ZXIodikgPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIG5hbWUgZm9yIGEgc2VydmljZSwgdmFyaWFibGUsYSAgdGhpbmcgdGhhdCBzaG91bGQgYmUgaW5pdGlhbGlzZWQsIHJlY3JlYXRlZCwgZXRjXG4gICAgICAgICBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIGFycmF5IHdpdGggZGVwZW5kZW5jaWVzXG4gICAgICAgICB0aGUgbGFzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uKGVyciwuLi4pIHRoYXQgaXMgY2FsbGVkIHdoZW4gZGVwZW5kZW5jaWVzIGFyZSByZWFkeSBvciByZWNhbGxlZCB3aGVuIGFyZSBub3QgcmVhZHkgKHN0b3Agd2FzIGNhbGxlZClcbiAgICAgICAgIElmIGVyciBpcyBub3QgdW5kZWZpbmVkIGl0IG1lYW5zIHRoYXQgb25lIG9yIGFueSB1bmRlZmluZWQgdmFyaWFibGVzIGFyZSBub3QgcmVhZHkgYW5kIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBsYXRlclxuICAgICAgICAgQWxsIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHRoZSBjb3JyZXNwb25kaW5nIGFyZ3VtZW50cyBvZiB0aGUgY2FsbGJhY2sgd2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlcyBvZiB0aGUgY29ycmVzcG9uZGluZyBkZXBlbmRlbmN5XG4gICAgICAgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgKG9yIG51bGwpXG4gICAgICovXG4gICAgdGhpcy5kZWNsYXJlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uKG5hbWUsIGRlcGVuZGVuY3lBcnJheSwgY2FsbGJhY2spe1xuICAgICAgICBpZihjYWxsYmFja3NbbmFtZV0pe1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmlnbm9yZVBvc3NpYmxlRXJyb3IoXCJEdXBsaWNhdGUgZGVwZW5kZW5jeTpcIiArIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2tzW25hbWVdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpbW1lZGlhdGVbbmFtZV0gICA9IGRlcGVuZGVuY3lBcnJheTtcbiAgICAgICAgICAgIGluc2VydERlcGVuZGVuY3lpblJUKG5hbWUsIGRlcGVuZGVuY3lBcnJheSk7XG4gICAgICAgICAgICB0aGluZ3NbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuc2F0aXNmaWVkQ291bnRlciA9IHJlc2V0Q291bnRlcihuYW1lKTtcbiAgICAgICAgaWYodW5zYXRpc2ZpZWRDb3VudGVyID09PSAwICl7XG4gICAgICAgICAgICBjYWxsRm9yVGhpbmcobmFtZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbEZvclRoaW5nKG5hbWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLypcbiAgICAgICAgY3JlYXRlIGEgc2VydmljZVxuICAgICAqL1xuICAgIHRoaXMuc2VydmljZSA9IGZ1bmN0aW9uKG5hbWUsIGRlcGVuZGVuY3lBcnJheSwgY29uc3RydWN0b3Ipe1xuICAgICAgICB0aGlzLmRlY2xhcmVEZXBlbmRlbmN5KG5hbWUsIGRlcGVuZGVuY3lBcnJheSwgY29uc3RydWN0b3IpO1xuICAgIH07XG5cblxuICAgIHZhciBzdWJzeXN0ZW1Db3VudGVyID0gMDtcbiAgICAvKlxuICAgICBjcmVhdGUgYSBhbm9ueW1vdXMgc3Vic3lzdGVtXG4gICAgICovXG4gICAgdGhpcy5zdWJzeXN0ZW0gPSBmdW5jdGlvbihkZXBlbmRlbmN5QXJyYXksIGNvbnN0cnVjdG9yKXtcbiAgICAgICAgc3Vic3lzdGVtQ291bnRlcisrO1xuICAgICAgICB0aGlzLmRlY2xhcmVEZXBlbmRlbmN5KFwiZGljb250YWluZXJfc3Vic3lzdGVtX3BsYWNlaG9sZGVyXCIgKyBzdWJzeXN0ZW1Db3VudGVyLCBkZXBlbmRlbmN5QXJyYXksIGNvbnN0cnVjdG9yKTtcbiAgICB9O1xuXG4gICAgLyogbm90IGRvY3VtZW50ZWQuLiBsaW1ibyBzdGF0ZSovXG4gICAgdGhpcy5mYWN0b3J5ID0gZnVuY3Rpb24obmFtZSwgZGVwZW5kZW5jeUFycmF5LCBjb25zdHJ1Y3Rvcil7XG4gICAgICAgIHRoaXMuZGVjbGFyZURlcGVuZGVuY3kobmFtZSwgZGVwZW5kZW5jeUFycmF5LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvcigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsbEZvclRoaW5nKG5hbWUsIG91dE9mU2VydmljZSl7XG4gICAgICAgIHZhciBhcmdzID0gaW1tZWRpYXRlW25hbWVdLm1hcChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgIHJldHVybiB0aGluZ3NbaXRlbV07XG4gICAgICAgIH0pO1xuICAgICAgICBhcmdzLnVuc2hpZnQob3V0T2ZTZXJ2aWNlKTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY2FsbGJhY2tzW25hbWVdLmFwcGx5KHt9LGFyZ3MpO1xuICAgICAgICB9IGNhdGNoKGVycil7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIudGhyb3dFcnJvcihlcnIpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZihvdXRPZlNlcnZpY2UgfHwgdmFsdWU9PT1udWxsKXsgICAvL2VuYWJsZSByZXR1cm5pbmcgYSB0ZW1wb3JhcnkgZGVwZW5kZW5jeSByZXNvbHV0aW9uIVxuICAgICAgICAgICAgaWYodGhpbmdzW25hbWVdKXtcbiAgICAgICAgICAgICAgICB0aGluZ3NbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc2V0VXBDb3VudGVycyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdWNjZXNzIHJlc29sdmluZyBcIiwgbmFtZSwgXCI6XCIsIHZhbHVlLCBcIk90aGVyIHJlYWR5OlwiLCBvdGhlclJlYWR5KTtcbiAgICAgICAgICAgIGlmKCF2YWx1ZSl7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAge1wicGxhY2Vob2xkZXJcIjogbmFtZX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBvdGhlclJlYWR5ID0gcmVzZXRVcENvdW50ZXJzKG5hbWUpO1xuICAgICAgICAgICAgb3RoZXJSZWFkeS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgICAgIGNhbGxGb3JUaGluZyhpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICAgIERlY2xhcmUgdGhhdCBhIG5hbWUgaXMgcmVhZHksIHJlc29sdmVkIGFuZCBzaG91bGQgdHJ5IHRvIHJlc29sdmUgYWxsIG90aGVyIHdhaXRpbmcgZm9yIGl0XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlICAgID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuICAgICAgICB0aGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgdmFyIG90aGVyUmVhZHkgPSByZXNldFVwQ291bnRlcnMobmFtZSk7XG5cbiAgICAgICAgb3RoZXJSZWFkeS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgY2FsbEZvclRoaW5nKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgICB0aGlzLmluc3RhbmNlRmFjdG9yeSA9IGZ1bmN0aW9uKG5hbWUsIGRlcGVuZGVuY3lBcnJheSwgY29uc3RydWN0b3Ipe1xuICAgICAgICBlcnJvckhhbmRsZXIubm90SW1wbGVtZW50ZWQoXCJpbnN0YW5jZUZhY3RvcnkgaXMgcGxhbm5lZCBidXQgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAgICBEZWNsYXJlIHRoYXQgYSBzZXJ2aWNlIG9yIGZlYXR1cmUgaXMgbm90IHdvcmtpbmcgcHJvcGVybHkuIEFsbCBzZXJ2aWNlcyBkZXBlbmRpbmcgb24gdGhpcyB3aWxsIGdldCBub3RpZmllZFxuICAgICAqL1xuICAgIHRoaXMub3V0T2ZTZXJ2aWNlICAgID0gZnVuY3Rpb24obmFtZSl7XG4gICAgICAgIHRoaW5nc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIHZhciB1cE5vZGVzID0gZGlzY292ZXJVcE5vZGVzKG5hbWUpO1xuICAgICAgICB1cE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICB0aGluZ3NbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgY2FsbEZvclRoaW5nKG5vZGUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5cbmV4cG9ydHMubmV3Q29udGFpbmVyICAgID0gZnVuY3Rpb24oY2hlY2tzTGlicmFyeSl7XG4gICAgcmV0dXJuIG5ldyBDb250YWluZXIoY2hlY2tzTGlicmFyeSk7XG59O1xuXG4vL2V4cG9ydHMuY29udGFpbmVyID0gbmV3IENvbnRhaW5lcigkJC5lcnJvckhhbmRsZXIpOyIsImV4cG9ydHMuZG9tYWluUHViU3ViID0gcmVxdWlyZShcIi4vZG9tYWluUHViU3ViXCIpOyIsIlxuLyoqXG4gKiBHZW5lcmljIGZ1bmN0aW9uIHVzZWQgdG8gcmVnaXN0ZXJzIG1ldGhvZHMgc3VjaCBhcyBhc3NlcnRzLCBsb2dnaW5nLCBldGMuIG9uIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKiBAcGFyYW0gbmFtZSB7U3RyaW5nKX0gLSBuYW1lIG9mIHRoZSBtZXRob2QgKHVzZSBjYXNlKSB0byBiZSByZWdpc3RlcmVkLlxuICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufSAtIGhhbmRsZXIgdG8gYmUgaW52b2tlZC5cbiAqIEBwYXJhbSBwYXJhbXNEZXNjcmlwdGlvbiB7T2JqZWN0fSAtIHBhcmFtZXRlcnMgZGVzY3JpcHRpb25zXG4gKiBAcGFyYW0gYWZ0ZXIge0Z1bmN0aW9ufSAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gZXhlY3V0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFkZFVzZUNhc2UobmFtZSwgZnVuYywgcGFyYW1zRGVzY3JpcHRpb24sIGFmdGVyKXtcbiAgICB2YXIgbmV3RnVuYyA9IGZ1bmM7XG4gICAgaWYodHlwZW9mIGFmdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbmV3RnVuYyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIGFmdGVyKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgb3ZlcnJpZGRlblxuICAgIGNvbnN0IHByb3RlY3RlZFByb3BlcnRpZXMgPSBbICdhZGRDaGVjaycsICdhZGRDYXNlJywgJ3JlZ2lzdGVyJyBdO1xuICAgIGlmKHByb3RlY3RlZFByb3BlcnRpZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpe1xuICAgICAgICB0aGlzW25hbWVdID0gbmV3RnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnQgb3ZlcndyaXRlICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXNEZXNjcmlwdGlvbil7XG4gICAgICAgIHRoaXMucGFyYW1zW25hbWVdID0gcGFyYW1zRGVzY3JpcHRpb247XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYWxpYXMgdG8gYW4gZXhpc3RpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0gbmFtZTEge1N0cmluZ30gLSBOZXcgZnVuY3Rpb24gbmFtZS5cbiAqIEBwYXJhbSBuYW1lMiB7U3RyaW5nfSAtIEV4aXN0aW5nIGZ1bmN0aW9uIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGFsaWFzKG5hbWUxLCBuYW1lMil7XG4gICAgdGhpc1tuYW1lMV0gPSB0aGlzW25hbWUyXTtcbn1cblxuLyoqXG4gKiBTaW5nbGV0b24gZm9yIGFkZGluZyB2YXJpb3VzIGZ1bmN0aW9ucyBmb3IgdXNlIGNhc2VzIHJlZ2FyZGluZyBsb2dnaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvZ3NDb3JlKCl7XG4gICAgdGhpcy5wYXJhbXMgPSB7fTtcbn1cblxuLyoqXG4gKiBTaW5nbGV0b24gZm9yIGFkZGluZyB5b3VyIHZhcmlvdXMgZnVuY3Rpb25zIGZvciBhc3NlcnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFzc2VydENvcmUoKXtcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xufVxuXG4vKipcbiAqIFNpbmdsZXRvbiBmb3IgYWRkaW5nIHlvdXIgdmFyaW91cyBmdW5jdGlvbnMgZm9yIGNoZWNrcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDaGVja0NvcmUoKXtcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xufVxuXG4vKipcbiAqIFNpbmdsZXRvbiBmb3IgYWRkaW5nIHlvdXIgdmFyaW91cyBmdW5jdGlvbnMgZm9yIGdlbmVyYXRpbmcgZXhjZXB0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFeGNlcHRpb25zQ29yZSgpe1xuICAgIHRoaXMucGFyYW1zID0ge307XG59XG5cbi8qKlxuICogU2luZ2xldG9uIGZvciBhZGRpbmcgeW91ciB2YXJpb3VzIGZ1bmN0aW9ucyBmb3IgcnVubmluZyB0ZXN0cy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUZXN0UnVubmVyQ29yZSgpe1xufVxuXG5Mb2dzQ29yZS5wcm90b3R5cGUuYWRkQ2FzZSAgICAgICAgICAgPSBhZGRVc2VDYXNlO1xuQXNzZXJ0Q29yZS5wcm90b3R5cGUuYWRkQ2hlY2sgICAgICAgID0gYWRkVXNlQ2FzZTtcbkNoZWNrQ29yZS5wcm90b3R5cGUuYWRkQ2hlY2sgICAgICAgICA9IGFkZFVzZUNhc2U7XG5FeGNlcHRpb25zQ29yZS5wcm90b3R5cGUucmVnaXN0ZXIgICAgPSBhZGRVc2VDYXNlO1xuXG5Mb2dzQ29yZS5wcm90b3R5cGUuYWxpYXMgICAgICAgICAgICAgPSBhbGlhcztcbkFzc2VydENvcmUucHJvdG90eXBlLmFsaWFzICAgICAgICAgICA9IGFsaWFzO1xuQ2hlY2tDb3JlLnByb3RvdHlwZS5hbGlhcyAgICAgICAgICAgID0gYWxpYXM7XG5FeGNlcHRpb25zQ29yZS5wcm90b3R5cGUuYWxpYXMgICAgICAgPSBhbGlhcztcblxuLy8gQ3JlYXRlIG1vZHVsZXNcbnZhciBhc3NlcnRPYmogICAgICAgPSBuZXcgQXNzZXJ0Q29yZSgpO1xudmFyIGNoZWNrT2JqICAgICAgICA9IG5ldyBDaGVja0NvcmUoKTtcbnZhciBleGNlcHRpb25zT2JqICAgPSBuZXcgRXhjZXB0aW9uc0NvcmUoKTtcbnZhciBsb2dnZXJPYmogICAgICAgPSBuZXcgTG9nc0NvcmUoKTtcbnZhciB0ZXN0UnVubmVyT2JqICAgPSBuZXcgVGVzdFJ1bm5lckNvcmUoKTtcblxuLy8gRXhwb3J0IG1vZHVsZXNcbmV4cG9ydHMuYXNzZXJ0ICAgICAgPSBhc3NlcnRPYmo7XG5leHBvcnRzLmNoZWNrICAgICAgID0gY2hlY2tPYmo7XG5leHBvcnRzLmV4Y2VwdGlvbnMgID0gZXhjZXB0aW9uc09iajtcbmV4cG9ydHMubG9nZ2VyICAgICAgPSBsb2dnZXJPYmo7XG5leHBvcnRzLnRlc3RSdW5uZXIgID0gdGVzdFJ1bm5lck9iajtcblxuLy8gSW5pdGlhbGlzZSBtb2R1bGVzXG5yZXF1aXJlKFwiLi9zdGFuZGFyZEFzc2VydHMuanNcIikuaW5pdChleHBvcnRzLCBsb2dnZXJPYmopO1xucmVxdWlyZShcIi4vc3RhbmRhcmRMb2dzLmpzXCIpLmluaXQoZXhwb3J0cyk7XG5yZXF1aXJlKFwiLi9zdGFuZGFyZEV4Y2VwdGlvbnMuanNcIikuaW5pdChleHBvcnRzKTtcbnJlcXVpcmUoXCIuL3N0YW5kYXJkQ2hlY2tzLmpzXCIpLmluaXQoZXhwb3J0cyk7XG5yZXF1aXJlKFwiLi90ZXN0UnVubmVyLmpzXCIpLmluaXQoZXhwb3J0cyk7XG5cbi8vIEdsb2JhbCBVbmNhdWdodCBFeGNlcHRpb24gaGFuZGxlci5cbmlmKHByb2Nlc3Mub24pXG57XG4gICAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0Y29uc3QgdGFnID0gXCJ1bmNhdWdodEV4Y2VwdGlvblwiO1xuXHRcdGNvbnNvbGUubG9nKHRhZywgZXJyKTtcblx0XHRjb25zb2xlLmxvZyh0YWcsIGVyci5zdGFjayk7XG5cdH0pO1xufSIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcdFx0XHRcdGNyZWF0ZVF1ZTogcmVxdWlyZShcIi4vbGliL2ZvbGRlck1RXCIpLmdldEZvbGRlclF1ZXVlXG5cdFx0XHRcdFx0Ly9mb2xkZXJNUTogcmVxdWlyZShcIi4vbGliL2ZvbGRlck1RXCIpXG59OyIsIi8vY29uc29sZS5sb2cocmVxdWlyZS5yZXNvbHZlKFwiLi9jb21wb25lbnRzLmpzXCIpKTtcbm1vZHVsZS5leHBvcnRzID0gJCQubGlicmFyeShmdW5jdGlvbigpe1xuXHRyZXF1aXJlKFwiLi9jb21wb25lbnRzLmpzXCIpO1xuXHQvKnJlcXVpcmUoXCIuL21rRGlyUmVjLmpzXCIpOyovXG59KSIsImNvbnN0IFBTS0J1ZmZlciA9IHJlcXVpcmUoJy4vbGliL1BTS0J1ZmZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBTS0J1ZmZlcjtcbiIsImNvbnN0IFBza0NyeXB0byA9IHJlcXVpcmUoXCIuL2xpYi9Qc2tDcnlwdG9cIik7XG5jb25zdCBzc3V0aWwgPSByZXF1aXJlKFwiLi9zaWduc2Vuc3VzRFMvc3N1dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBza0NyeXB0bztcblxubW9kdWxlLmV4cG9ydHMuaGFzaFZhbHVlcyA9IHNzdXRpbC5oYXNoVmFsdWVzO1xuXG5pZih0eXBlb2YoX19fRElTQUJMRV9PQlNPTEVURV9aSVBfQVJDSElWRVJfV0FJVF9GT1JfQkFSUykgPT09ICd1bmRlZmluZWQnKXtcbiAgICBtb2R1bGUuZXhwb3J0cy5Qc2tBcmNoaXZlciA9IHJlcXVpcmUoXCIuL2xpYi9wc2stYXJjaGl2ZXJcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzLkR1cGxleFN0cmVhbSA9IHJlcXVpcmUoXCIuL2xpYi91dGlscy9EdXBsZXhTdHJlYW1cIik7XG5cbm1vZHVsZS5leHBvcnRzLmlzU3RyZWFtID0gcmVxdWlyZShcIi4vbGliL3V0aWxzL2lzU3RyZWFtXCIpOyIsImNvbnN0IFBTS0xvZ2dlciA9IHJlcXVpcmUoJy4vc3JjL1BTS0xvZ2dlckNsaWVudC9pbmRleCcpO1xuY29uc3QgRW52aXJvbm1lbnREYXRhUHJvdmlkZXIgPSByZXF1aXJlKCcuL3NyYy91dGlscycpLkVudmlyb25tZW50RGF0YVByb3ZpZGVyO1xuXG5cbmlmKCFnbG9iYWwuaGFzT3duUHJvcGVydHkoJyQkJykpIHtcbiAgICBnbG9iYWwuJCQgPSB7fTtcbn1cblxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBQU0tMb2dnZXIgc2hvdWxkIGJlIHVzZWQgYXMgaXMgd2l0aG91dCBvdmVyd3JpdGluZyBjb25zb2xlLlxuICogVGhlIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIGFkZGVkIHRvIFBTS0xvZ2dlciB0byBsb2cgdG8gY29uc29sZSB0aGUgbWVzc2FnZSBhbmQgdXNlZnVsIG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIG92ZXJ3cml0ZUNvbnNvbGUoKSB7XG4gICAgaWYocHJvY2Vzcy5lbnYuY29udGV4dCA9PT0gJ3NhbmRib3gnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXhlY3V0aW9uIGRldGVjdGVkIGluIHNhbmRib3gsIGNvbnNvbGUgd29uJ3QgYmUgb3ZlcndyaXR0ZW5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dnZXIgPSBQU0tMb2dnZXIuZ2V0TG9nZ2VyKCk7XG5cbiAgICBjb25zdCBvcmlnaW5hbENvbnNvbGUgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjb25zb2xlKS5mb3JFYWNoKGtleSA9PiBvcmlnaW5hbENvbnNvbGVba2V5XSA9IGNvbnNvbGVba2V5XSk7XG5cbiAgICBPYmplY3Qua2V5cyhsb2dnZXIpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICBjb25zb2xlW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgY29uc3QgbG9nID0gbG9nZ2VyW2tleV0uYXBwbHkobG9nZ2VyLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yTWV0YShsb2cubWV0YSk7XG5cbiAgICAgICAgICAgaWYob3JpZ2luYWxDb25zb2xlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc29sZVtrZXldLmFwcGx5KG9yaWdpbmFsQ29uc29sZSwgW2BbJHtjb250ZXh0fV1gLCAuLi5sb2cubWVzc2FnZXNdKTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dEZvck1ldGEobWV0YSkge1xuICAgICAgICBjb25zdCBjb250ZXh0cyA9IHtcbiAgICAgICAgICAgIG5vZGU6IChtZXRhKSA9PiBgbm9kZToke21ldGEuY29udGV4dH1gLFxuICAgICAgICAgICAgZG9tYWluOiAobWV0YSkgPT5gZG9tYWluOiR7bWV0YS5kb21haW59YCxcbiAgICAgICAgICAgIGFnZW50OiAobWV0YSkgPT4gYGRvbWFpbjoke21ldGEuZG9tYWlufTphZ2VudDoke21ldGEuYWdlbnR9YCxcbiAgICAgICAgICAgIHNhbmRib3g6ICgpID0+IGBzYW5kYm94YFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb250ZXh0cy5oYXNPd25Qcm9wZXJ0eShtZXRhLm9yaWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0c1ttZXRhLm9yaWdpbl0obWV0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5jb250ZXh0ICE9PSAnc2FuZGJveCcpIHtcblxuICAgIGNvbnN0IE1lc3NhZ2VQdWJsaXNoZXIgPSByZXF1aXJlKCcuL3NyYy9NZXNzYWdlUHVibGlzaGVyJyk7XG4gICAgY29uc3QgTWVzc2FnZVN1YnNjcmliZXIgPSByZXF1aXJlKCcuL3NyYy9NZXNzYWdlU3Vic2NyaWJlcicpO1xuICAgIGNvbnN0IFB1YlN1YlByb3h5ID0gcmVxdWlyZSgnLi9zcmMvUHViU3ViUHJveHknKTtcblxuICAgIGZ1bmN0aW9uIGVuYWJsZUVudmlyb25tZW50RGF0YURlZmF1bHQoKSB7XG4gICAgICAgIGdsb2JhbC4kJC5nZXRFbnZpcm9ubWVudERhdGEgPSBFbnZpcm9ubWVudERhdGFQcm92aWRlci5nZXRFbnZpcm9ubWVudERhdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5hYmxlRW52aXJvbm1lbnREYXRhRm9yQWdlbnQoKSB7XG4gICAgICAgIGdsb2JhbC4kJC5nZXRFbnZpcm9ubWVudERhdGEgPSBFbnZpcm9ubWVudERhdGFQcm92aWRlci5nZXRFbnZpcm9ubWVudERhdGFGb3JBZ2VudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmFibGVFbnZpcm9ubWVudERhdGFGb3JEb21haW4oKSB7XG4gICAgICAgIGdsb2JhbC4kJC5nZXRFbnZpcm9ubWVudERhdGEgPSBFbnZpcm9ubWVudERhdGFQcm92aWRlci5nZXRFbnZpcm9ubWVudERhdGFGb3JEb21haW47XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgdGhpcyB0byBwcm92aWRlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZvciBvdGhlciBlbnZpcm9ubWVudHMgKGV4OiBmb3IgZG9tYWlucywgYnJvd3NlciBldGMuKVxuICAgICAqL1xuICAgIGlmKHByb2Nlc3MuZW52Lmhhc093blByb3BlcnR5KCdQUklWQVRFU0tZX0FHRU5UX05BTUUnKSkge1xuICAgICAgICBlbmFibGVFbnZpcm9ubWVudERhdGFGb3JBZ2VudCgpO1xuICAgIH0gZWxzZSBpZihwcm9jZXNzLmVudi5oYXNPd25Qcm9wZXJ0eSgnUFJJVkFURVNLWV9ET01BSU5fTkFNRScpKSB7XG4gICAgICAgIGVuYWJsZUVudmlyb25tZW50RGF0YUZvckRvbWFpbigpXG4gICAgfSBlbHNlIGlmKCFnbG9iYWwuJCQuaGFzT3duUHJvcGVydHkoJ2dldEVudmlyb25tZW50RGF0YScpKSB7XG4gICAgICAgIGVuYWJsZUVudmlyb25tZW50RGF0YURlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5NZXNzYWdlUHVibGlzaGVyTW9kdWxlICA9IE1lc3NhZ2VQdWJsaXNoZXI7XG4gICAgbW9kdWxlLmV4cG9ydHMuTWVzc2FnZVN1YnNjcmliZXJNb2R1bGUgPSBNZXNzYWdlU3Vic2NyaWJlcjtcbiAgICBtb2R1bGUuZXhwb3J0cy5QdWJTdWJQcm94eU1vZHVsZSAgICAgICA9IFB1YlN1YlByb3h5O1xufSBlbHNlIHtcbiAgICBnbG9iYWwuJCQuZ2V0RW52aXJvbm1lbnREYXRhID0gRW52aXJvbm1lbnREYXRhUHJvdmlkZXIuZ2V0RW52aXJvbm1lbnREYXRhRm9yU2FuZGJveDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVDb25zb2xlID0gb3ZlcndyaXRlQ29uc29sZTtcbm1vZHVsZS5leHBvcnRzLlBTS0xvZ2dlciA9IFBTS0xvZ2dlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcdFx0XHRcdHNvdW5kUHViU3ViOiByZXF1aXJlKFwiLi9saWIvc291bmRQdWJTdWJcIikuc291bmRQdWJTdWJcbn07IiwibW9kdWxlLmV4cG9ydHMuT3dNID0gcmVxdWlyZShcIi4vbGliL093TVwiKTtcbm1vZHVsZS5leHBvcnRzLmJlZXNIZWFsZXIgPSByZXF1aXJlKFwiLi9saWIvYmVlc0hlYWxlclwiKTtcblxuY29uc3QgdWlkR2VuZXJhdG9yID0gcmVxdWlyZShcIi4vbGliL3VpZEdlbmVyYXRvclwiKS5jcmVhdGVVaWRHZW5lcmF0b3IoMjAwLCAzMik7XG5cbm1vZHVsZS5leHBvcnRzLnNhZmVfdXVpZCA9IHJlcXVpcmUoXCIuL2xpYi9zYWZlLXV1aWRcIikuaW5pdCh1aWRHZW5lcmF0b3IpO1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZSA9IHJlcXVpcmUoXCIuL2xpYi9RdWV1ZVwiKTtcbm1vZHVsZS5leHBvcnRzLmNvbWJvcyA9IHJlcXVpcmUoXCIuL2xpYi9Db21ib3NcIik7XG5cbm1vZHVsZS5leHBvcnRzLnVpZEdlbmVyYXRvciA9IHVpZEdlbmVyYXRvcjtcbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRlVWlkID0gdWlkR2VuZXJhdG9yLmdlbmVyYXRlVWlkO1xuXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVQc2tDb25zb2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9saWIvcHNrY29uc29sZScpO1xufTtcblxuXG5pZih0eXBlb2YgZ2xvYmFsLiQkID09IFwidW5kZWZpbmVkXCIpe1xuICBnbG9iYWwuJCQgPSB7fTtcbn1cblxuaWYodHlwZW9mIGdsb2JhbC4kJC51aWRHZW5lcmF0b3IgPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgJCQudWlkR2VuZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMuc2FmZV91dWlkO1xufVxuIiwiZXhwb3J0cy5mc0V4dCA9IHJlcXVpcmUoXCIuL0ZTRXh0ZW5zaW9uXCIpLmZzRXh0OyJdfQ==
